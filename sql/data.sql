SET NAMES utf8;
SET foreign_key_checks = 0;
SET time_zone = '+02:00';
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

INSERT INTO `mirror_posts` (`id`, `title`, `body`, `date`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\n\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\n\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\n\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\n\n/--code\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\n\\--\n\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58'),
(3,	'Lovec matematik',	'Znáte následující hádanku?\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\n\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\n\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\n\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26'),
(4,	'Tabulkový masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\r\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\r\n\r\nPodívejte se na první ukázku:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\r\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\\--\r\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\r\n\r\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" rowspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">B1</td>\r\n		<td width=\"33%\" rowspan=\"4\">B2</td>\r\n		<td width=\"33%\" colspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" rowspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" rowspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">A1</td>\r\n		<td width=\"33%\" colspan=\"4\">A2</td>\r\n		<td width=\"33%\" rowspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" colspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">C1</td>\r\n		<td width=\"33%\" colspan=\"4\">C2</td>\r\n		<td width=\"33%\" rowspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">D1</td>\r\n		<td width=\"33%\" colspan=\"4\">D2</td>\r\n		<td width=\"33%\" rowspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\r\n\r\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\\--\r\nVýsledek je vidět ve třetí ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\r\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12'),
(6,	'Výpočet mediánu',	'Zadání\r\n======\r\n\r\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\r\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \r\njednoduchost a implementační nenáročnost, paměťová spotřeba.\r\n\r\nDefinice\r\n========\r\n\r\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\r\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\r\njako je tomu například u průměru.\r\n\r\nAnalýza problému\r\n================\r\n\r\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\r\ntotiž o způsob, který zřejmě napadne každého jako první.\r\n\r\nPřímočaré řešení\r\n----------------\r\n\r\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\r\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\r\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\r\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\r\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\r\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\r\npřípadě.\r\n\r\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\r\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\r\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\r\nřazení.\r\n\r\nAlgoritmus FIND\r\n---------------\r\n\r\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\r\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\r\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\r\nmediánu.\r\n\r\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\r\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\r\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\r\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\r\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\r\numístěny na levé straně a prvky větší než pivot zase na pravé.\r\n\r\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\r\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\r\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\r\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\r\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\r\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\r\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\r\nnaším mediánem.\r\n\r\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\r\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\r\nnásledující odstavce.\r\n\r\nAlgoritmus SELECT\r\n-----------------\r\n\r\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\r\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\r\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\r\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\r\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\r\ndělení celé posloupnosti.\r\n\r\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\r\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\r\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\r\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\r\n\r\nSrovnání zmíněných algoritmů\r\n============================\r\n\r\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\r\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\r\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\r\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\r\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\r\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\r\nnejlepší možné řešení.\r\n\r\nZávěr\r\n=====\r\n\r\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\r\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\r\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39'),
(7,	'Osm návrhových přikázání',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14'),
(9,	'Návrhový vzor Singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n}\r\n\\--\r\n\r\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = Object::getInstance();\r\n\\--\r\n\r\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\r\n\r\n/--code php\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\'; //TRUE\r\n} else {\r\n	echo \'$obj1 !== $obj2\';\r\n}\r\n\\--\r\n\r\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = new Object();\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n}\r\n\\--\r\n\r\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = clone $obj1;\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n}\r\n\\--\r\n\r\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = unserialize(serialize($obj1));\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n	private function __wakeup() {}\r\n}\r\n\\--\r\n\r\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	public final function __clone() {\r\n		throw new Exception(\'Objekt nelze klonovat!\');\r\n	}\r\n	public final function __wakeup() {\r\n		throw new Exception(\'Objekt nelze deserializovat!\');\r\n	}\r\n}\r\n\\--',	'2012-12-26 20:38:01'),
(10,	'Návrhový vzor Factory Method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\r\n\r\n/--code php\r\n<?php\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\\--\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	public function test() {\r\n		echo $this->attribute;\r\n	}\r\n}\r\n\\--\r\n\r\nPřípadně jeho rozhraní:\r\n\r\n/--code php\r\n<?php\r\ninterface IObject {\r\n	public function test();\r\n}\r\n\\--\r\n\r\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\r\n\r\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\r\n\r\n/--code php\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance->test();\r\n\\--\r\n\r\nPři zapojení továrny je použití zdánlivě složitější.\r\n\r\n/--code php\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance->test();\r\n\\--\r\n\r\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nA teď přidejme nový atribut - aktuální rok.\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	// ...\r\n}\r\n\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\r\n\r\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39'),
(11,	'Nette 2.1-dev CliRouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem <code>php index.php</code>. Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze <code>php index.php Front:Homepage:default</code>.',	'2013-03-17 22:02:36'),
(74,	'Znovupoužitelný formulář',	'Každý kdo nějakou chvíli pracuje s Nette Frameworkem již jistě narazil na prvky, které lze použít v aplikaci opakovaně. Říkejme jim znovupoužitelné komponenty, nebo prostě jen komponenty. Následující text má za úkol ukázat opět maximálně prakticky a uceleně jedno z možných řešení jak k tomuto problému přistupovat a co se mi na tomto řešení líbí, nebo naopak nelíbí.\n\nMotivace\n========\nProč vůbec přemýšlet o komponentách? Na tuto věc má pravděpodobně dost lidí zcela jiný názor. Pro mě je havní motivací to, že si vyčistím presentery. Chci toho mít v presenterech skutečně tak akorát. Vždyť podle MVP struktury bych v presenterech neměl mít nic složitého. A pak je zde ta znovupoužitelnost. Co když se rozhodnu, že potřebuji použít stejný formulář na více místech? Přece ho nebudu kopírovat. A že takový požadavek je sice často někdo zmíní, ale prakticky není moc reálný? Ale kdepak. Zrovna nedávno jsem vytvářel mnoho stránek a na každé jsem chtěl mít právě kontaktní formulář. To je požadavek na komponentu jako dělaný...\n\nPresenter\n=========\nVždy když programuji něco takového, tak se nedívám na to, jak je to správně z hlediska OOP a bůh ví čeho všeho ještě. Pro mě je v současné chvíli klíčové to, jak se dané řešení bude používat. Přesenter by tedy mohl vypadat třeba takto:\n\n/--code php\n<?php\n\nclass AdminPresenter extends BasePresenter {\n\n	/** @var \\ActualityFactory @inject */\n	public $actualityFactory;\n\n	private $id;\n\n	public function actionAktualita($id = NULL) {\n		$this->id = $id;\n	}\n\n	protected function createComponentForm() {\n		$control = $this->actualityFactory->create($this->id);\n		$control[\'form\']->onSuccess[] = function () {\n			$this->redirect(\'default\');\n		};\n		return $control;\n	}\n\n}\n\\--\n\nMám tedy presenter, který je například pro administraci a jednu podstránku, která bude sloužit jak pro editaci aktuality, tak i pro přidání nové aktuality. Proto je parametrem *action* právě `id = NULL`. Tim totiž říkám, že může přijít jako parametr *ID* aktuality (v tom případě ji budu chtít upravovat), nebo toto *ID* nebude předáno a v tom případě bude hodnota *NULL* a budu s tím později patřičně nakládat.\n\nV poslední metodě si daný formulář vytvořím. Teoreticky by stačila pouze první řádka. Přidávám však ještě další chování do pole `onSuccess[]`, protože chci komponentu používat na více místech, ale pokaždé po úspěchu přesměrovat na jinou stránku. Zde je jedna z věcí které se mi nelíbí. A to je právě to volání `$control[\'form\']->onSuccess[] = ...`. Musím totiž vědět jak je pojmenovaný formulář uvnitř komponenty, což mě ale je skutečnosti vůbec nezajímá. Mnohem raději bych byl třeba za zápis `$control->onSuccess[] = ...`. Chápu, že se nemusí použít komponenta pouze na fomulář, ale přesto. **Neznáte někdo lepší řešení?**\n\nA teď přijde záludná otázka. Co je to ta factory a proč jí vlastně používám?\n\nFactory\n=======\nProtože v komponentách velmi často potřebuji nějaké závislosti, musím je tam nějak dostat. K tomu slouží například generované továrničky. Jedná se vlastně pouze o interface:\n\n/--code php\n<?php\n\ninterface IActualityFactory {\n\n	/** @return \\Cntrl\\Actuality */\n	public function create();\n\n}\n\\--\n\nNette se této továrničky chytí a vytvoří zhruba tento kód:\n\n/--code php\n<?php\n\nfinal class SystemContainer_IActualityFactoryImpl_58_IActualityFactory implements IActualityFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	public function create() {\n		$service = new Cntrl\\Actuality;\n		return $service;\n	}\n\n}\n\\--\n\nZde je tedy (když bude potřeba) možné vytvořit nějaké závislosti a v metodě `create()` je komponentě předat. To vše lze udělat automaticky a Nette se o to postará. Dokonce lze předávat i parametry z konfiguračního souboru. Je to nesmírně elegantní řešení. Kdybych továrničky nepoužil, musel bych vytvářet ručně komponentu, to by ale znamenalo, že bych také musel předávat všechny závislosti ručně a jen bych si tím přidělal práci. Zkuste si vytvořit komponentu bez použití factory. Je nesmysl tahat si v presenteru nepotřebné závislosti přes presenter... Jak však předat parametry z presenteru? Netuším, jestli to lze nějak generovanou továrničku naučit, nic nám však nebrání napsat si vlastní factory:\n\n/--code php\n<?php\n\nclass ActualityFactory extends Nette\\Object {\n\n	private $actualities;\n\n	public function __construct(App\\Actualities $actualities) {\n		$this->actualities = $actualities;\n	}\n\n	public function create($id) {\n		return new \\Cntrl\\Actuality($this->actualities, $id);\n	}\n\n}\n\\--\n\nJe jasně vidět, že tato ručně napsaná factory vypadá velmi podobně jako automaticky vygenerovaná, ale navíc teď můžu předat metodě `create($id)` parametr, což je přesně to co potřebuji viz presenter. Chci si předat číslo aktuality a nevidím důvod proč bych to měl dělat až v komponentě. Komponenta potřebuje *ID* aktuality, ale kde ho vezme nemusí řešit. Je otázka, jestli bych si už rovnou neměl vytáhnout data z databáze v presenteru. Takto se mi to ale zatím líbí víc...\n\nRučně vytvořenou factory musíme ještě zaregistrovat v konfiguračním souboru:\n\n/--code neon\nservices:\n	- ActualityFactory\n\\--\n\nTo je vše. Už jsme pouze krůček od funkčního formuláře.\n\nSamotná komponenta\n==================\nSamotný kód komponenty už není téměř ničím zvláštní, nebo nějak nepochopitelný:\n\n/--code php\n<?php\n\nnamespace Cntrl;\n\nuse App;\nuse Entity;\nuse Nette\\Application\\UI;\nuse Nette;\n\nclass Actuality extends UI\\Control {\n\n	private $actualities;\n	private $actuality;\n\n	public function __construct(App\\Actualities $actualities, $id) {\n		parent::__construct();\n		$this->actualities = $actualities;\n		$this->actuality = $this->actualities->findOneBy([\'id\' => $id]);\n	}\n\n	public function render() {\n		$this->template->setFile(__DIR__ . \'/Actuality.latte\');\n		$this->template->render();\n	}\n\n	protected function createComponentForm() {\n		$form = new UI\\Form;\n		$form->addText(\'headline\', \'Titulek:\');\n		$form->addTextArea(\'text\', \'Text:\');\n		$form->addSubmit(\'send\', \'Uložit\');\n		if($this->actuality) { //výchozí hodnoty jen pokud aktualita již existuje\n			$form->setDefaults(array(\n				\'headline\' => $this->actuality->headline,\n				\'text\' => $this->actuality->text,\n			));\n		}\n		$form->onSuccess[] = $this->actualityFormSucceeded;\n		return $form;\n	}\n\n	public function actualityFormSucceeded(UI\\Form $form) {\n		$values = $form->getValues();\n		try {\n			if(!$this->actuality) { //pokud ještě neexistuje vytvořím novou entitu\n				$this->actuality = new Entity\\Actuality();\n			}\n			$this->actuality->headline = $values->headline;\n			$this->actuality->text = $values->text;\n			$this->actuality->date = new \\DateTime();\n			$this->actualities->save($this->actuality);\n			$this->presenter->flashMessage(\'Aktualita byla úspěšně uložena.\', \'success\');\n		} catch (\\Exception $exc) {\n			$this->presenter->flashMessage($exc->getMessage(), \'danger\');\n		}\n		//žádný redirect, až v presenteru!\n	}\n\n}\n\\--\n\nV konstruktoru jednak získám nějakou modelovou třídu pro práci s databází (o to se krom factory  vůbec nestarám) a také *ID*, které přišlo z presenteru. A rovnou toto *ID* použiju k vytáhnutí si dat z databáze, protože konstruktor se spustí vždy a já také vím, že tyto data budu vždy potřebovat. V `render()` metodě pouze předám šablonu komponenty, která ve své nejprimitivnější podobě může vypada pouze takto:\n\n/--code\n{control form}\n\\--\n\nOstatně stejný kód mohu použít pro šablonu do které předávám komponentu z presenteru. Výsledkem celého snažení je tedy poměrně jednoduchý přesenter a jedna stránka na které je formulář, který zvládne jak editaci, tak vytváření nového záznamu v databázi.\n\nPoužíváte nějaké lepší (jiné) řešení? Podělte se o něj... :-)',	'2014-05-13 11:54:22'),
(54,	'AJAX upload souborů v Nette pomocí Fine Uploaderu',	'<div class=\"alert alert-danger\">Následující text řeší starší verzi FineUploaderu `3.*`, nikoliv nejnovější. Hledáte-li aktuálnější návod, přečtěte si prosím http://www.zeminem.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2...</div>\n\nA je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\nnahrávání souborů v Nette pomocí \"Fine Uploaderu .{target:_blank}\":http://fineuploader.com/.\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\n\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\n\n/--code html\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\n\n/--code html\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\n<div id=\"triggerUpload\">Nahrát obrázky</div>\n\\--\n\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\n\n/--code javascript\n$(function () {\n	if ($(\'#image-uploader\').length != 0) { //test existence elementu\n		$.nette.ext(\'uploader\', {\n			complete: function () { //zavěšení na konec ajaxového požadavku\n				var uploader = $(\'#image-uploader\').fineUploader({\n					request: {\n						endpoint: \'product/default/\' + $(\'#image-uploader\').data(\'id\') + \'?do=upload\'\n					},\n					text: {\n						uploadButton: \'Klikněte, nebo přetáhněte obrázky\',\n						cancelButton: \'zrušit\',\n						failUpload: \'Nahrání obrázku se nezdařilo\',\n						dragZone: \'Přetáhněte soubory sem\',\n						dropProcessing: \'Zpracovávám přetažené soubory...\',\n						formatProgress: \'{percent}% z {total_size}\',\n						waitingForResponse: \'Zpracovávám...\'\n					},\n					autoUpload: false,\n					failedUploadTextDisplay: {\n						mode: \'custom\',\n						maxChars: 70,\n						responseProperty: \'error\',\n						enableTooltip: true\n					}\n				});\n				$(\'#triggerUpload\').click(function () {\n					uploader.fineUploader(\'uploadStoredFiles\');\n				});\n			}\n		});\n	}\n\n	$.nette.init(); //inicializace nette.ajax\n});\n\\--\n\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\nTen může vypadat například takto:\n\n/--code php\npublic function handleUpload($id) {\n	$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\n	$uploader = new \\qqFileUploader($allowedExtensions);\n	//...\n	try {\n		$result = $uploader->handleUpload(__DIR__ . \'/../../../www/uploads/\' . $id . \'/default\', NULL);\n		$result[\'uploadName\'] = $uploader->getUploadName();\n		//...\n	} catch (\\Exception $exc) {\n		$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\n			\'error\' => $exc->getMessage(),\n		)));\n	}\n	$this->invalidateControl();\n	$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\njako úspěšný upload.\n\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na \"GitHubu .{target:_blank}\":https://github.com/Widen/fine-uploader-server a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\no webalize názvů souborů.\n\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použít.\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2013-08-21 22:14:44'),
(44,	'Portál ZČU dočasně mimo provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n<div class=\"alert alert-danger\">Tak dlouho jsem s tímto blogem experimentoval, až jsem o obrázek \npřišel. :-( Představte si tedy prosím screen vyhledávání na kterém je portál ZČU se zaindexovaným\ntitle \"Portál ZČU dočasně mimo provoz&hellip;\"</div>\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:',	'2013-07-28 21:58:42'),
(45,	'Testování presenterů v Nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\r\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\r\nV následujících odstavcích bych rád předvedl myšlenku jak si\r\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\r\n\r\nNezbytná teorie\r\n===============\r\n\r\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\r\na následně daný presenter vyrobit. Například takto:\r\n\r\n/--code php\r\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\r\n\\--\r\n\r\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\r\npomocí inject anotace.\r\n\r\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\r\n\r\n/--code php\r\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n$response = $this->presenter->run($request);\r\n\\--\r\n\r\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \r\nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\r\n\r\n/--code php\r\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\\--\r\n\r\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\r\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\r\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\r\n\r\n/--code php\r\n$html = (string)$response->getSource();\r\n$dom = \\Tester\\DomQuery::fromHtml($html);\r\n\\Tester\\Assert::true($dom->has(\'title\'));\r\n\\--\r\n\r\nPsaní, psaní, psaní...\r\n======================\r\n\r\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\r\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\r\nzačne být lehce kopírovací nuda.\r\n\r\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\r\nMůj první návrh vypadá přibližně takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\nclass Presenter extends \\Nette\\Object {\r\n\r\n        private $container;\r\n        private $presenter;\r\n        private $presName;\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->container = $container;\r\n        }\r\n\r\n        /**\r\n         * @param $presName string Fully qualified presenter name.\r\n         */\r\n        public function init($presName) {\r\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n                $this->presenter = $presenterFactory->createPresenter($presName);\r\n                $this->presenter->autoCanonicalize = FALSE;\r\n                $this->presName = $presName;\r\n        }\r\n\r\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $params[\'action\'] = $action;\r\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n                $response = $this->presenter->run($request);\r\n                return $response;\r\n        }\r\n\r\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $response = $this->test($action, $method, $params, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\r\n                $html = (string)$response->getSource();\r\n                $dom = \\Tester\\DomQuery::fromHtml($html);\r\n                \\Tester\\Assert::true($dom->has(\'title\'));\r\n\r\n                return $response;\r\n        }\r\n\r\n        public function testForm($action, $method = \'POST\', $post = array()) {\r\n                $response = $this->test($action, $method, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\r\n\r\n                return $response;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nTestování samotných presenterů je pak již otázkou několika málo řádek:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\n$container = require __DIR__ . \'/../bootstrap.php\';\r\n\r\nclass HomepagePresenterTest extends \\Tester\\TestCase {\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->tester = new \\Test\\Presenter($container);\r\n        }\r\n\r\n        public function setUp() {\r\n                $this->tester->init(\'Front:Homepage\');\r\n        }\r\n\r\n        public function testRenderDefault() {\r\n                $this->tester->testAction(\'default\');\r\n        }\r\n\r\n}\r\n\r\nid(new HomepagePresenterTest($container))->run();\r\n\\--\r\n\r\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\r\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\r\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.',	'2013-07-28 22:36:38'),
(46,	'CRON validátor',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\r\n\r\nMůžeš tohle, nesmíš tamto\r\n=========================\r\n\r\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\r\n\r\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\r\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\r\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\r\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\r\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\r\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\r\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\r\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\r\n\r\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\r\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\r\numístit sem celý kód alespoň vytvoření:\r\n\r\n/--code php\r\n/**\r\n  * @return Nette\\Application\\UI\\Form\r\n  */\r\nprotected function createComponentAddCron() {\r\n	$form = new Nette\\Application\\UI\\Form;\r\n	$form->addProtection();\r\n	$form->addText(\'minutes\', \'Minuty:\')\r\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\r\n	$form->addText(\'hours\', \'Hodiny:\')\r\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\r\n	$form->addText(\'mdays\', \'Dny měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\r\n	$form->addText(\'months\', \'Měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\r\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\r\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\r\n	$form->addText(\'command\', \'Příkaz:\')\r\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\r\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\r\n	$form->onSuccess[] = $this->addCronSucceeded;\r\n	return $form;\r\n}\r\n\\--\r\n\r\nA rovnou bez hloupých povídání celý validátor:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Fresh;\r\n\r\n/**\r\n * Class ValidateCron - inspired by ISPConfig\r\n * @package Fresh\r\n */\r\nclass ValidateCron extends \\Nette\\Object {\r\n\r\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\r\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\r\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\r\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\r\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\r\n\r\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\r\n        }\r\n\r\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\r\n        }\r\n\r\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\r\n        }\r\n\r\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\r\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\r\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\r\n                } else {\r\n                        return TRUE;\r\n                }\r\n        }\r\n\r\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\r\n        }\r\n\r\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\r\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\r\n                        return FALSE;\r\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\r\n                        return FALSE;\r\n                }\r\n                $time_list = explode(\",\", $value);\r\n                foreach ($time_list as $entry) {\r\n                        // possible value combinations:\r\n                        // x               =>      ^(\\d+)$\r\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\r\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\r\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\r\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\r\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\r\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\r\n                                return FALSE;\r\n                        }\r\n                        // matches contains:\r\n                        // 1       =>      * or value or x-y range\r\n                        // 2       =>      unused\r\n                        // 3       =>      value if [1] != *\r\n                        // 4       =>      empty if no range was used\r\n                        // 5       =>      2nd value of range if [1] != * and range was used\r\n                        // 6       =>      empty if step was not used\r\n                        // 7       =>      step\r\n                        if ($matches[1] == \"*\") {\r\n                                // not to check\r\n                        } else {\r\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\r\n                                        return FALSE;\r\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\r\n                                        // check if value is in allowed range and not less or equal to first value\r\n                                        return FALSE;\r\n                                }\r\n                        }\r\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\r\n                                return FALSE;\r\n                        }\r\n                } // end foreach entry loop\r\n                return TRUE;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\r\n\r\n/--code html\r\n{form $form}\r\n\r\n<ul class=\"error\" n:if=\"$form->allErrors\">\r\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\r\n</ul>\r\n\r\n...\r\n\r\n{/form}\r\n\\--',	'2013-07-28 22:53:32'),
(47,	'Třída pro připojení k FIO API',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://www.zeminem.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n\\--\n\nK tomu se hodí právě následující třída:\n\n/--code php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         * @return array|mixed\n         */\n        public function transactions($from = \'-1 month\', $to = \'now\') {\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date(\'Y\');\n                }\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . \'last/\' . $this->token . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded(\'curl\')) {\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n\\--\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n/--code neon\nparameters:\n	fio_token: \'\' #token pro přístup do FIO banky\n    \n...\n\nservices:\n	- Fresh\\Fio(token: %fio_token%)\n    \n...\n\\--\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.',	'2013-07-29 10:36:44'),
(61,	'Stáhněte si zdarma 897457 emailových adres',	'V následujícím článku bych rád nastínil problematiku newsletterů nejen z programátorského hlediska <s>a také bych se rád opřel do bezpečnosti společnosti Wedos, které mnoho lidí tolik věří</s>... (-:\n\n<span style=\"color:green\">Tento projekt pravděpodobně nemá se společností Wedos nic společného jak jsem si zřejmě mylně myslel.</span>\n\nNa začátku byl email\n====================\nJednoho dne mi přišel email, který byl automaticky filtrován jako spam. Vzhledem k tomu, že když mě něco štve, tak to řeším, spam jsem otevřel a hledal odkaz na odhlášení. Ten byl dobře umístěn, stačilo kliknout a hotovo. Každý přece ví, že to takto má být. Když je odhlášení delší, než kliknutí na spam v email klientovi, je to problém. Bohužel tento odkaz vedlo na doménu <code>m-letter.eu</code>. Mě samozřejmě zajímá jak jsem se dostal do takového spam listu a jelikož jsem byl odkázán na mě neznámou doménu, byl jsem velmi rozezlen.\n\n<s>Zde je nutné říct, že jsem dříve jednal, než pátral. Nakonec se ukázalo, že jsem byl možná v tomto listu oprávněně, jelikož se jedná o doménu, ze které zřejmě Wedos odesílá podobné reklamní emaily, takže je dost pravděpodobné, že jsem s tím dříve souhlasil.</s>\n\n<span style=\"color:green\">Při hlubším pátrání jsem zjistil, že jsem stále nic nezjistil. Chybně jsem tento problém svedl na někoho jiného, což mě odvedlo na špatnou kolej. Stále tedy nevím, kde jsem se na tomto spam listu vzal a opět to beru osobně. Není mi to jedno...</span>\n\nNeštvi programátora\n===================\nCelý reklamní systém je udělán dosti nešťastně, takže než abych pátral jak jsem se tam dostal, soustředil jsem se na něco jiného, co pro mě z pohledu programátora webových aplikací bylo dost zajímavé. URL adresa. Celá adresa pro odhlášení je v následujícím formátu:\n\n/--code\nhttp://www.m-letter.eu/odh.html?c=XXXXXXX&s=53&q=51\n\\--\n\nKde **XXXXXXX** je číslo zhruba od 1300486 do 2197943. To mě zaujalo a tak jsem toto číslo začal měnit. A ukázalo se, že jsem odhlašoval další lidi. V té době ještě tato stránka vypsala informaci o úspěšném odhlášení včetně emailu, který byl odhlášen. Vzhledem k tomu, že stránka je velmi jednoduchá, lze programově stejně jednoduše získat onu emailovou adresu.\n\nJen si představte program, který iteruje tuto URL adresu a jen sbírá emaily. 897457. To je počet emailů které takto získáte. **897457**. Navíc tímto celý systém znehodnotíte, protože všechny odhlásíte. A pro takový počet emailů to již není zanedbatelné.\n\nTo má být jako oprava?\n======================\nNejde mi zrovna o to znehodnotit celý čupr dupr systém na spamování, ale proč ne. Tato informace se poměrně rychle rozšířila a o pár minut později mi byl odepřen přístup na tento server. Navíc výpis byl pozměněn tak, aby již nešlo stáhnout téměř 900 000 emailových adres. Nicméně celý systém zřejmě stále funguje stejně, takže můžete jednoduše iterovat URL adresy a tím celý systém znehodnotit:\n\n/--code php\n<?php\nfor ($i=2197943; $i > 1300486; $i--) {\n    file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\");\n}\n\\--\n\nDoporučuji spustit v příkazové řádce, kde není nastaven pro PHP timeout. Iterace je schválně pozpátku, protože se dá předpokládat, že ty nejnovější záznamy mají větší číslo a ty s malým číslem už dost možná nebudou aktuální. Celý program jsem měl daleko složitější, vzhledem k tomu, že jsem byl připraven na stáhnutí všech emailů. Po změně výpisu již většina programu není potřeba a stačí tedy tři řádky pro znehodnocení celého nezanedbatelně velkého systému.\n\n<s>Dejme tedy někomu z Wedos čas na opravu a pak hurá na hromadný lynč.</s> <span style=\"color:green\">Opět stejný problém jako předtím. Doufám, že mám tentokrát pravdu...</span> Sice jde jen o emailové adresy, ale vzpomeňte si na to až zase budete nadávat na spam, nebo souhlasit s tím, že vaše emailová adresa nebude nikde uveřejněna.',	'2014-01-27 12:33:57'),
(49,	'Using fulltext searching with InnoDB',	'Sometimes is quite useful to use InnoDB engine. \r\nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \r\nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \r\nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \r\nLet me show you how to search via fulltext on InnoDB tables.\r\n\r\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \r\nbut there is possible workaround. At first you need a classic InnoDB structure. \r\nFor example database of  blog:\r\n\r\n/--code sql\r\nSET NAMES utf8;\r\nSET foreign_key_checks = 0;\r\nSET time_zone = \'SYSTEM\';\r\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\r\n\r\nDROP TABLE IF EXISTS `posts`;\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  `date` datetime NOT NULL,\r\n  `release_date` datetime NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `title_3` (`title`(200))\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `tags`;\r\nCREATE TABLE `tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(50) NOT NULL,\r\n  `color` varchar(6) NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `posts_tags`;\r\nCREATE TABLE `posts_tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) NOT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `tag_id` (`tag_id`),\r\n  KEY `post_id` (`post_id`),\r\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\r\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \r\nIt would be nice to be able search on database table **posts** using fulltext search:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\r\n\\--\r\n\r\nBut it is not possible. It returns something like:\r\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\r\n\r\nLet\'s create another one table with triggers and fulltext indexes. \r\nWe need to create mirror table. For example:\r\n\r\n/--code sql\r\nDROP TABLE IF EXISTS `mirror_posts`;\r\nCREATE TABLE `mirror_posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  FULLTEXT KEY `title_body` (`title`,`body`),\r\n  FULLTEXT KEY `title` (`title`),\r\n  FULLTEXT KEY `body` (`body`)\r\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nAnd than we need to create triggers:\r\n\r\n/--code sql\r\nDELIMITER ;;\r\n\r\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\r\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\r\n\r\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\r\nUPDATE mirror_posts SET\r\n    id = NEW.id,\r\n    title = NEW.title,\r\n    body = NEW.body\r\nWHERE id = OLD.id;;\r\n\r\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\r\nDELETE FROM mirror_posts WHERE id = OLD.id;;\r\n\\--\r\n\r\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\r\nFinally we can use more complex fulltext search feature:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM mirror_posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\r\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\r\n\\--\r\n\r\nAs I said, this is just workaround, not solution. \r\nSometimes it\'s bad practice, because you need copy of indexed columns. \r\nBut it works. And for small blogs it\'s sufficient.',	'2013-07-29 21:37:51'),
(50,	'Problémy fulltextu v Nette',	'Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://www.zeminem.cz/using-fulltext-searching-with-innodb).\r\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\r\nbylo řešení \"Jakuba Vrány .{target:_blank}\":http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php.\r\n\r\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\r\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\r\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\r\n\r\nNette, ty jedna zrádná bestie...\r\n================================\r\n\r\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\r\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\r\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\r\npoužití **REGEXP**.\r\n\r\nBěžný kód pro fultextové dotazování může vypadat takto:\r\n\r\n/--code php\r\n/** @var Nette\\Database\\SelectionFactory @inject */\r\npublic $sf;\r\n    \r\n$this->sf->table(\'mirror_posts\')\r\n	->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\r\n	->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\r\n	->limit(50);\r\n\\--\r\n\r\nCož vygeneruje přibližně přesně následující:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE)) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\r\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\r\nposkládám složitější dotaz:\r\n\r\n/--code php\r\n$where = \"\";\r\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE \'ft_min_word_len\'\"), 0, 1);\r\n$ft_min_word_len = 4;\r\npreg_match_all(\"~[\\\\pL\\\\pN_]+(\'[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\r\nforeach ($matches[0] as $part) {\r\n	if (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\r\n		$regexp = \"REGEXP \'[[:<:]]\" . addslashes($part) . \"[[:>:]]\'\";\r\n		$where .= \" OR (title $regexp OR body $regexp)\";\r\n	}\r\n}\r\n\\--\r\n\r\nA doplníme fluidní dotaz:\r\n\r\n/--code php\r\n...\r\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\r\n...\r\n\\--\r\n\r\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\r\n\r\n/--code sql\r\nSELECT `id` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]`api`[[:>:]]\' OR `body` REGEXP \'[[:<:]]`api`[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\r\nDůvodem jsou zpětné uvozovky v regulárním výrazu **\'\'[[:<:]]`api`[[:>:]]\'\'**.\r\n\r\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\r\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\r\npřímo ptá databáze. Existuje však vyčůranější způsob.\r\n\r\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\r\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\r\n\r\n/--code php\r\n$regexp = \"REGEXP \'[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]\'\";\r\n\\--\r\n\r\nA dotaz se následně poskládá strávně:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]API[[:>:]]\' OR `body` REGEXP \'[[:<:]]API[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\r\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\r\n\r\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\r\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\r\nale je to divné.',	'2013-07-30 22:15:33'),
(51,	'Routování v Nette - prakticky',	'<div class=\"alert alert-success\">Tento článek byl naposledy revidován, aktualizován a rozšířen <strong>27. června 2014</strong>. Snažím se jej držet stále aktuální&hellip;</div>\n\nV následujícím článku se budu opírat o teorii napsanou v \"dokumentaci\":http://doc.nette.org/cs/routing.\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\n\nZáklad všeho je porozumět tomu, jak se v Nette vytváří \"odkazy\":http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu.\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\n\nPrvní kroky\n===========\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu:\n\n/--code\napp/\n├─── config/\n├─── model/\n├─── presenters/\n│     └── HomepagePresenter.php\n│\n├─── router/\n├─── templates/\n│     ├── Homepage/\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\n│     │    └── ...\n│     └── @layout.latte\n│\n└─── bootstrap.php\n\\--\n\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\n\n/--code php\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n\\--\n\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\n\n/--code\nhttp://www.zeminem.cz/homepage/kontakt\n\\--\n\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibližně následující:\nBude-li se někdo odkazovat v obecném tvaru `Presenter:view`, pochop `Presenter` jako název presenteru (např. **Homepage**Presenter) a hledej tedy soubor `HomepagePresenter.php`\na `view` bude šablona presenteru, hledej ji tedy ve složce `Presenter/view.latte` a sestav URL která bude přesně v tomto tvaru.\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\n\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\n\n/--code php\n$router[] = new Route(\'<action>\', \'Homepage:default\');\n\\--\n\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\nse mění cílová šablona podle URL:\n\n/--code\nhttp://www.zeminem.cz/kontakt\n\\--\n\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\n\n/--code php\npublic function createRouter() {\n	$router = new RouteList();\n	$router[] = new Route(\'<action>\', \'Homepage:default\');\n	$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n	return $router;\n}\n\\--\n\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře jako šablony, routa je opět jednoduchá:\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\n\\--\n\nHledá se šablona <code>sitemap.latte</code>. Přečtěte si jak vytvořit tuto šablonu v článku \"RSS a Sitemap jednoduše a rychle\":http://www.zeminem.cz/rss-a-sitemap-jednoduse-a-rychle. Výsledná URL je tak jak má být:\n\n/--code\nhttp://www.zeminem.cz/sitemap.xml\n\\--\n\nTo samé lze udělal pro RSS.\n\nJdeme do hloubky\n================\nTrošku složitější routování přichází vždy když chcete udělat něco speciálního.\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\n\n/--code\nhttp://www.zeminem.cz/2\n\\--\n\n/--code php\n$router[] = new Route(\"[<paginator-page [1|2]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\n\n/--code\nhttp://www.zeminem.cz/using-fulltext-searching-with-innodb\n\\--\n\n/--code php\n$router[] = new Route(\'<id>\', array(\n	\'presenter\' => \'Single\',\n	\'action\' => \'article\',\n	\'id\' => array(\n		Route::FILTER_IN => function ($url) {\n			return $this->posts->getIdByUrl($url);\n		},\n		Route::FILTER_OUT => function ($id) {\n			return $this->posts->getUrlById($id);\n		},\n	),\n));\n\\--\n\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\n\n/--code\nhttp://www.zeminem.cz/search/fio%20api\n\\--\n\n/--code php\n$router[] = new Route(\'search[/<search>]\', \'Search:default\');\n\\--\n\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\n\n/--code\nhttp://www.zeminem.cz/rss.xml\n\\--\n\n/--code php\n$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n\\--\n\nChová se to stejně jako u předchozího příkladu se `sitemap.xml`, v tomto příkladu však routa hledá `BlogPresenter.php` ve složce `FrontModule` a šablonu `rss.latte`, také v tomto modulu. U rout pro modulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa zvládne jazykové mutace pro FrontModul, jinak je to opět ta nejobecnější routa vůbec:\n\n/--code\nhttp://www.zeminem.cz/en/site/kontakt\n\\--\n\n/--code php\n$router[] = new Route(\'[<lang cs|sk|en>/]<presenter>/<action>[/<id>]\', array(\n	\'module\' => \'Front\',\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n));\n\\--\n\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\n\n/--code\nhttp://www.zeminem.cz/user/en/setting/password\n\\--\n\n/--code php\n$router[] = new Route(\'user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]\', array(\n	\'module\' => \'User\',\n	\'presenter\' => \'Board\',\n	\'action\' => \'default\',\n));\n\\--\n\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Front:Export:sitemap\');\n$router[] = new Route(\'kategorie/<category>\', \'Front:Product:default\');\n$router[] = new Route(\'produkt/<product>\', \'Front:Product:detail\');\n$router[] = new Route(\'\', \'Front:Product:default\');\n$router[] = new Route(\'admin/sign-<action>\', \'Admin:Sign:\');\n$router[] = new Route(\'registrace/\', \'Front:Register:new\');\n$router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\n$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n$router[] = new \\App\\RestRouter(\'api[/<presenter>[/<id>]]\', array( //vyžaduje speciální objekt (není součástí Nette)\n	\'module\' => \'Rest\',\n	\'presenter\' => \'Resource\',\n	\'action\' => \'get\',\n), \\App\\RestRouter::RESTFUL);\n\\--\n\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\n\nJak na v posledním příkladu zmíněný CLI router se dočtete v článku \"Nette 2.1-dev CliRouter\":http://www.zeminem.cz/nette-2-1-dev-clirouter.\n\nMáte nějakou zajímavou routu? Podělte se o ni... (-:',	'2013-08-04 12:19:19'),
(52,	'Fluent interface a PCRE',	'Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu (\"inspirace .{target:_blank}\":https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php), což je druhá věc o které bych se rád zmínil.\r\n\r\nRegulární výrazy jsou peklo\r\n=======================\r\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\r\n\r\n/--code\r\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\r\n\\--\r\n\r\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\r\n\r\n/--code php\r\n<?php\r\n\r\nclass Regexp {\r\n\r\n	private $regexp = \'\';\r\n\r\n	public function has($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function maybe($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")?\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function anythingBut($value) {\r\n		$this->regexp .= \"([^\" . preg_quote($value, \'/\') . \"]*)\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function __toString() {\r\n		return \"/^$this->regexp$/\";\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nS tím, že její použití je prosté:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\');\r\n$regexp->maybe(\'s\');\r\n$regexp->then(\'://\');\r\n$regexp->maybe(\'www.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->then(\'.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\r\n\r\nFluent interfaces, regulární peklo chladne\r\n===================================\r\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\')\r\n		->maybe(\'s\')\r\n		->then(\'://\')\r\n		->maybe(\'www.\')\r\n		->anythingBut(\' \')\r\n		->then(\'.\')\r\n		->anythingBut(\' \')\r\n		->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\r\n\r\nNe, peklo je opět peklem\r\n=====================\r\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\r\n\r\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.',	'2013-08-10 22:31:21'),
(53,	'RSS a Sitemap jednoduše a rychle',	'Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\r\n\r\nZačněme HomepagePresenterem (DEV Nette):\r\n\r\n/--code php\r\n<?php\r\n\r\nclass HomepagePresenter extends BasePresenter {\r\n\r\n	/** @var \\Model\\Posts @inject */\r\n	public $posts;\r\n\r\n	public function renderRss() {\r\n		$this->template->posts = $this->posts->getAllPosts()->order(\'date DESC\')->limit(50);\r\n	}\r\n\r\n	public function renderSitemap() {\r\n		$this->template->sitemap = $this->posts->getAllPosts();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\r\n\r\nPro úplnost ještě \\Model\\Posts:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Model;\r\n\r\nclass Posts extends \\Nette\\Object {\r\n\r\n	/** @var \\Nette\\Database\\SelectionFactory @inject */\r\n	public $sf;\r\n\r\n	/**\r\n	 * @return Nette\\Database\\Table\\Selection\r\n	 */\r\n	public function getAllPosts() {\r\n		return $this->sf->table(\'posts\');\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n	{foreach $sitemap as $s}\r\n		<url>\r\n			<loc>{link //Single:article $s->id}</loc>\r\n		</url>\r\n	{/foreach}\r\n</urlset>\r\n\\--\r\n\r\nRss.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<rss version=\"2.0\">\r\n	<channel>\r\n		<title>Martin Zlámal [BLOG]</title>\r\n		<link>{link //:Homepage:default}</link>\r\n		<description>Nejnovější články na blogu.</description>\r\n		<language>cs</language>\r\n\r\n		<item n:foreach=\"$posts as $post\">\r\n			<title>{$post->title}</title>\r\n			<link>{link //:Single:article $post->id}</link>\r\n			<description>{$post->body|texy|striptags}</description>\r\n		</item>\r\n	</channel>\r\n</rss>\r\n\\--\r\n\r\nA pro úplnou úplnost i router:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\nuse Nette;\r\nuse Nette\\Application\\Routers\\Route;\r\nuse Nette\\Application\\Routers\\RouteList;\r\nuse Nette\\Application\\Routers\\SimpleRouter;\r\n\r\nclass RouterFactory {\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n		// na RSS se dá odkazovat normálně bez routeru, nebo:\r\n		$router[] = new Route(\'rss.xml\', \'Homepage:rss\');\r\n		//...\r\n		$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nJednoduché a na pár řádek. Jen vědět jak na to... (-:',	'2013-08-10 23:10:22'),
(55,	'Důležitost titulku podruhé (a naposled)',	'Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://www.zeminem.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\r\n\r\nJak málo stačí k umístění ve vyhledávači\r\n========================================\r\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\r\n\r\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\r\n\r\nJenže není zobrazení jako zobrazení\r\n===================================\r\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\r\n\r\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://www.zeminem.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://www.zeminem.cz/navrhovy-vzor-factory-method).\r\n\r\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.',	'2013-10-21 23:20:36'),
(56,	'LaTeX šablona',	'Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\r\n\r\n/--code tex\r\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\r\n\\usepackage[czech]{babel}\r\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\r\n\r\n%%% PAGE DIMENSIONS\r\n\\usepackage{geometry} % to change the page dimensions\r\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\r\n\\geometry{a4paper}\r\n\r\n\\usepackage{graphicx} % support the \\includegraphics command and options\r\n\\usepackage{wrapfig} % support the wrapfigure section\r\n\r\n\\usepackage{hyperref} % links in \\tableofcontents\r\n\\hypersetup{\r\n	colorlinks,\r\n	citecolor=black,\r\n	filecolor=black,\r\n	linkcolor=black,\r\n	urlcolor=black\r\n}\r\n\r\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\r\n\r\n%%% PACKAGES\r\n\\usepackage{booktabs} % for much better looking tables\r\n\\usepackage{array} % for better arrays (eg matrices) in maths\r\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\r\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\r\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\r\n% These packages are all incorporated in the memoir class to one degree or another...\r\n\\usepackage{tikz} % graphs\r\n\\usepackage{pgfplots}\r\n\\usepackage{float}\r\n\r\n%%% HEADERS & FOOTERS\r\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\r\n\\pagestyle{fancy} % options: empty , plain , fancy\r\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\r\n\\lhead{}\\chead{}\\rhead{}\r\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\r\n\r\n%%% SECTION TITLE APPEARANCE\r\n\\usepackage{sectsty}\r\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\r\n% (This matches ConTeXt defaults)\r\n\r\n%%% ToC (table of contents) APPEARANCE\r\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\r\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\r\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\r\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\r\n\\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\r\n\r\n%%% END Article customizations\r\n\r\n\\begin{document}\r\n\r\n	...\r\n\r\n\\end{document}\r\n\\--\r\n\r\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?',	'2013-10-21 23:42:14'),
(57,	'Změna URL struktury',	'Rád bych tímto upozornil na změny URL adres na tomto webu. A zároveň k technické povaze tohoto webu\nprozradím i bližší informace ze zákulisí.\n\nPřed úpravou URL struktury jsem definoval několik důležitých bodů, kterých jsem se držel:\n1) Musí zůstat maximální (úplná) zpětná kompatibilita\n2) Výsledné URL musí být maximálně jednoduché a cool\n\nPředtím a potom\n===============\nDůležité je, aby stará URL adresa nekončila chybou 404, ale aby přesměrovala na novou URL.\nRSS je nyní na adrese http://www.zeminem.cz/rss. Původně bylo na adrese http://www.zeminem.cz/homepage/rss.\nObě dvě adresy fungují stále, rozdíl je v tom, že homepage/rss nyní přesměrovává pomocí 301 na */rss.\nToho se dalo docílit velice jednoduše:\n\n/--code php\n$router[] = new Route(\'rss\', \'Homepage:rss\'); //nová routa\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\'); //původní\n//záleží na pořadí!\n\\--\n\nAčkoliv je teď druhá routa zbytečná, nechal jsem jí pro případ, že bych měl nějakou URL nezachycenou.\nV tom případě ji zachytí tato obecná.\n\nZpětná kompatibilita\n====================\nStejně tak jako změna adresy RSS, tak si i ostatní adresy musí zachovat stejné vlastnosti viz první bod.\nA vzhledem k tomu, že jsem se rozhodl změnit adresu vyhledávání a tagů, nezbývalo, než další\ndvě routy přidat. Opět záleží na pořadí:\n\n/--code php\n$router[] = new Route(\'s[/<search>]\', \'Search:default\'); //nová\n$router[] = new Route(\'t[/<search>]\', \'Tag:default\'); //nová\n\n//tyto routy (až uznám za vhodné) mohu smazat:\n$router[] = new Route(\'search[/<search>]\', \'Search:default\', Route::ONE_WAY); //původní\n$router[] = new Route(\'tag[/<search>]\', \'Tag:default\', Route::ONE_WAY); //původní\n\\--\n\nOpět platí, že funguje jak stará adresa http://www.zeminem.cz/search/nette s přesměrováním 301, tak i nová \nhttp://www.zeminem.cz/s/nette. Obdobně je tomu u tagů.\n\nČarodějnictví!\n==============\nNejvětší sranda však začíná u druhého požadavku. Už dlouho jsem si pohrával s myšlenkou,\nže chci názvy článků a adresy jednotlivých stránek v menu hned za lomítkem jako v kořenovém\nadresáři. Tedy aby článek měl adresu http://www.zeminem.cz/lovec-matematik a stránka http://www.zeminem.cz/about.\nZde jsem se však vždy dostával do velkého problému. Jak rozlišit a nabídnout z databáze článek a \njak poznat, kdy naopak nabídnout stránku například s referencemi?\n\nNo, tak nejdříve je zapotřebí routa pro články:\n/--code php\n$router[] = new Route(\'<slug>\', \'Single:article\');\n\\--\nKdy v presenteru tahám články z databáze podle slugu:\n/--code php\npublic function renderArticle($slug) {\n	$post = $this->posts->getBySlug($slug)->fetch(); //načetní článku podle slugu\n	if (!$post) { //článek neexistuje (db vrací FALSE)\n		$this->forward($slug); //nabídni statickou šablonu\n	} else { // zobrazení článku\n    	//...\n    }\n}\n\\--\nCož je podle mého dostatečně elegantní řešení. Jednoduše se pokusím o načtení stránky podle slugu\nz databáze a když se to nepodaří, nabídnu nějaký latte soubor, pokud existuje. Pokud neexistuje, \ntak ErrorPresenter již obstará vrácení 404, což je správně, protože není co nabídnout...\n\nJeště je zapotřebí vytvořit jednu routu:\n/--code php\n$router[] = new Route(\'<action>\', \'Single:article\');\n\\--\nBez této routy by to také fungovalo, ale latte ony latte soubory (action) bych našel na dvou URL\nadresách, což nechci. Takže se z původního http://www.zeminem.cz/single/about dostanu na http://www.zeminem.cz/about, \ncož je cool a splňuji tak druhý požadavek.\n\nPoslední routa, která stojí za zmíňku pak zajišťuje stránkování. Pouze rozpoznává čísla podle\nregulárního výrazu a podle toho stránkuje:\n/--code php\n$regex = \'1|2|3\'; //zjednodušeně\n$router[] = new Route(\"[<paginator-page [$regex]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nOstatně to jak mám v době psaní tohoto článku router vytvořený můžete zjistit na \"bitbucketu\":https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/0580e2e9f0e4edb162fe97ad563cfef766bea625/app/router/RouterFactory.php.\n',	'2013-10-27 21:27:00'),
(58,	'Nette 2.2-dev',	'Nedávno byla změněna vývojová verze Nette Frameworku na 2.2-dev (https://github.com/nette/nette/commit/3a426255084163ec1a2f324ea0d3e9b3139adccc).\nTato změna s sebou přinesla explozi změn. Na následujících řádcích bych rád přiblížil\nněkteré zásadní změny, které se odehrály a je zapotřebí je upravit, aby bylo možné z verze 2.1-dev\npřejít právě na verzi 2.2-dev.\n\nNutné úpravy\n============\nPrvě se změnilo umístění konfigurátoru. Tato změna se samozřejmě týká souboru `bootstrap.php`.\nNově je konfigurátor v novém umístění:\n\n/--code php\n//$configurator = new Nette\\Config\\Configurator;\n$configurator = new \\Nette\\Configurator;\n\\--\n\nDále jsem si zvykl používat automatické injektování závislostí pomocí anotace `@inject`.\nPro opětovné použití je nutné zapnout `nette.container.accessors`, což ostatně napoví chybová hláška,\njelikož je tato volba v nové developměnt verzi Nette ve výchozím stavu zakázána. Config.neon:\n\n/--code neon\nnette:\n	container:\n    	accessors: TRUE\n\\--\n\nNyní již bude možné anotace `@inject` používat. Další změna, které mě osobně moc nepotěšila\na nevím co jí předcházelo je zrušení podpory krátkého zápisu bloků:\n\n/--code html\n<!-- Předtím: -->\n{#content}\n	...\n{/#}\n<!-- Nyní: -->\n{block content}\n	...\n{/block}\n\\--\n\nTato změna se mi moc nelíbí, protože například stále funguje `{include #parent}`, což je prostě\nzvláštní... Za zmínku také stojí změna třídy pro práci s databází. Zatímco se ve verzi 2.0.13\nnormálně používá `Nette\\Database\\Connection`, ve verzi 2.1-dev se přešlo na `Nette\\Database\\SelectionFactory`, \nnicméně ve verzi 2.1.0RC2 se již pracuje s `Nette\\Database\\Context` a SelectionFactory již neexistuje. \nToto  platí i pro verzi 2.2-dev. Tato změna mi bude zřejmě dlouho trvat, než ji vstřebám.\nMyslím si, že obyčejné `Nette\\Database` by bylo v modelu daleko více vypovídající než nějaký Context, \nale budiž.\n\nTolik k podle mého zásadním změnám, které zabrání například spuštění projektu z quickstartu. Nyní\nbych rád poukázal na několik málo změn z celé té exploze, které mě zaujaly.\n\nDalší změny\n===========\nByla odstraněna celá řada zastaralých věcí. Nemá smysl je rozebírat. Je jich hodně a zastaralé jsou\nuž od 2.1. Každopádně například makro `n:input` se stalo zastaralé a k dispozici je nové makro\n`{inputError}`, které ošéfuje vykreslení chybové hlášky u příslušného políčka. Jééj! :-)\n\nLehce odlišně se také přistupuje k checkboxům a vůbec, formuláře jsou zase o něco lepší, což\npředpokládám souvisí s:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Chtěl jsem v rychlosti udělat příklad, jak v <a href=\"https://twitter.com/search?q=%23netteFw&amp;src=hash\">#netteFw</a> renderovat formuláře s Twitter Bootstrapem.&#10;&#10;Zabitej den a překopaný Nette…</p>&mdash; geekovo (@geekovo) <a href=\"https://twitter.com/geekovo/statuses/409064701369516032\">December 6, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nKonečně!\n========\nSvětlo světa spatřil nový \"quickstart\":http://doc.nette.org/cs/2.1/quickstart v češtině pro dnes již téměř nekatuální verzi 2.0.13.\nVěřím tomu, že se jedná o daleko přínosnější věc, než psaní pokročilých návodů v angličtině\n(navazujících na quickstart) a doufám, že tento počin pomůže pár lidí popostrčit dál...\n\nJaká změna vás zaujala nejvíce?',	'2013-12-15 14:10:23'),
(59,	'Přednáška z Nette na ZČU',	'Dnes jsem měl tu čest přednášet na ZČU studentům předmětu KIV/WEB - Webové aplikace.\nPřednášku a i celé povídání jsem se snažil chopit velmi realisticky, prakticky a pro studenty, \nkteří s tvorbou webových aplikací teprve začínají. Doufám, ze bylo mé povídání\ninspirativní, srozumitelné a pochopitelné. Ostatně sami si prezentaci můžete přečíst:\n<br><br>\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29326870\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe>\n\n<br>\nVěřím, že Nette bude používat zase o něco více začátečníků a že še jim podaří psát kvalitní\nwebové aplikace. Rád bych ještě jednou popřál všem studentům úspěšné složení zkoušky z předmětu KIV/WEB\na snad se ještě někdy potkáme... (-:',	'2013-12-18 17:54:22'),
(60,	'Veřejná distribuce klíčů',	'<blockquote>\n  Inspirací a zdrojem informací pro tento článek byla kniha <strong>Simona Singha</strong> - Kniha kódu a šifer.\n  <small>Utajování od starého Egypta po kvantovou kryptografii</small>\n</blockquote>\n\nTímto článkem bych rád navázal na článek o asymetrickém šifrování http://www.zeminem.cz/asymetricka-sifra-s-verejnym-klicem a vyřešil tak několik restů. Zejména potom onu osudnou veřejnou distribuci klíčů o které jsem sice již dříve psal, ale článek již není k dispozici. Proto tento text budu brát jako revizi původního. Také bych na začátek chtěl říct, že tento problém je již dávno vyřešen a proto bude následující text ohlédnutím za vznikem této myšlenky s tím, že je však použití stále aktuální a reálně se používá (např.: http://nodejs.org/api/crypto.html#crypto_class_diffiehellman).\n\nDistribuce klíčů? Vždyť je to tak snadné...\n===========================================\nPokud si chtějí dvě osoby vyměnit zašifrované zprávy, je jasné, že musejí znát i klíče, které jim umožní tyto zprávy dešifrovat. Jenže jak si vyměnit tyto klíče? Mohou se tyto osoby někdy potkat a klíč si povědět. To však není vždy možné. Navíc klíče je dobé frekventovaně měnit, takže je v dnešní době toto řešení naprosto nesmyslné.\n\n<blockquote>\n  Dříve, než dva lidé mohou sdílet tajemství, musí již jedno tajemství sdílet.\n  <small>Dříve než dva lidé mohou sdílet šifrovanou zprávu, musí již sdílet klíč.</small>\n</blockquote>\n\nAčkoliv je osobní výměna bezpečná, jedná se tedy o metodu nereálnou a je třeba navrhnout jiné postupy. Co třeba najmou kurýra? Je to sice méně bezpečné, ale eliminují se některé předchozí problémy. Bohužel kurýr je až příliš nebezpečný způsob, protože pak lze klíč rovnou nějakým kanálem poslat a dostáváme se opět na začátek. Je tedy vůbec možné si vyměnit klíč bez nutnosti potkat se? Je tedy vůbec nutné si klíč vyměnit?\n\nMožná to jde i jinak\n====================\nExistuje skvělá hádanka, která na první pohled daný problém řeší. Představte si poštovní službu, která však všechny zásilky otevírá a čte si je. Nicméně Alice potřebuje poslat tajný balík Bobovi. Lze využít tuto poštu tak, aniž by balík otevřela?\n\nPřistupím rovnou k řešení, které je opravdu jednoduché. Alice pošle balík (schránku), který opatří vlastním zámkem a klíč od tohoto zámku si ponechá. V tom případě není pošta schopna balík otevřít. Bohužel ani Bob balík neumí otevřít, protože nemá k dispozici správný klíč. Proto Bob vezme vlastní zámek a schránku zamkne ještě vlastním zámkem. Klíč si opět ponechá. To může vyznít zvláštně, ale hned to začne být jasné. Bob balík opět odešle, Alice sundá vlastní zámek (protože od něj má klíč) a balík pošle opět Bobovi. Nyní je na balíku pouze Bobovo zámek a ten ho může jednoduše odemknout. Zdá se tedy, že lze cokoliv poslat zabezpečeně a výměna klíčů není potřeba! Toto je nesmírně důležitá myšlenka.\n\nMá to však háček. Ačkoliv se zdá být předchozí problém naprosto zřejmý a funkční, po převedení do světa kódů a šifer, celá myšlenka padá. Důvod je jednoduchý. Bylo velmi snadné na schránku umístit zámek **A**, poté zámek **B**, poté odstranit zámek **A** a nakonec odstranit zámek **B**. Takže posloupnost  šifrování byla +A => +B => -A => -B. Použijete-li však tento postup pomocí doposud známých šifer, zjistíte, že záleží na pořadí šifrování, resp. dešifrování. Zkrátka nelze toto pořadí zaměnit, jinak je výsledek zamíchaný a nepoužitelný.\n\nTak to je problém...\n====================\nAčkoliv byla myšlenka posílání balíku téměř ideální, ve světě šifer již nefunguje. Co teď? Na scénu přichází matematika. Konkrétně jednosměrné funkce a s nimi modulární aritmetika. Nemyslím si, že má smysl řešit co je to jednosměrná funkce, ale zkráceně jednosměrná funkce je taková funkce, která se nedá (nebo velmi těžce) zvrátit. Jeko velmi dobrý příklad takové funkce je například smíchání dvou barev (nelze získat zpět původní barvy). Obdobně pro matematické funkce. Zkrátky vždy je o to nalézt takovou funkci, kterou je velmi jednoduché použít a spočítat, ale již velmi složité invertovat výsledek. Právě pro tyto úlohy se perfektně hodí modulární aritmetika. Tam kde se běžná aritmetika chová předvídatelně a na základě pokusů lze konvergovat k výsledku, v modulární takováto chování neexistují.\n\nŘešení\n======\nNásledující algoritmus je zhruba použit v šifrách DES (pro velká čísla). Budu však používat malá, aby bylo vše lépe pochopitelné. Alice a Bob se <strong>veřejně</strong> dohodnou na funkci *Y<sup>x</sup>(mod P)*, kdy si číla např. Y=5 a P=8 vymění (a útočník je může odposlechnout).\n\nTeď tedy zná příjemnce, odesílatel i útočník danou funkci. Odesílatel a příjemnce si nyní zvolí jiné číslo <strong>které uchovají v tajnosti</strong>, toto číslo vloží do matematické funkce *Y<sup>x</sup>(mod P)* a výsledek odešlou. Například Bob zvolil x=4, tedy *5<sup>4</sup>(mod 8)=1*. Alice volí x=3, tedy *5<sup>3</sup>(mod 8)=5*. Tyto výsledky si vymění.\n\nZ pohledu útočníka lze říci, že zná funkci a zná také výsledky, konkrétně 1 a 5. S touto znalostí by šlo možná privátní číslo **x** dopočítat. Jenže vyzkoušejte si to. Pro malá čísla možná, ale pro velká je to téměř nemožné. A že se používají velká čísla...\n\nNyní vezme Alice výsledek od Boba a spočte *vysledek<sup>x</sup>(mod P)*, tedy *1<sup>3</sup>(mod 8)=1*. Nezapomeňte, že číslo **x** je stále privátní a zná ho jen Alice. Stejně teď postupuje i Bob, ale s vlastním privátním číslem a výsledkem od Alice: *5<sup>4</sup>(mod 8)=1*. A zde je vidět k čemu došlo. Výsledek obou výpočtů vyšel stejně a k přenosu priváního čísla **x** nikdy nedošlo. Vyzkoušejte si to na papír a nejlépe pro větší čísla. Pro útočníka nastává velký problém, protože nezná privátní číslo a je pro něj tedy nemožné provést tyto výpočty, nicméně Alice i Bob mají k dispozici jeden výsledek, tedy jeden klíč, který mohou používat.\n\nZávěr\n=====\nJeště zopakuji k čemu tedy došlo. Bylo zapotřebí dohodnout se mezi odesílatelem a příjemcem na společném klíči, podle kterého bude posílaná zpráva šifrována. To se pomocí vhodných matematických metod povedlo a navíc (což je to njdůležitější) není téměř možné tento přenos odposlechnout, jelikož se jedná o jednosměrné operace.\n\nAnalogicky lze použít opět míchání barev. Alice a Bob mají nádobu s litrem červené barvy. Stejnou nádobu má i útočník. Alice i Bob nyní nalijí vlastní privátní barvu do nádoby a tyto nádoby si vymění. Útočník je může vidět, ale nedokáže z nich odhadnout jaká je privátní barva. Nakonec Alice i Bob nalijí zbytek své tajné barvy do nádoby (již je mají vyměněné), čímž vznikne Alici i Bobovi stejná barva. Ani Alice, ani Bob, ani útočník neví co bylo přidáno za barvy od toho druhého, ale se znalostí vlastního privátního klíče se dostanou ke stejnému výsledku. útočník tyto klíče nezná a je nahraný.\n\nTak a zde by měl začínat článek http://www.zeminem.cz/asymetricka-sifra-s-verejnym-klicem.\n\nTento a daleko více inspirativních nápadů a příběhů naleznete v knize https://www.kosmas.cz/knihy/146743/kniha-kodu-a-sifer/.',	'2013-12-22 12:08:24'),
(62,	'Představení projektu Vacuum - STATIC',	'Vzhledem k tomu, že vzrostl zájem o Vacuum projekty, rozhodl jsem se zde uveřejnit postup jak pracovat s projektem **Vacuum - STATIC** (https://bitbucket.org/mrtnzlml/vacuum-static). Věřím, že je daleko lepší projekt ukázat a lehce popsat, než popsat a lehce ukázat, jak si Nette komunita občas myslí...\n\nCo to vlastně je\n================\nVacuum - STATIC je projekt, který vznikl z úplně základního Nette skeletonu, který jsem používal pro jednoduché statické firemní prezentace jako je například http://www.businessservice.cz/. Postupem času jsem dodával vylepšení a když už tento projekt dosáhl svého maxima, rozhodl jsem se do něj napsat jednoduchou administraci. V současné době tedy Vacuum - STATIC vlastně vůbec není statická prezentace. Obsahuje vestavenou SQLite databázi, díky které není potřeba nějaké MySQL databáze. Web prostě funguje zdánlivě bez databáze. Toto je velmi zásadní. Vacuum - STATIC pravděpodobně nikdy nebude mít externí databázi, takže se bude stále tvářit jako jednoduchá webová prezentace, která má však navíc jednoduchou administraci.\n\nStažení, instalace, spuštění\n============================\nCelý projekt se dá stáhnout různě, asi nejjednodušší je využít funkcionalit GITu:\n\n/--code\n>> git clone https://mrtnzlml@bitbucket.org/mrtnzlml/vacuum-static.git folder\nCloning into \'folder\'...\nremote: Counting objects: 433, done.\nremote: Compressing objects: 100% (401/401), done.\nremote: Total 433 (delta 201), reused 0 (delta 0)\nReceiving objects:  92% (399/433), 636.00 KiB | 192 KiB/s\nReceiving objects: 100% (433/433), 664.47 KiB | 192 KiB/s, done.\nResolving deltas: 100% (201/201), done.\n\\--\n\nTím vytvoříte složku `folder`, která bude obsahovat aktuální verzi projektu Vacuum - STATIC. Pokud v tuto chvíli projekt sputíte, vrátí chybu, že nemůže najít soubor `autoload.php`. Je to proto, že projekt ještě neobsahuje žádné knihovny (například Nette). Ty totiž nemá smysl udržovat v repozitáři. Veškeré potřebné knihovny lze doinstalovat jednoduše pomocí Composeru:\n\n/--code\n>> composer update\nLoading composer repositories with package information\nUpdating dependencies (including require-dev)\n  - Installing nette/tester (dev-master a60c379)\n    Cloning a60c379836617422c8df9d9846fea4efa2ca9d1d\n\n  - Installing nette/nette (dev-master a748c3d)\n    Cloning a748c3d344767ed1f0cc9ee40019f6a6f81afa97\n\n  - Installing janmarek/webloader (dev-master 3d44d30)\n    Cloning 3d44d306d59591dc94f6fdcb98f55c0990d98326\n\n  - Installing texy/texy (dev-release-2.x 79d0e15)\n    Cloning 79d0e1517363ab32edf2db8ec515e3dc84f50f0a\n\nnette/nette suggests installing ext-fileinfo (*)\njanmarek/webloader suggests installing leafo/lessphp (Lessphp is a composer for LESS written in PHP.)\nWriting lock file\nGenerating autoload files\n\\--\n\nV tuto chvíli je projekt připraven k použití. V některých systémech však bude potřeba ještě nastavit práva k zápisu složkám `temp` a `log`. Dokonce není potřeba ani nějakého XAMPP serveru. Stačí v té samé složce využít integrovaného PHP serveru v příkazové řádce:\n\n/--code\nphp -S localhost:8888 -t www\n\\--\n\nFunkční Vacuum - STATIC pak naleznete na adrese http://localhost:8888/. Trapně jednoduché a překvapivě funkční. (-: Vzhledem k tomu, že již vidíte funkční stránku, můžete se přihlásit do administrace (link v patičce). Přihlašovací údaje jsou *demo*/*demo*.\n\nUpdate projektu\n===============\nNa tomto projektu stále pracuji a čas od času v něm něco doplním nebo upravím. Vzhledem k tomu, že doporučuji použít ke stažení GIT, je update projektu velmi jednoduchý. Stejně jako jsem nedávno zapomněl přidat nahrát dva soubory:\n\n/--code\n>> git pull\nUpdating ead4a56..2439d5f\nFast-forward\n www/js/codemirror.js | 5516 ++++++++++++++++++++++++++++++++++++++++++++++++++\n www/js/xml.js        |  338 ++++\n 2 files changed, 5854 insertions(+)\n create mode 100644 www/js/codemirror.js\n create mode 100644 www/js/xml.js\n\\--\n\nTo je asi tak vše co se k tomu dá teď napsat. Nic na tom není, jen je třeba vědět jak na to. Přeji hodně úspěchů při používání tohoto projektu ať už je to ke studijním účelům, nebo k reálné webové prezentaci. Zpětnou vazbu samozřejmě rád uvítám.',	'2014-01-28 18:10:34'),
(63,	'Vlna na webu',	'Vlna je program \"Petra Olšáka .{target:_blank}\":http://ftp.linux.cz/pub/tex/local/cstug/olsak/vlna/, který slouží k umístění nezalomitelné místo na místo v textu, kde by nemělo dojít k samovolnému zalomení řádku. Tento program slouží k dodatečné úpravě textů napsaných v LaTeXu. V tomto prostředí se nezalomitelná mezera nahrazuje znakem vlnovkou - tildou (~). U webového výstupu se používá zástupná entita <code>&amp;nbsp;</code>.\n\nKde by měla být nedělitelná mezera\n==================================\nV základu program Vlna umístí tildu za znaky <code>KkSsVvZzOoUuAI</code>. Více toho pokud vím nedělá. Podle Ústavu pro jazyk český AV ČR by však toto pravidlo mělo platit mimo jiné pro znaky <code>KkSsVvZzAaIiOoUu</code>. Neuvažuji další pravidla, která určují další nevhodné výrazy na konci řádku. Mezi tyto pravidla patří například mezery uvnitř číslic, mezery mezi číslicí a značkou, atd. Některá pravidla jsou totiž natolik specifická, že by je bylo náročné (nebo nepraktické) podchytit programově.\n\nImplementace\n============\nO samotné nahrazování se stará následující regulární výraz:\n/--code php\npreg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n\\--\nTento výraz říká, že nestojí-li bezprostředně před sadou znaků <code>KkSsVvZzAaIiOoUu</code> jiný alfanumerický znak a stojí-li za touto sadou jakýkoliv alfanumerický znak oddělený bílým znakem bude tento znak nahrazen entitou <code>&amp;nbsp;</code>. V konkrétní implementaci lze zaregistrovat Vlnu jako helper pro Latte šablony například takto (obsahuje i registraci Texy helperu):\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	$template->registerHelper(\'vlna\', function ($string) {\n		$string = preg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n		return $string;\n	});\n	return $template;\n}\n\\--\n\nVlna se pak v Latte šablonách používá jako jakýkoliv jiný helper:\n\n/--code\n{$post->title|vlna}\n\\--\n\nJeště by možná stálo za to vrátit se k tomu, jaké problémy by způsobovala implementace i dalších pravidel a jak by to bylo náročné. Ještě nad tím budu přemýšlet, každopádně již teď mě napadají určité problémy. Například u čísel. Jak přesně identifikovat, kdy se má použít nedělitelná mezera a kdy ne? Možná je toto právě ten důvod, proč takové rozšířené chování program Vlna nepodporuje...',	'2014-02-01 22:09:38'),
(64,	'Použití Texy s FSHL',	'Někdy (hodně dávno) jsem kdesi našel poměrně hezký a jednoduchý postup jak implementovat \"Texy .{target:_blank}\":http://texy.info/ s použitím \"FSHL .{target:_blank}\":http://fshl.kukulich.cz/ na webu. Rád bych se zde podělil o postup, který používám již na řadě projektů, které potřebují zvýrazňování syntaxe.\n\nPoužití samotného Texy\n======================\nBěžně by se Texy zaregistrovalo do šablony jako helper:\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	return $template;\n}\n\\--\n\nTento helper lze i nadále používat. Hodě se například pokud je potřeba Texy prvky naopak escapovat:\n\n/--code\n{$post->body|texy|striptags}\n\\--\n\nPoužití Texy s FSHL\n===================\nSamotné texy je sice geniální nástroj. Pro samotné zpracování se zvýrazněním se však hodí funkcionalitu Texy rozšířit, jelikož je potřeba zpracovat vstupující text a ty správná místa prohnat také tím správným lexxerem ve FSHL. K tomu dobře poslouží následující třída, která dědí právě od Texy:\n\n/--code php\n<?php\n\nclass fshlTexy extends Texy {\n\n	public function blockHandler($invocation, $blocktype, $content, $lang, $modifier) {\n		if ($blocktype !== \'block/code\') {\n			return $invocation->proceed(); //vstup se nebude zpracovavat\n		}\n\n		$highlighter = new \\FSHL\\Highlighter(\n			new \\FSHL\\Output\\Html(),\n			\\FSHL\\Highlighter::OPTION_TAB_INDENT | \\FSHL\\Highlighter::OPTION_LINE_COUNTER\n		);\n\n		$texy = $invocation->getTexy();\n		$content = Texy::outdent($content);\n\n		//Set correct lexer:\n		switch(strtoupper($lang)) {\n			case \'CPP\': $lexer = new \\FSHL\\Lexer\\Cpp(); break;\n			case \'CSS\': $lexer = new \\FSHL\\Lexer\\Css(); break;\n			case \'HTML\': $lexer = new \\FSHL\\Lexer\\Html(); break;\n			case \'JAVA\': $lexer = new \\FSHL\\Lexer\\Java(); break;\n			case \'JAVASCRIPT\': $lexer = new \\FSHL\\Lexer\\Javascript(); break;\n			case \'NEON\': $lexer = new \\FSHL\\Lexer\\Neon(); break;\n			case \'PHP\': $lexer = new \\FSHL\\Lexer\\Php(); break;\n			case \'PYTHON\': $lexer = new \\FSHL\\Lexer\\Python(); break;\n			case \'SQL\': $lexer = new \\FSHL\\Lexer\\Sql(); break;\n			case \'TEX\': $lexer = new \\FSHL\\Lexer\\Tex(); break; //WARNING: vlastní výroba!\n			case \'TEXY\': $lexer = new \\FSHL\\Lexer\\Texy(); break;\n			default: $lexer = new \\FSHL\\Lexer\\Minimal();\n		}\n\n		$content = $highlighter->highlight($content, $lexer);\n		$content = $texy->protect($content, Texy::CONTENT_BLOCK);\n\n		$elPre = TexyHtml::el(\'pre\');\n		if ($modifier) {\n			$modifier->decorate($texy, $elPre);\n		}\n		$elPre->attrs[\'class\'] = strtolower($lang);\n\n		$elCode = $elPre->create(\'code\', $content);\n\n		return $elPre;\n	}\n\n}\n\\--\n\nTato třída při správném použití zajistí, že se použije ten správný lexer a ještě na úrovni PHP zajistí změnu výstupu. Konkrétně obalí určitá klíčová slova (v závislosti na kontextu) tagem <code>&lt;span&gt;</code> se zvláštní třídou. Toho se následně lze chytit v CSS a HTML výstup obarvit. Použití této třídy například v metodě <code>render*()</code>:\n\n/--code php\n$texy = new \\fshlTexy();\n//registrace handleru z nové třídy:\n$texy->addHandler(\'block\', array($texy, \'blockHandler\'));\n//dále stejně jako klasické použití Texy:\n$texy->tabWidth = 4;\n$texy->headingModule->top = 3; //start at H3\n$this->template->body = $texy->process($post->body);\n\\--\n\nVýstup lze pak v Latte lehce podchytit a zobrazit:\n\n/--code\n{$body|noescape}\n\\--\n\nBarvy, barvy, barvičky\n======================\nProgramově je sice tělo dokumentu vypsáno s tagy <code>&lt;span&gt;</code> s příslušnou třídou. To se však nijak viditelně neprojeví. Celou krásu udělá teprve CSS. Lze použít výchozí hodoty FSHL a vložit je do vlastního souboru stylů:\n\n/--code css\n/* Common */\n.xlang { color: #ff0000; font-weight: bold; }\n.line { color: #888888; background-color: #ffffff; }\n\n/* CSS */\n.css-at-rule { color: #004a80; font-weight: bold; }\n.css-tag { color: #004a80; }\n.css-id { color: #7da7d9; font-weight: bold; }\n.css-class { color: #004a80; }\n.css-pseudo { color: #004a80; }\n.css-property { color: #003663; font-weight: bold; }\n.css-value { color: #448ccb; }\n.css-func { color: #448ccb; font-weight: bold; }\n.css-color { color: #0076a3; }\n.css-comment { background-color: #e5f8ff; color: #999999; }\n\n/* CPP */\n.cpp-keywords1 {color: #0000ff; font-weight: bold;}\n.cpp-num {color: #ff0000;}\n.cpp-quote {color: #a52a2a; font-weight: bold;}\n.cpp-comment {color: #00ff00;}\n.cpp-preproc {color: #c0c0c0;}\n\n/* HTML */\n.html-tag {color: #598527; font-weight: bold;}\n.html-tagin {color: #89a315}\n.html-quote {color: #598527; font-weight: bold;}\n.html-comment {color: #999999; background-color: #f1fae4;}\n.html-entity {color: #89a315;}\n\n/* Java */\n.java-keywords1 {color: #0000ff; font-weight: bold;}\n.java-num {color: #ff0000;}\n.java-quote {color: #a52a2a; font-weight: bold;}\n.java-comment {color: #009900;}\n.java-preproc {color: #c0c0c0;}\n\n/* Javascript */\n.js-out {color: #898993;}\n.js-keywords1 {color: #575757; font-weight: bold;}\n.js-num {color: #575757;}\n.js-quote {color: #575757; font-weight: bold;}\n.js-comment {color: #898993; background-color: #f4f4f4;}\n\n/* Neon */\n.neon-section {color: #598527;}\n.neon-sep {color: #ff0000;}\n.neon-key {color: #0000ff;}\n.neon-comment {color: #999999;}\n.neon-value {color: #000000;}\n.neon-quote {color: #884433;}\n.neon-num {color: #448ccb;}\n.neon-var {color: #ffaa00;}\n.neon-ref {color: #884433;}\n\n/* PHP */\n.php-keyword1 {color: #dd2244; font-weight: bold;}\n.php-keyword2 {color: #dd2244;}\n.php-var {color: #ffaa00; font-weight: bold;}\n.php-num {color: #ff0000;}\n.php-quote {color: #884433; font-weight: bold;}\n.php-comment {color: #999999; background-color: #ffffee;}\n\n/* Python */\n.py-keyword1 {color: #0033cc; font-weight: bold;}\n.py-keyword2 {color: #ce3333; font-weight: bold;}\n.py-keyword3 {color: #660066; font-weight: bold;}\n.py-num {color: #993300;}\n.py-docstring {color: #e86a18;}\n.py-quote {color: #878787; font-weight: bold;}\n.py-comment {color: #009900; font-style: italic;}\n\n/* SQL */\n.sql-keyword1 {color: #dd0000; font-weight: bold;}\n.sql-keyword2 {color: #dd2222;}\n.sql-keyword3 {color: #0000ff; font-weight: bold;}\n.sql-value {color: #5674b9;}\n.sql-comment {color: #ffaa00;}\n.sql-num {color: #ff0000;}\n.sql-option {color: #004a80; font-weight: bold;}\n\n/* Tex */\n.tex-func {color: #ffaa00; font-weight: bold;}\n.tex-comment {color: #999999; background-color: #ffffee;}\n.tex-attr1 {color: #dd2222;}\n.tex-attr2 {color: #0000ff; font-weight: bold;}\n.tex-math {color: #00AA00; font-weight: bold;}\n\n/* Texy */\n.texy-hlead {color: #4444bb; font-weight: bold;}\n.texy-hbody {background-color: #eeeeff; color: #4444bb;}\n.texy-hr {color: #bb4444;}\n.texy-code {color: #666666;}\n.texy-html {color: #66aa66;}\n.texy-text {color: #6666aa;}\n.texy-err {background-color: #ff0000; color: #ffffff;}\n\\--\n\nCelá krása tohoto řešení spočívá v tom, že nepoužívám žádné javascriptové knihovny, ale vše se provede pěkně na úrovni PHP a bude to tedy fungovat vždy, stejně tak jako Texy... (-:',	'2014-02-02 10:47:06'),
(65,	'Udržujete dokumentaci stále aktuální?',	'Již dlouho si v hlavě pohrávám s jednou myšlenkou, kterou stále nemohu dovést do zdárného konce. Již na samém začátku jsem již však věděl, že se zajisté nezalíbí velké skupině programátorů. Přesto si myslím, že má něco do sebe. Jen jsem ji ještě nedomyslel tak, aby jsem s ním byl spokojen. Třeba bude mít někdo nějaký geniální nápad.\n\nNa začátku byl problém\n======================\nA každý problém by se měl řešit. Mluvím teď o jednom konkrétním. *Jak udržet dokumentaci projektu aktuální?* To je problém, který některé projekty dokáží bez větších problémů. Obdivuji člověka, který napíše kus kódu a k němu napíše přehlednou a užitečnou dokumentaci. Ještě více však obdivuji toho, kdo aktualizuje kus kódu a opět se pustí na přepisování dokumentace. V praxi je toto však bolístka, která trápí většinu projektů, které používá menší než obrovské množství...\n\nMyslím si, že tento postup je částečně zcestný. Není problém napsat dokumentaci, ale problém je se pak vracet k napsaným textům a číst je znova a znova a stále je upravovat. Má tento problém vůbec nějaké řešení? Možná ano. Pokud zůstanu u myšlenky, že jednou napsat dokumentace a dost, může se leckomu zdát, že při tomto postupu není možné dokumentaci aktualizovat. Definjme tedy alespoň rámcově tyto pojmy. Pod dokumentací si představuji webovou stránku s případnou obsahovou strukturou, která obsahuje jak veškeré naučné texty, tak ukázky kódů. Praktické ukázky. Tak jak to ve skutečnosti funguje.\n\nBěžné zadání dokumentace, že? Nikde jsem však nenapsal, že tato dokumentace musí obsahovat přímo napsané povídání. Musí tento text ve výsledku obsahovat, ale nemusí být součástí!\n\nCo prosím?\n==========\nMyslím to přesně tak jak jsem napsal. Dokumentace musí na výstupu obsahovat veškeré texty a prostě všechno, ale nemusí je při tvorbě obsahovat. To zní možná trošku divně. Není ta věta v rozporu sama se sebou? Ne nutně. Dokumentaci bych si opravdu představoval jako soubor pravidel obsahující nadpis, několik programových direktiv a to by bylo v podstatě všechno. Mohlo by to vypadat například takto pro nějaký tutoriál:\n\n/--code\nToto je nadpis stránky v dokumentaci\n\nindex.php\nbootstrap.php\nHomepagePresenter.php:renderDefault\n\\--\n\nSchválně jsem zvolil všem tolik známý sandbox z Nette Frameworku. V souboru bych tedy jen definoval jen (omáčku okolo), nadpis, soubory odkud se má dokumentace generovat, popř. nějaký výběr. Zde je nutné říct, že by byl projekt po programové stránce poněkud zvláštní a nejsem si jist, jestli je to úplně OK. usel by totiž obsahovat onu dokumentaci viz např. *index.php*:\n\n/--code php\n<?php\n\n/**\n ** Zde je umístněna dokumentace.\n ** Obsahuje kompletní poučný text, který se pak vyfiltruje do dokumentace včetně\n ** řádků, popř. metod ke kterám se vztahuje. Pro lepší použití by bylo potřeba\n ** definovat několik zřejmě anotací jako např:\n **\n ** @doc-lines 12-14\n ** @doc-highlight 14\n **/\n$container = require __DIR__ . \'/../app/bootstrap.php\'; ///>label\n\n$container->application->run();\n\\--\n\nTakovýto soubor je pak jednoduché vzít, rozebrat, naservírovat text, aplikovat funkci entit a vykreslit i kód ke kterému se tento komentář vztahuje. Možná by šlo vytvořit i nějaká návěští pro odkazování se do kódu, protože číslo řádky není úplně nejvhodnější (<code>///>label</code>).\n\nPro et Contra\n=============\nJednoznačně by tento postup vedl k tomu, aby programátor kromě psaní kódu udržoval i komentář, který by byl běžně velmi blízko. Jednalo by se tak vlastně o jednu práci. Netřeba otevírat celou dokumentaci, stačí změnit pouze malou část, která se s pushnutím zobrazí i v dokumentaci. Na druhou stranu, nedovedu si tento postup představit v kombinaci s klasickým PHPDOC. Nenapadá mě jiné řešení, než udržovat klasický projekt a vedle projekt, který by sloužil pouze pro dokumentaci. Například onen sandbox z NetteFW. Při takovém postupu mi to však dává docela dobrý smysl. Dokumentace by byla doslova stejně aktuální jako zdrojové kódy a to včetně ukázek! Co je u takových projektů důležitější?\n\nMimochodem. PHP k tomuto má velmi blízko. Minimálně podle jejich dokumentačních \"slohokomentářů\". S tímto problémem také lehce souvisí verzování projektů o kterém bych se chtěl rozepsat jindy.\n\nTeď však zpět k myšlence. Jak moc je to hloupý nápad? Co je jeho překážkou? Proč by ho nešlo prakticky použít?',	'2014-02-03 21:50:55'),
(66,	'Kde se berou spamy?',	'<div class=\"alert alert-info\">Tento článek navazuje na článek \"Stáhněte si zdarma 897457 emailových adres\":http://www.zeminem.cz/stahnete-si-zdarma-897457-emailovych-adres z ledna tohoto roku. Přečtěte si jej prosím, ať víte o co jde.</div>\n\nRád bych tímto všechny čtenáře poprosil o pomoc. Ačkoliv na internetu vystupuji veřejně a nemám s tím problém, jsem velmi háklivý na to, když někdo neoprávněně zneužívá mé osobní informace. Někteří přijmou moji žádost a problém odstraní - viz nedávno zrušená kopie tohoto blogu. Někteří však dělají všechno proto, abych pokračoval v rituálním podpalování válečné sekery a proto jsem neskončil tam kde jsem v minulém článku přestal psát.\n\nTrnitá cesta plná překážek\n==========================\nJe již známá věc, že jistý web má nemalou zásluhu na šíření reklamních emailů křížem krážem. Vzhledem k tomu, že takové email dorazil i ke mě a vzhledem k tomu, že upoutal moji pozornost, začal jsem zbrojit. Při prvních pokusech jsem oťukával jejich systém abych zjistil o co jde. Zde jsem mimo jiné udělal mylný myšlenkový pochod a vše jsem svedl na někoho kdo s tím nemá nic společného. Každopádně po několika minutách jsem měl celkem jasno a udělal jsem velkou chybu. Popsal jsem bezpečnostní chybu reklamního systému na G+, na což někdo velmi rychle zareagoval a já jsem dostal na tento reklamní server ban. Doufám, že to byla jen náhoda...\n\nToto řešení mi přišlo poněkud směšné, a tak jsem do tohoto systému přes IP anonymizér šťoural stále více. V tuto chvíli jsem to prakticky zabalil, protože chyba byla tak nějak opravena. Systém již při odhlašování nezobrazoval emailovou adresu, takže již nešlo použít něco jako:\n\n/--code php\npreg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n\\--\n\nNa necelý měsíc jsem to pustil z hlavy až včera jsem si na tento web opět vzpomněl. Také jsem byl již na jiné IP adrese což se mi stává celkem často, takže jsem opět vyzkoušel to co před měsícem a světe div se, bezpečností chyba opět funguje. To mě rozproudilo ještě víc, takže jsem opět usedl k editoru a začal jsem psát program, abych si ověřil, že jsem nekecal:\n\n/--code php\n<?php\ntry {\n    $db = new PDO(\'mysql:dbname=emails;host=127.0.0.1\', \'root\', \'\');\n    $stmt = $db->prepare(\"INSERT INTO emails (url_id, email) VALUES (:url_id, :email)\n							ON DUPLICATE KEY UPDATE url_id= :url_id, email= :email\");\n	$stmt->bindParam(\':url_id\', $url_id);\n	$stmt->bindParam(\':email\', $email);\n\n	//1300486 - 2197943\n	for ($i=2197943; $i > 1300486; $i--) {\n		preg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n		if (preg_match(\"#@#\", $match[1])) {\n			$url_id = $i;\n		    $email = $match[1];\n		    echo $i . \': \' . $email . \"\\n\";\n			$stmt->execute();\n		}\n	}\n\n} catch (PDOException $e) {\n    echo \'Connection failed: \' . $e->getMessage();\n}\n\\--\n\nNejsem žádný extra programátor, ale na takovou věc ani být nemusím. Je asi zřejmé, že by tento program trval poměrně dlouhou dobu. Nemá však smysl řešit nějaké paralelní zpracování, když se o to server při vhodně zvoleném programu postará sám. Napsal jsem tedy celkem tři velmi podobné programy. Jeden bral URL adresy od nízkého čísla, druhý od vysokého a třetí na obě strany od středu číselného intervalu. Právě je 17:00, dávám si něco k jídlu a vyrážím do města na hokej...\n\nJak to bylo dál?\n================\nPo tom co hokej nedopadl moc dobře, strávil jsem nějaký čas u piva a vrátil jsem se domů. Bylo pozdě a program pořád běžel. Šel jsem spát a ráno do školy. Program stále běžel. V tuto chvíli již 16 hodin. Odhadem až někdy po 20ti hodinách dolování emailových adres z tohoto serveru jsem opět dostal IP ban. V tu chvíli jsem měl však získáno více než čtvrt milionu unikátních emailových adres. Ono to funguje! **Zde bych měl říct, že jsem tyto emailové adresy nedoloval kvůli nějakému zneužití, maximálně z nich udělám nějakou statistiku**... (-: Chtěl jsem také napsat na email který mají vystavený na webu, to bohužel nefungovalo, protože tento email byl pravděpodobně zrušen.\n\nV tuto chvíli adresy stále zpracovávám, protože celý systém psal někdo moc \"šikovný\" a tak občas systém vrátil místo emailu *Invalid key!* a jindy zase mix náhodných speciálních znaků s čímž jsem nepočítal. Také já jsem byl šikovný, takže jsem sice v programu počítal s unique klíčem, ale v DB jsem ho neudělal a v reklamním systému je jich cca 10% duplicitních.\n\nŽádám tedy o pomoc. Víte komu patří emailová adresa `b2bdm@email.cz`? Komu patří `m-letter.eu`? Kdo zneužívá tak obrovské množství emailových adres? A kde je vůbec bere? Skutečně mě to zajímá, protože takto je to těžko představitelné, ale několik set tisíc adres je skutečně obrovské množství a já stále nevím, kde jsem se tam vzal...',	'2014-02-20 23:48:22'),
(67,	'Jaký email je nejvíce využívaný?',	'Včera jsem psal o bezpečnostní chybě, která umožňuje získat podle mého názoru nezanedbatelně velký vzorek emailových adres. Krom toho, že bych byl rád, aby byla tato chyba opravena, nemám co jiného s touto kolekcí adres dělat. Tak jsem se rozhodl vytvořit nějakou statistiku. Svým způsobem se totiž jedná o dosti specifické uživatele, protože se pravděpodobně jedná z naprosté většiny pouze o ČR a SK uživatele, takže kdo čeká, že bude např. gmail umístěn nějak dobře, možná bude překvapen.\r\n\r\nA protože po diskusích krouží mnoho rádoby matematiků, rád bych teď přesně definoval všechny vstupní a výstupní hodnoty včetně jejich chyb, čímž doufám minimalizuji to, že výsledky někdo špatně pochopí. Všechny data jsou brány z kolekce čítající **384 392 unikátních** emailových adres s tím, že uvažuji zejména u rozložení poskytovatelů emailových schránek chybu 1%. Je to dáno tím, že vstupní data nejsou úplně korektní a ukazuje se, že se dost často vyskytují emaily jako `@seznam.czsms`, `@seznam.cztel`, `@seznam.czwww`, `@seznam.czweb`, `@senam.cz` atd. Většinu takových prohřešků jsem se snažil eliminovat, každopádně není to dokonalé. Osobně bych chybu odhadoval na desetiny, možná ani ne setiny procenta, ale raději ji nechávám větší. Tato chyba je v prvním grafu také graficky znázorněna. Zajímavé je také to, že někteří lidé evidentně chápu input pro zadání emailu jako deník, takže jsou schopni napsat do tohoto řádku všechny své emailové adresy. Stojí za zamyšlení jak správně navrhovat formuláře... Dále jsou pak z výpočtů zastoupení četnosti znaků prvních písmen emailových adres vypuštěny čísla, takže tato dílčí statistika počítá s o něco menší vstupní kolekcí 382 338 emailových adres.\r\n\r\nRozložení poskytovatelů emailových schránek\r\n===========================================\r\nNásledující graf ukazuje počet emailových adres příslušejících ke konkrétní doméně. Konkrétně je zobrazeno prvních 20 největších poskytovatelů a i tak již mají poslední méně než jedno procento velikosti prvního, tedy Seznamu. Ten je v českém zastoupení naprosto bezkonkurenční. Všímejte si prosím takových věcí. Většina programátorů se totiž potkává pouze s lidma \"od gmailu\", ale to je na českém trhu pouze minoritní složka. A je to tak u všeho. Je až překvapivě obrovský nepoměr mezi tím co si většina lidí myslí a skutečností. A tento vzorek již považuji za dostatečnou skutečnost.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=744207493\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nKolikrát jsem slyšel, že jsou Centrum a Atlas mrtvé projekty. To už ani nemá smysl počítat, ale reálně se ukazuje, že tomu tak vůbec není a těmto číslům momentálně věřím, protože už je zde přehazuji několik desítek hodin... (-: Bohužel nemám představu o tom, kolik existuje emailových adres v ČR, ale veřím, že se tvarově graf moc nepohne. Pouze se bude měnit počet na svislé ose.\r\n\r\nDalší zajímavá data\r\n===================\r\nDalší graf ukazuje skutečně velkou hloupost. Ani nevím proč jsem jí vlastně dělal. Jde o početné zastoupení prvních znaků emailových adres. To jsou ty modré pruhy. Červené pruhy jsou pak předpokládaná četnost znaků pro českou abecedu podle \"Jana Králíka .{target:_blank}\":http://www.czech-language.cz/alphabet/alph-prehled.html. Není to poprvé co tuto tabulku četností používám a dá se říci, že s ní souhlasím. Každopádně mám v plánu tyto četnosti ověřit a zaktualizovat, takže se možná tento graf časem malinko pozmění.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=1555577201\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nDalší informací, která již však nemá pevně uchopitelný základ je počet TLD. Lze tedy pouze říci, že ze vzorku zkoumaných dat, tedy ze vzorku emailových adres českých uživatelů mají největší zastoupení koncovky `.cz` (290311), poté `.sk` (88764) a další v pořadí je `.com` (5183), která se však svojí četností již poněkud mimo hru. Zajímavé teké je, že většinu překlepů dělají češi. To může být tím, že jsme prostě nepozorní, nebo jsou programátoři lajdáci. Tato informace je založena na počtu korekcí doménových názvů.\r\n\r\nPoslední již nikterak využitelnou informací je délka adres. Nejdelší adresy jsou `butovice.zlicine.tel.728222069.pouzite.kalhotky@...`, `www.malirstvi.tym.czemail.malirstvi.hruby@...` a `martin.59kenvelo400500600300700800900201@...` Zakrývám alespoň domény, aby někdo neprskal, když už proti tomu tak zbrojím. Naopak nejkratší je adresa, která má se vším všudy 8 znaků: `in@.....`.\r\n\r\nZajímá vás ještě nějaká informace, která se dá z této kolekce emailových adres získat?',	'2014-02-21 17:12:09'),
(68,	'Omyly hashování hesel',	'Někdy minulý rok jsem si četl prezentaci \"Michala Špačka .{target:_blank}\":http://www.michalspacek.cz/ o \"hashování hesel .{target:_blank}\":http://www.slideshare.net/spaze/hashe-hesla-develcz-2013 a byl jsem z toho poněkud zklamán. Naprosto souhlasím se vším co tam je, přesto však nemám rád, když se dojde k závěrům, které sice na první pohled dávají smysl a fakt dobře se tak dá argumentovat, ale ve výsledku jsou podle mého názoru některé opravdu chybné. Nedávno kolem mě tato prezentace proplula znova a protože již mám celkem setříděné myšlenky, rozhodl jsem se je sepsat.\n\nTímto článkem nehodlám hatit již zmíněnou prezentaci. Naopak se chci opřít do všech prezentací a výstupů, které něco tvrdí a není to tak docela pravda. Zároveň je také nutno říct, že nebudu řešit funkce typu MD5, protože doufám, že všichni v dnešní době vědí, že funkce MD5 prostě není určena na hashování hesel. Přesto si neodpustím několik vět i o konkrétních implementačních problémech.\n\nOmyl první\n==========\nKdyž jsem se opět dožadoval matematického důkazu o problému cyklického hashování, byl jsem dokázán na \"stackoverflow .{target:_blank}\":http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/17396367#17396367, což mě mělo uspokojit. Četl jsem to pozdě v noci, takže jsem to nechal na ráno a ani tak jsem s tím nesouhlasil.\n\nV podstatě se jedná o popsání preimage útoku, který se snaží najít stejný hash jako je hash známý a tím získat původní (nebo jinou fungující) hodnotu hesla, tedy v tuto chvíli jediný zajímavý způsob. Celý důkaz toho, že cyklické hashování není dobrý nápad je prováděn na vlastní funkci a směšně malé množině vstupů. To je první divná věc. Mnohem divnější však je závěr pokusu, který tvrdí, že nekonečný vstup lze namapovat na konečnou množinu. Jedná se tedy o surjektivní zobrazení první množiny na druhou, kdy se každý prvek z první množiny namapuje na všechny prvky menší výstupní podmnožiny. A právě v tomto kroku vidím celou teoretickou úvahu jako chybnou. Žádná hashovací funkce totiž nepočítá s libovolným, nebo dokonce s nekonečným vstupem. Když to rozvedu i na konkrétní funkci MD5, pak nekonečný počet vstupů mapuji na 2^128 výstupů. Reálně (což je to co nás primárně zajímá) však mapuji 2^64 vstupů na 2^128 výstupů (čti bitů). V tu chvíli se však bavíme o injektivním zobrazení, což bylo v původním textu odsouzeno. Jak jsem k tomumo názoru došel? Vycházím z \"RFC 1321 - The MD5 Message-Digest Algorithm .{target:_blank}\":http://www.faqs.org/rfcs/rfc1321.html\n\n> A 64-bit representation of b (the length of the message before the\n> padding bits were added) is appended to the result of the previous\n> step. In the unlikely event that b is greater than 2^64, then only\n> the low-order 64 bits of b are used. (These bits are appended as two\n> 32-bit words and appended low-order word first in accordance with the\n> previous conventions.)\n\nPak už je jen malý krůček k tomu uvědomit si, že 2^64 bitové heslo je jinak řečeno něco kolem 2 exabajtů, což je tak trošku hodně i na uložení, natož na zapamatování. A i kdybych to spočetl blbě - jakože doufám, že ne - několik řádů sem tam je úplně jedno, protože množina na kterou se to mapuje je daleko větší. Stejně tak mi přijde naprosto komická tato ukázka:\n\n/--code\n$output = md5($input); // 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n\\--\n\nPřepíšu to jinak:\n\n/--code\n$output = md5($input); // 340282366920938463463374607431768211456 possibilities\n$output = md5($output); // 340282366920938463463374607431768211455 possibilities\n$output = md5($output); // 340282366920938463463374607431768211454 possibilities\n$output = md5($output); // 340282366920938463463374607431768211453 possibilities\n$output = md5($output); // 340282366920938463463374607431768211452 possibilities\n\\--\n\nVycházíme tedy z 340 undecilionů 282 decilionů 366 nonilionů 920 octilionů 938 septilionů 463 sextilionů 463 quintilionů 374 quadrilionů 607 trilionů 431 bilionů 768 milionů 211 tisíc 456 možností. Jasné? Tuto teorii tedy považuji za čistě teoretickou. Klidně si to heslo zašifrujte undecilionkrát... Ostatně stejný problém byl při šifrování vždy. Klidně se mohlo stát, že klíč od zprávy zašifrované v Enigmě (nebo kdekoliv jinde) uhodnou. Ale nedělalo se to, protože je to prostě jen papírový nesmysl. Ostatně i když se to stane, tak je to prostě debilní smůla, jenže věří snad ještě někdo tomu, že se to stane u celé databáze?\n\nOmyl druhý\n==========\nNyní budu předpokládat, že bude nyní mým cílem zjistit skutečně takové heslo, jaké bylo před zahashováním. Úplně tím tedy odbourám fakt, že dva různé texty budou mít stejný hash. To se může stát, druhá možnost však bude svým charakterem tak úplně jinde, že ji stejně nepůjde např. při přihlašování použít. Pokud tedy chci zjistit heslo z hashe u kterého vím, že bylo několikrát hashováno, nezbývá mi, než jít postupně z hashe až k heslu:\n\n/--code\n7eaefb28c9c3fe4be6997cc5b7fb599f // původní hash\n92b7db0f6d7348d91e90651d31ff9e71\n651a9c9c86f3116a53e2bb6e80bfdf69\n1b929b62a2c822c4a59e688fde2a3a0b\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nJenže jaké teď skutečné heslo? Je to \"heslo\"? Pokud bych byl chytrý a uměl si zapamatovat 32 znaků, moje heslo by určitě bylo \"1b929b62a2c822c4a59e688fde2a3a0b\" a jen bych zmátl všechny okolo. A potom je celkem sranda to, když se vrátíme k čistě teoretickému uvažování a řekněme, že se může stát, že dva hashe budou totožné:\n\n/--code\n1b929b62a2c822c4a59e688fde2a3a0b // původní hash   <-\n... // dlouhá série hashů vedoucích k opakování     |\n651a9c9c86f3116a53e2bb6e80bfdf69                    |-- stejné hashe\n1b929b62a2c822c4a59e688fde2a3a0b   <-----------------\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nVěřte, že mé heslo je teď \"651a9c9c86f3116a53e2bb6e80bfdf69\". Při pokusu o zjištění původu hashe mám dvě možnosti. Mohu najít takový hash, který je před tím prvním, ale jiný než \"955db0b81ef1989b4a4dfeae8061a9a6\", nebo právě \"955db0b81ef1989b4a4dfeae8061a9a6\". V prvním případě je to stejné jako předchozí případ. V druhém však naleznu nejdříve jinou shodu a nejen že dojdu k jinému heslu, ale také úplně přeskočím to správné heslo. Takže v určitém případě může být opakované hashování dokonce ještě bezpečnější! Opět je to pouze teorie, ale chci tím ukázat, že některé argumenty mohou být sice silné, mají však vždy i obrácenou stranu, která není o nic slabší...\n\nChtěl jsem tedy vyvrátit několik zažitých předpokladů, což se mi doufám podařilo. Musím však dodat nesmírně důležitou věc. Neobhajuji zde použití MD5 ani jiné podobné funkce (která tak jako MD5 není k hashování hesel určena). Používejte spíše funkce, které mají složitou výpočetní náročnost a jejich výstup je pro dva stejné vstupy různý. Takovou dobrou funkcí je pro PHP funcke `password_hash`, která byla vytvořena právě kvůli tomu, že v tom programátoři dělají neskutečný bordel. Použití je úplně jednoduché:\n\n/--code php\n<?php\necho password_hash(\'heslo\', PASSWORD_DEFAULT);\n\\--\n\nTato funkce momentálně používá bcrypt, do budoucna je možné použít konstantu PASSWORD_BCRYPT, protože defaultní konstanta může způsob šifrování změnit na nějaký lepší. Stejně jednoduché je i ověření hesla:\n\n/--code php\nif (password_verify(\'heslo\', \'$2y$10$2YOiYB9vFd11vTRBtqqKE.TnrT1ydXuCGsSHXbAKRvUgnpE9VaoES\')) {\n    echo \'Password is valid!\';\n} else {\n    echo \'Invalid password.\';\n}\n\\--\n\nTyto funkce, stejně tak jako dobře použitý kompatibilní `crypt` považuji za naprosto dostatečná řešení a víc se o tom není třeba již <s>nikdy</s> bavit. Tečka.\n\n<span style=\"color:green\">A pod tečkou ještě něco. Čím musím napravit nešťastně volená slova v předchozí větě. Tím že se o tom není již třeba nikdy bavit je myšleno to o čem se ve větě píše, tedy že bcrypt funkce považuji za naprosto dostatečné (v současné době i blízké budoucnosti) a za tím si stojím. Neznamená to však, že teď házím za hlavu celou tuto problematiku. Pokud bych měl tedy předchozí větu opravit, napsal bych asi, že tyto funkce považuji za naprosto dostatečné, nicméně stále má smysl tuto problematiku řešit, protože věřím, že v zřejmě ne malém horizontu let bude i tato funkce nedostatečná. Teď ale není.</span>',	'2014-02-22 14:02:31'),
(69,	'Čteme QR kódy bez čtečky',	'[* 2139a61c-efc4-4e3c-b630-5c3cbf9258df/qrcode-ahoj.png 200x200 <]\n\nPatříte mezi lidi, kteří se nespokojí pouze se čtečkou QR kódů, ale chcete vědět jak fungují? Nebo co víc jak je přečíst bez použité takové čtečky? Tak to jste na správné adrese. Dnes budu řešit zejména právě čtení QR kódu bez použití čtečky. Celou dobu budu řešit tento QR kód na levé straně, takže doporučuji nepoužívat telefon a počkat až na konec, kde se jeho obsah dozvíte. Zároveň se nebudu nijak opírat o korekci chyb a další jinak důležité věci, ale budu se co nejvíce soustředit právě na přečtení kódu bez použití jakéhokoliv přístroje. Pojďme na to...\n\nTrocha nezbytné teorie\n======================\n[* 312d5904-ab94-4877-9743-8ec902fbc50a/qrcode-parts.png <]\n\nQR kód asi viděl každý. Stejně tak předpokládám, že spoustu lidí tuší, že QR kód dodržuji určitá pravidla, aby jej šlo přečíst strojově. Jedná se zejména o \"finder pattern\", tedy ty velké čtverce, které slouží k zaměření čtečky a určení orientace kódu. Díky tomu, že jsou tři, tak lze QR kód přečíst i pokud je vzhůru nohama. Dalším významným prvkem jsou separátory, které obklopují právě tyto čtverce a slouží k oddělení zaměřovačů od zbytku kódu. Žlutě jsem zvýraznil tzv. \"timing patterns\". Ty se táhnout z rohu do rohu zaměřovacích čtverců, kdy se celou dobu střídá černá a bílá barva a slouží opět pro čtečky například k určení velikosti celého kódu. Na takto malém kódu nejsou žádní informace i verzi, ani korekční body.\n\nNejdůležitější jsou však červené a zelené části. Zde jsou uloženy informace i formátu, které následně také využijeme. Je zajímavé, že se jak červená část, tak zelená část na kódu vždy dvakrát opakuje. Informace je očíslována čísly 1-15 s tím, že kolem levého horního zaměřovače je informace celá a ta samá informace je ještě rozdělena a umístěna kolem zbylých dvou zaměřovačů. Je zde ještě jedna zajímavost. V levém dolním rohu nad číslem 9 je černé místo, tzv. \"dark module\". Toto místo by mělo být na všech kódech černé. Jedná se přebytečné místo, které vzniká při zdvojování informace o formátu. Podle specifikace by to tak mělo být, ale ne vždy to platí. Pro nás je však zajímavá jediná část z celé 15 bitů dlouhé informace a to konkrétně bity umístněné na pozici 11, 12 a 13, tedy v zelené části. Právě ty si nesou tu nejdůležitější informaci o masce. Všechny ostatní části informace slouží ke korekci chyb. Celkově se ve výsledku ukáže, že kromě samotné informace je v QR kódu sloustu \"zbytečných\" věcí, které informaci nenesou. V mašem případě je tedy maska `111` (černé místo je 1 a bílé 0). Tuto informaci je však ještě potřeba dekódovat pomocí XOR součtu přičtením hodnoty `101`, tedy:\n\n/--code\n111\n101 /XOR\n---\n010\n\\--\n\nCelá dekódovací maska je `101010000010010`, ale pro naší potřebu je potřeba pouze část `101`. Ještě než vysvětlím co to maska je, uvedu zde všechny hodnoty jaké může maska mít:\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr><td>Hodnota masky</td><td>Podmínka masky</td></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>000</td>\n      <td>(i + j) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>001</td>\n      <td>i mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>**010**</td>\n      <td>**j mod 3 = 0**</td>\n    </tr>\n    <tr>\n      <td>011</td>\n      <td>(i + j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>100</td>\n      <td>((i div 2) + (j div 3)) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>101</td>\n      <td>(i j) mod 2 + (i j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>110</td>\n      <td>((i j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>111</td>\n      <td>((i+j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n  </tbody>\n</table>\n\nTo může vypadat děsivě, ale hned vysvětlím. Podle toho jakou má kód masku vezmeme vzorec a dosadíme za **j** číslo sloupce. V našem případě se tedy bavíme o prvním a pak každém třetím sloupci. Pro tyto sloupce platí, že na nich musíme provést negaci, tedy otočit barvy. Tím QR kód odmaskujeme. Toto však platí pouze pro částí kde je opravdu nějaká informace, nikoliv pro zaměřovače, nebo například části nesoucí formátovací informaci. Toto maskování slouží k zamíchání barevných polí. Nestane se tak, že by byl kód nejednoznačný. Při kódování se totiž porovnávají jednotlivé masky, každá maska má nějaké skóré jednoznačnosti a ve výsledku se vybere ta nejjednoznačnější. Celé odmaskování je znázorněno na obrázku níže. Pravý černý QR kód je již odmaskovaný a nic nebrání jej přečíst. V tuto chvíli však již pouze bez použití čtečky.\n\n[* 63e85abb-b86a-4877-9640-fb70b4cd2542/qrcode-important.png 300x300 <]\n[* 3951a3ea-5f53-4af9-9c01-a45fd71dd5b0/qrcode-unmasked.png 300x300 *]\n\nHrajeme si na čtečku\n====================\n[* 0ed74ba7-ddec-40da-ab12-4e6b8d82103c/qrcode-decode.png <]\n\nPředchozí část byla možná trošku složitější, ale když se na to podíváte zpětně je to vlastně velice jednoduché. Stačí přečíst 3 bity z celého kódu, provést jednoduchý XOR a jak se ukáže dále, tak stačí invertovat pouze jeden sloupec, protože více jich není potřeba.\n\nPodívejte se nyní na levý obrázek. Ten ukazuje, jak budeme číst uloženou informaci. Barevně znázorněná část je kompletní informace. Zbytek kódu je pro nás v tuto chvíli jen odpad. Barevně zvýrazněná část se ještě dělí na tři podčásti. Červená oblast obsahuje informaci o módu. Bity čteme vždy podle čísel a šipek. Tento QR kód je tedy v módu `0100` což je mód \"BYTE\". Data tedy budeme rozdělovat tak, aby měla každý část 1 byte, tedy 8 bitů. Tyto módy a další informace jsou velmi podrobně popsány v oficiální dokumentaci. Modrá část nám ještě prozrazuje informaci o délce, binárně tedy `00000100` což je v desítkové soustavě číslo 4. Takže informace v tomto QR kódu má délku 4 znaky. Opíšeme si tedy řadu bitů:\n\n/--code\n01100001 01101000 01101111 01101010\n\\--\n\nZde by mohl být trošku zádrhel pro lidi, co neumí ASCII tabulku. Prozradím tedy malý fígl. Pokud binární čásla prevedeme do decimální soustavy, což je velmi jednoduché, získáme následující zápis:\n\n/--code\n97 104 111 106\n\\--\n\nA teď už je to jen posunutá abeceda, protože číslo 97 je malé **a**. Výsledkem je tedy po chvilce abecedování:\n\n/--code\na h o j\n\\--\n\nTo nebylo tak těžké, že? Je to sice absurdní a pravděpodobně nikdy nikoho neuvidím s tužkou a papírem před QR kódem, ale i tak si myslím, že je dobré tyto věci vědět, když už se QR kód používá tak často. Doporučuji všem přečíst si dokument *ISO/IEC 18004:2006*, který řeší právě QR kódy. Je to nesmírně zajímavý dokument plný obrázků a úplných popisků, ačkoliv je i v tomto dokumentu pár drobných chyb.',	'2014-02-28 12:49:05'),
(70,	'AJAX upload souborů v Nette pomocí Fine Uploaderu #2',	'\"Dříve\":http://www.zeminem.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu jsem psal o tom, jak použít Fine Uploader jakožto nástroj pro AJAXové nahrávání souborů na server. Původní článek však platí pouze pro verzi `3.*`, která je dnes již zastaralá. Pojďme si dnes ukázat v podstatě to samé, ale pro novější verzi `4.3+`, která se v učitých směrech poměrně zásadně liší od svého předchůdce. Tentokrát se to však pokusím vyřešit co nejjednodušeji.\n\nZačátek je vlastně úplně stejný. Musíme nalinkovat javascriptové soubory:\n\n/--code html\n<!-- jQuery -->\n<script src=\"{$basePath}/js/jquery.fineuploader-4.3.1.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití je úplně jednoduché, ve zjednodušené formě:\n\n/--code html\n<div id=\"image-uploader\"></div>\n\\--\n\nSnažím se ukázat opravdu jen kritické minimum, protože ty základní věci jsou stejné, případně dohledatelné v dokumentaci, takže se dají oba dva návody z velké části doplnit. Minule jsem však zatáhl do ukázek i poměrně hodně balastu, takže ten u staré verze nechám, ale bude následovat opravdu jen to nejnutnější.\n\nStejně tedy jako v předchozí verzi následuje javascriptový spouštěcí kód. Zde již vznikají určité odlišnosti:\n\n/--code javascript\n$(function () {\n	$(\'#image-uploader\').fineUploader({\n		debug: true, //hodí se pro lazení\n		request: {\n			endpoint: \'pictures?do=uploadPicture\'\n		},\n		retry: {\n			enableAuto: true\n		}\n	});\n});\n\\--\n\nPoužití je tedy téměř stejné, až na to, že jsem úplně vypustil překlad textů. V této nové verzi jsou totiž novinkou šablony (ostatně proto také nové číslo verze). Uživatel-programátor má tak více pod kontrolou výsledný vzhled uploaderu:\n\n/--code html\n<script type=\"text/template\" id=\"qq-template\">\n	<div class=\"qq-uploader-selector qq-uploader\">\n		<div class=\"qq-upload-drop-area-selector qq-upload-drop-area\" qq-hide-dropzone>\n			<span>Přetáhněte soubory sem</span>\n		</div>\n		<div class=\"qq-upload-button-selector qq-upload-button\">\n			<div>Klikněte, nebo přetáhněte obrázky</div>\n		</div>\n        <span class=\"qq-drop-processing-selector qq-drop-processing\">\n           <span>Zpracovávám přetažené soubory...</span>\n           <span class=\"qq-drop-processing-spinner-selector qq-drop-processing-spinner\"></span>\n        </span>\n		<ul class=\"qq-upload-list-selector qq-upload-list\">\n			<li>\n				<div class=\"qq-progress-bar-container-selector\">\n					<div class=\"qq-progress-bar-selector qq-progress-bar\"></div>\n				</div>\n				<span class=\"qq-upload-spinner-selector qq-upload-spinner\"></span>\n				<img class=\"qq-thumbnail-selector\" qq-max-size=\"100\" qq-server-scale>\n				<span class=\"qq-edit-filename-icon-selector qq-edit-filename-icon\"></span>\n				<span class=\"qq-upload-file-selector qq-upload-file\"></span>\n				<input class=\"qq-edit-filename-selector qq-edit-filename\" tabindex=\"0\" type=\"text\">\n				<span class=\"qq-upload-size-selector qq-upload-size\"></span>\n				<a class=\"qq-upload-cancel-selector qq-upload-cancel\" href=\"#\">Zrušit</a>\n				<a class=\"qq-upload-retry-selector qq-upload-retry\" href=\"#\">Opakovat</a>\n				<a class=\"qq-upload-delete-selector qq-upload-delete\" href=\"#\">Smazat</a>\n				<span class=\"qq-upload-status-text-selector qq-upload-status-text\"></span>\n			</li>\n		</ul>\n	</div>\n</script>\n\\--\n\nA opět následuje zpracování v handleru:\n\n/--code php\npublic function handleUploadPicture() {\n	$uploader = new \\UploadHandler();\n	$uploader->allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\");\n	$result = $uploader->handleUpload(__DIR__ . \'/../../www/uploads\');\n	$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nZde celkem není co pokazit, ale pokud by bylo potřeba vrátit chybu, provede se to opět pomocí `JsonResponse`:\n\n/--code php\n$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse(array(\n		\'error\' => $exc->getMessage(),\n)));\n\\--\n\nSamotná třída `UploadHandler` je pak opět k nalezení na \"GitHubu\":https://github.com/Widen/fine-uploader-server/blob/master/php/traditional/handler.php. Tento návod tedy mohu zakončit vlastní citací:\n\n> A to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například podle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit. To konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2014-03-03 21:15:13'),
(71,	'Sbohem NDBT, vítej Doctrine',	'Byl jsem požádán, abych napsal nejenom důvod přechodu z Nette Database na Doctrine, ale obecně co mě k tomu vedlo a jak takový přechod vlastně učinit. Na úvod bych však chtěl zdůraznit, že nejsem žádný extra programátor, vlastně to ani nestuduji, takže vše co budu ukazovat a vysvětlovat je tedy z mého pohledu a lecjakého OOP znalce by tento text mohl pobouřit... (-:\n\nNásledující text používá \"Kdyby\\Doctrine\":https://github.com/Kdyby/Doctrine, nevidím důvod proč ve spojení s Nette používat něco jiného. Je to dobrá knihovna.\n\nSbohem NDBT\n===========\nNette Database Table a obecně celé Nette Database je úžasná část frameworku a spokojeně jsem ji používal po velmi dlouhou dobu. Nikdy jsem neholdoval pokřikům, že je NDBT zabugované (jako někteří) a i když jsem vyzkoušel i jiné alternativy, vždy jsem se spokojeně vracel právě k NDBT. Použití je velice intuitivní a dobře se s tím zachází:\n\nModel:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Nette\\Database\\Context */\n	private $database;\n\n	public function __construct(Nette\\Database\\Context $context) {\n		$this->database = $context;\n	}\n\n	public function getAllPosts() {\n		return $this->database->table(\'posts\')->where(\'release_date < NOW()\');\n	}\n\n}\n\\--\n\nPresenter:\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$this->template->posts = $this->posts->getAllPosts();\n	}\n\n}\n\\--\n\nJe to jednoduché a jasné. Takové věci mám prostě rád. V modelové třídě mám jak select metody, tak insert metody, takže bych tomu správně neměl říkat repository, ale abych byl upřímný, tak je mi toto názvosloví celkem volné. Do takové objektu si prostě dám to co chci (tak jak mi to dává smysl). Nepřijde mi to vůbec podstatné. Tahání dat z databáze má však ještě jednu vrstvu a tou je vykreslování.\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->related(\'posts_tags\')->order(\'tag_id ASC\') as $post_tag}\n			<a n:href=\"Tag:default, $post_tag->tag->name\">\n				<span style=\"background: #{$post_tag->tag->color}\">{$post_tag->tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nA to je věc, která mě dlouhou dobu trápila. Dá se čekat, že když v databázi existuje jakási vazba mezi příspěvkem a tagem, tak že tuto vazbu budu chtít nějak využít. A to pokud možno co nejvíce pohodlně. A co nejvíce pohodlně znamená, že v okamžik, kdy budu pracovat s příspěvkem a vzpomenu si, že potřebuji také tagy, tak tyto tagy také dostanu. Bohužel musím znát také spojovací tabulku, která nemá (minimálně v tomto případě) žádný faktický smysl a celkově práce s takto \"dopřivázanou\" tabulkou není vůbec pohodlná a už vůbec ne intuitivní. Dává to smysl a asi to tak být musí, takže proti NDBT žádná, ale tak nějak vnitřně jsem hledal něco lepšího (čti více vyhovujícího mým požadavkům).\n\nVítej Doctrine\n==============\nSchválně se snažím vše popisovat podle mých myšlenkových pochodů, proto i nadále budu řešit úplně ten samý problém, jen s použitím Doctrine. Nutno ještě dodat, že Doctrine rozhodně nebyla jasná volba. Opět mi dlouho trvalo, než jsem obecně ORM přišel na chuť. Ještě před Doctrine jsem nějakou dobu experimentoval s \"Lean Mapperem\":http://www.leanmapper.com/ od Vojtěcha Kohouta (Tharos). Malou nevýhodou je, že téměř veškerá dokumentace je v brutálně dlouhém vláknu na Nette fóru, které má v tuto chvíli **1023 příspěvků**, takže je to občas dřina, ale myslím si, že je to skutečně povedená knihovna. Vojtěch Kohout má skutečně dobré myšlenky. Nicméně jsem prostě chtěl přijít Doctrine na chuť, takže jsem i Lean Mapper opustil. Občas dělám radikální změny, pokud by však někdo vyloženě potřeboval důvod k tomu začít s Doctrine (alespoň dočasně), pak tedy jeden mohu nabídnout. A bude velmi krátký. Vidíte někdy jako požadavek na zaměstnance znalost Lean Mapperu, nebo ActiveRow? Pokud ne, tak začněte s tím co se tam ukazuje často. Doctrine.\n\nAle zpět k tématu. Pojďme si ukázat modelovou část podle mě:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Kdyby\\Doctrine\\EntityDao */\n	private $dao;\n\n	public function __construct(Kdyby\\Doctrine\\EntityDao $dao) {\n		$this->dao = $dao;\n	}\n\n	public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {\n		return $this->dao->findBy($criteria, $orderBy, $limit, $offset);\n	}\n\n}\n\\--\n\nVelmi podobné jako u předchozího modelu. Asi by šlo si napsat nějakou `__call` metodu, protože se dost často volá to co už je v DAO objektu (viz níže), ale kdo si to jak poslepuje, tak to bude mít... A co prezentační vrstva?\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$posts = $this->posts->findBy(array());\n	}\n\n}\n\\--\n\nTo je také dost podobné. Pole kritérií potom slouží k dodatečnému filtrování ve tvaru např. `[\'id\' => 21]`, tedy předává se to, co se má použít i v SQL WHERE klauzuli. Tento zápis je mi poměrně blízký, protože jsem ho používal při komunikaci s jedním SOAP serverem. Ok, co na to šablona?\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->tags as $tag}\n			<a n:href=\"Search:default, $tag->name\">\n				<span style=\"background: #{$tag->color}\">{$tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nTak to je podle mě úplně super výsledek. Maximálně intuitivní a nic víc splňuje to má očekávání. Je však asi zřejmé, že jsem úplně vypustil jakoukoliv informaci o spojovací tabulce. A také jsem ještě neřekl, co je to `EntityDao`, se kterým se pracuje v modelu. Vlastně je to úplně jednoduché. V konfiguračním souboru definuji, že chci pracovat s jakýmsi DAO objektem, tedy objektem, který oproti repository umožňuje data nejen číst, ale také ukládat (opět pouze OOP slovíčkaření).\n\n/--code neon\nservices:\n	- App\\Pictures(@doctrine.dao(Entity\\Picture))\n	- App\\Posts(@doctrine.dao(Entity\\Post))\n	- App\\Tags(@doctrine.dao(Entity\\Tag))\n	- App\\Users(@doctrine.dao(Entity\\User))\n\\--\n\nFajn, teď mám tedy v každé modelové třídě DAO objekt. Ten obsahuje několik metod, které výrazně usnadňují práci s Doctrine (\"source\":https://github.com/Kdyby/Doctrine/blob/master/src/Kdyby/Doctrine/EntityDao.php). Do tohoto objektu předávám jakousi entitu. To je objekt, který reprezentuje strukturu databázové tabulky. To možná není napsáno úplně šťastně, ale prakticky to tak skutečně většinou je. Taková entita může vypadat například takto:\n\n/--code php\nnamespace Entity;\n\n/**\n * @ORM\\Entity\n * @ORM\\Table(name=\"posts\")\n */\nclass Post extends Doctrine\\Entities\\BaseEntity {\n\n	/**\n	 * @ORM\\ManyToMany(targetEntity=\"Tag\", inversedBy=\"posts\", cascade={\"persist\"})\n	 * @ORM\\JoinTable(name=\"posts_tags\")\n	 * @ORM\\OrderBy({\"name\" = \"ASC\"})\n	 */\n	protected $tags;\n\n	/**\n	 * @ORM\\Id\n	 * @ORM\\Column(type=\"integer\")\n	 * @ORM\\GeneratedValue\n	 */\n	protected $id;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $title;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $slug;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $body;\n\n	/** @ORM\\Column(type=\"datetime\") */\n	protected $date;\n\n}\n\\--\n\nZde je právě důležité to, že rovnou ukazuji, kde je entita reprezentující tagy (která vypadá podobně jako tato), jak se k ní dostanu a dokonce jak se má řadit. Tedy všechny tyto informace jsem ze šablony odstranil. Pro mě je to tedy úžasný pokrok, protože jsem dosáhl toho co jsem chtěl. Aby se mi s databází pracovalo dobře.\n\nNo dobře, ale...\n================\nA teď je právě čas na některé dotazy, které vznikly při přípravě tohoto článku. Tak například co když chceš položit vlastní dotaz, v Nette Database je to přeci snadné. V Doctrine \"také\":https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/Posts.php?at=master#cl-128. V tom by ORM nemělo nijak zásadně bránit...\n\nDalší věc je, že v presenteru stále zůstává jistá závislost na struktuře tabulek. Konkrétně opět mluvím o poli kritérií. Jak se úplně zbavit této závislosti a mít pokud možno vše tak, aby když změním strukturu, tak to změním jen někde a ne všude? K tomu se dají použít třeba query objekty, které v sobě drží podobu potřebného SQL dotazu, takže místo toho, abych stále ťukal ten samý dotaz, jen jinde, tak jej schovám do třídy a právě tu pak používám. Budoucí změna se pak pravděpodobně bude týkat právě pouze toho objektu a případně entit. Ono toto asi nejde úplně odstínit (nebo spíš nevím jak), protože vždy je potřeba data i nahrávat a tedy stanovit určitou hranici mezi tím co je závislé na databázi a co už není. Nicméně uvážím-li, že budu měnit strukturu tabulky třeba kvůli tomu, že chci přidat nová data, stejně budu do kódu muset jít a někde ty data vzít a někam je dát. Proto je toto možná úplně zbytečné řešit, protože tato závislost nikdy nepůjde úplně odstranit.\n\nDalší věc je trošku záludná. Týká se tříd pro vazební tabulky. Pokud tedy ukládám M:N vazbu jako v předchozím textu, tím myslím, že mi jde pouze o to, že chci uložit do této tabulky cizí klíče, tak se o nic nemusím starat a stačí mi pouze onen dokumentační komentář v entitě `Post` nad proměnnou `protected $tags`, kde je definováno vše potřebné. Problémové je, když chci uložit data i do vazební tabulky. Zde bych rád citoval jeden příspěvek ze StackOverflow, protože si myslím, že tam je vše řečeno naprosto přesně.\n\n> A Many-To-Many association with additional values is not a Many-To-Many, but is indeed a new entity, since it now has an identifier (the two relations to the connected entities) and values.\n\nA přesně takto je s tím tedy potřeba zacházet. Už se nebavíme o vazební tabulce. Už se bavíme o normální tabulce, která vyžaduje svoji entitu a pouze obsahuje dva cizí klíče místo běžného jednoho.\n\nDoufám, že se mi v tomto článku svojí délkou limitně blížící se k nekonečnu podařilo zodpovědět všechny dotazy a objasnit všechny pochybnosti. Pokud ne, můžete se na celou problematiku podívat pod drobnohledem ještě \"zde\":https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/?at=master. Máte na celou problematiku jiný názor, nebo to jak to dělám já je kompletně špatně? Sem s tím... (-:',	'2014-03-11 19:34:00'),
(72,	'Orion login stojí za prd',	'Když jsem dříve připravoval \"prezentaci o Nette Frameworku\":http://www.zeminem.cz/prednaska-z-nette-na-zcu, hledal jsem nějaký vhodný příklad, na kterém bych demonstroval zranitelnost webových aplikací. Úspešně jsem vyzkoušel pár eshopů a jednu stránku, která slouží ke školním účelům, ale není nijak oficiálně vedená pod univerzitou. Právě zde mě napadlo vyzkoušet také univerzitní systémy. A nestačil jsem se divit.\n\nPozadí univerzitního přihlašování\n=================================\nVeškeré ověřování práv a identit putuje přes WebKDC server. Tento server komunikuje s Kerberosem a dohromady tvoří systém, který umožní přihlášení pomocí univerzitních loginů. Celkově proti tomuto systému nemám vůbec nic. Mám však hodně výhrad k jeho konkrétní implementaci. Konkrétní web servery (tam kde jsou umístěny aplikace vyžadující přihlášení) komunikují se vzdáleným WebKDC serverem. Tento server zajistí korektní ověření uživatele (spolupráce s Kerberos) a vráti informaci o úspěšném ověření. Paráda. Vnitřně velmi sofistikovaný systém funguje a umožňuje SSO (Single Sign-On) napříč celou infrastrukturou. Platí to tedy i pro aplikace mimo univerzitní doménu. Zjednodušeně popsáno, ale tématem tohoto článku není ta část, která \"spolehlivě funguje\":http://webauth.stanford.edu/, ale ta část, která nefunguje.\n\n/--code\n WEBKDC <----------> KERBEROS\n   |||\n   |||\n WEBAUTH (server s aplikací vyžadující přihlášení)\n    |\n    |\n STUDENT\n\\--\n\nJako poměrně zásadní fakt vidím to, že dokud student neklikne na \"LOGIN\", tak ho tento systém nepřihlásí (většinou). Nachází se tedy na úrovni \"WEBAUTH\", ale vidí jen omezenou stránku. Jakmile se chce přihlásit, aplikace jej přesměruje na WebKDC login-server, kde může vyplnit své přihlašovací informace, nebo je již přihlášen někdy z dřívější doby a v obou případech je přesměrován zpět na server s webovou aplikací. Už vidíte ten problém? :-)\n\nXSS\" onclick=\"alert(document.cookie); //:-)\n===========================================\nPrávě komunikace mezi WEBAUTH a WEBKDC je pro ověření naprosto zásadní, ale díky tomu, že zřejmě není nastavena žádná implementační laťka, tzn. že kdokoliv chce přihlašovat pomocí tohoto systému tak si to prostě nějak naprogramuje, vznikají bezpečnostní bublinky. Pravděpodobně neexistuje žádná konvence jak tento systém implementovat, takže neexistují ani takové funkce, jako je třeba ověřování již aktivního přihlášení atd. Může se tedy stát, že budu přihlášen (ověřen) ve webové aplikaci, ale na WEBKDC jsem odhlášen, protože WEBAUTH už se o to v tuto chvíli nestará (ten je přihlášen).\n\nDíky tomuto poznatku mohu velmi jednoduše vše co jsem teď napsal zapomenout, protože se dá celé složité schéma zjednodušit na toto:\n\n/--code\n WEBAUTH                   WEB-APP\n    |          resp.          |\n    |                         |\n STUDENT                   STUDENT\n\\--\n\nTak moment. Není to úplně normální přihlášení tak jako je na jakékoliv jiné úplně obyčejné stránce? Uživatel (student, profesor, administrátor) je přihlášen a teď už je to pouze nudná otrocká práce. Myslím, že mohu prozradit, že je stránka (čti univerzitní projekty) náchylná na session hijacking, na to přijde každý blbec, který o tom četl na wiki. A asi nemá smysl tajit, že XSS je naprosto reálná (a vyzkoušená) hrozba. Nebudu však říkat kde. A vzhledem k tomu, že tento systém webových portálů (IBM Web-Sphere Portal) není žádná domácí výroba, tak předpokládám, že stejný problém budou mít i další univerzity.\n\n/--code\n WEB-APP1     WEB-APP2\n    |            |\n    |----------EVA\n STUDENT\n\\--\n\nOd první chvíle, kdy jsem na tento problém upozorňoval poprvé jsou některé věci v současné době na serverech pozměněny, ale to zásadní zůstává pořád stejné. Nezáleží na tom co je v pozadí, když je řetěz tak silný, jak je silný jeho nejslabší článek a zvlášť, když ten silný zbytek řetězu skoro ani není potřeba...',	'2014-03-16 17:00:29'),
(73,	'Plzeňský Barcamp - láska na první pohled',	'Ačkoliv jsem z dřívějších barcampů sledoval záznamy, tak jsem byl fakticky na barcampu úplně poprvé a rovnou jsem měl tu čest přednášet. Než se však dostanu k samotné přednášce, rád bych zde napsal nějaký feedback. Celkově jsem z Plzeňského Barcampu skutečně nadšen. Skvělá atmosféra, fajn lidi, spoustu jídla, alkoholu možná až moc... :-))\n\nNa druhou stranu došlo i k pár přešlapům. Některé mě mrzí více, jiné ani tak ne, každopádně... Skutečně mě mrzí to, že nebyla nahrávána na video každá přednáška.\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/eshopkonzultant\">@eshopkonzultant</a> Honzo, máme to v plánu. Pokud nám ho nic nenaruší, chtěli bychom určitě záznamy dodat nejdéle do měsíce po skončení akce.</p>&mdash; Plzeňský Barcamp (@PlzenskyBarcamp) <a href=\"https://twitter.com/PlzenskyBarcamp/statuses/454275681665687552\">April 10, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nTo se moc nepovedlo. Mrzí mě to ze dvou důvodů. Jednak jsem tak nějak slíbil, že má přednáška bude potom na netu, to však není ten závažnější problém. Daleko více mě mrzí fakt, že se teď nemohu podívat na přednášky ostatních protože jsem byl jinde. Na barcampu bylo totiž spoustu zajímavých témat.\n\nDalší už jen krátce abych nezněl moc negativně, protože se mi na barcampu opravdu líbilo a zase tak moc mě tyto věci neštvou. Přístup k netu jen pro přednášející. Měl jsem možnost toho využít, nevyužil jsem, takže o nic nejde, jen bych veřejnou wifi na takových akcích čekal. Další jsou samolepky se jménem při registraci. No já nevím jak ostatním, mě prostě vůbec nedržela a než jsem došel do prvního patra, tak jsem měl na zádech jmenovku se jménem Martina. Bohužel bez čísla. Zdravím Martinu! :-) Poslední věc, která mě mohla dost uzemnit byla ztracená prezentace. Svojí prezentaci jsem na barcamp odeslal předem jak stálo v emailu, ale když jsem se po ní ptal, tak nebyla k nalezení. Naštěstí jsem měl plán B. Uff...\n\nPřednášky\n=========\nPostupně jsem se snažil projít ty nejzajímavější přednášky. Zde je jejich přehled:\n\n*Machine learning, aneb od našeptávače k porozumění řeči (\"Jan Švec .{target:_blank}\":https://twitter.com/honza_svec)* - přednáška o strojovém učení, porozumění řeči a chápání významu psaného i mluveného textu. Některým lidem tato přednáška přišla obsahově zajímavá a skutečně byla, každopádně tyto informace jsem z velké většiny již znal, protože jsem je slyšel již dříve a zase tolik se toho v tomto oboru nemění.\n\n*Procesory letajici, tikajici, hrajici a komunikujici (\"Radek Voltr .{target:_blank}\":https://twitter.com/crawlerdev)* - to je zase opak toho prvního. Některým lidem to nepřišlo moc zajímavé, protože tyto věci znají. Já je tolik neznám a i z důvodu svých budoucích prací do školy pro mě byla tato přednáška přínosným přehledem toho jak lze nacpat slušný výpočetní výkon na malou mršku.\n\n*Virtualizace a cloudy v dnešním IT (\"Milan Brych .{target:_blank}\":http://www.orgis.cz/cs/)* - nejvíce debatované a kontroverzní téma. Každopádně Milan se toho ujal dobře a ačkoliv tam bylo spoustu lidí z oboru, tak i v publiku došlo k debatám lidí s naprosto odlišným názorem. A zpětně musím dodat, že jednoznačně souhlasím s tím, že cloud jako takový je cloudem teprve tehdy, pokud je geograficky rozložen a má dostatečnou redundanci strojů. Někdo na přednášce zmiňoval cloud funkci u NAS serverů. V tu chvíli jsem se musel pousmát...\n\n*Věrnostní program a jeho odvrácená tvář (\"Marek Mencl .{target:_blank}\":https://twitter.com/mmencl)* - asi nejlepší přenáška. Zpětný pohled za projektem, který sice nějak dopadl, ale jeho průběh nebyl úplně hladký. Přednáška byla plná reálných problémů z praxe. Super. Prostě super. Jestli bude záznam, tak doporučuji!\n\n*Pracujte v trenýrkách z kavárny. Nebo ne? (\"David Šmehlík .{target:_blank}\":https://twitter.com/davidsmehlik)* - abych byl upřímný, tak na tuto přednášku jsem šel jen proto, že jsem neměl kam jinam a vybral jsem tak nejmenší zlo. Každopádně rychle jsem zjistil, že jsem udělal dobře, protože celé povídání bylo velmi zajímavé a motivující. I přes původní nedůvěru považuji tuto přednášku za druhou nejlepší. Sorry, Marek byl lepší... :-))\n\n*O e-shopech, o automatickém výpočtu nabídek za prokliky na Heurece a o tom, kde je problém doopravdy (\"Michal Janík .{target:_blank}\":https://twitter.com/michaljanik)* - zde to bylo celkem jednoduché. Jít na populární blbost (dle zpětných názorů ostatních), nebo na SEO (jak slyším SEO, tak utíkám), nebo na prezentaci neúspěšného portálu? Vybral jsem si tedy přednášku o e-shopech. Nejsem eshopista, takže to pro mě nemělo takovou přidanou hodnotu a myslím si, že kdokoliv nad problémy obchodu přemýšlí, tak dokonverguje ke stejným závěrům jako jsou v prezentaci. Každopádně říct, že to bylo nezajímavé by bylo nejen nefér, ale ani by to nebyla pravda.\n\nOpět musím zopakovat, že mě mrzí absence kamer u ostatních přednášek.\n\nOd Caesara ke QR kódům\n======================\nA konečně k mé přednášce. :-))\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Přednáška o kódování a Thomasu Youngovi na <a href=\"https://twitter.com/search?q=%23barcampcz&amp;src=hash\">#barcampcz</a> je kulervoucí.</p>&mdash; Pavel Pajkrt (@PavelAbbePajkrt) <a href=\"https://twitter.com/PavelAbbePajkrt/statuses/455008230444638208\">April 12, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nA zde je:\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/33460846\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nDěkuji všem posluchačům. Byl jsem skutečně nadšen, když za mnou pak někdo v průběhu dne přišel a děkoval. To bylo kouzelné. Nesmírně si toho vážím. Každopádně abych se jen nevychvaloval, tak cítím určitý dluh vůči posluchačům, protože ačkoliv se mi s tím Luboš Majner i Milan Brych snažili pomoct (díky!), tak jsem nedokázal závěrečnou problematiku úplně objasnit. A vzhledem k tomu, že jsem se pak ještě o těchto věcech několikrát bavil, tak přibližně tuším v čem byly problémy.\n\nTak prvně padl dotaz z kterého bylo jasné, že jsem něco řekl fakt špatně. Proč to šifrovat tak složitě? Proč neposlat rovnou surovou zprávu, když to nejde odposlechnout? To je velice jednoduché. Je sice pravda, že (alespoň v současné době) kvantový signál nelze odposlechnout, nic však nebrání Evě zastřelit Boba a zprávu si jednoduše přečíst. To se u šifrovaného signálu nemůže stát.\n\nA jak je tedy možné že ten signál nelze odposlechnout? Jde o to, že přenášená zpráva není ve formě informace, ale přenáší se pomocí nějakého fyzikálního principu. Takže se nelze připojit na optický kabel aniž by to nebylo zjistitelné. Každopádně jsem rád za závěrečnou diskusi, jelikož byla velmi přínosná a uvědomil jsem si věci, které jsem předtím neřešil. Například komunikaci po veřejném kanálu a ověření, že Alice skutečně mluví s Bobem a ne s Evou. Přečtěte si článek tento \"http://aldebaran.cz/bulletin/2005_14_kry.php .{target:_blank}\":http://aldebaran.cz/bulletin/2005_14_kry.php. Konkrétně poslední část o spolehlivosti metody. Již rozumím padlým dotazům a dávám posluchačům za pravdu. Beru to jako poučení a příští rok už budu tento problém schopen podat ještě líp. Doufám... :-)\n\nJo a přišel si to poslechnout i David Grudl. Yaaay! :-D',	'2014-04-13 13:31:22'),
(75,	'Stáhněte si lepší blog',	'Čas od času se na Nette fóru najde někdo, kdo hledá vzorový projekt do kterého by se mohl podívat. Vlastně se většinou hledá cokoliv, jakákoliv inspirace. Bohužel se zřejmě všichni bojí toho, že o svůj projekt přijdou, protože v něm někdo najde bezpečnostní chybu. Já se toho také bojím, ale lepší než před tím utíkat je se tomu postavit čelem. A tak je to tady.\n\nKdokoliv cokoliv\n================\nK dispozici je pro nahlédnutí tento blog. A nejen k nahlédnutí, ale také k \"volnému používání\":http://www.zeminem.cz/develop.\nNa pozadí běží hned několik technologií, které si můžete prakticky osahat:\n\n+ Nette Framework (\"nette.org .{target:_blank}\":http://nette.org/)\n+ Nette Tester (\"tester.nette.org .{target:_blank}\":http://tester.nette.org/)\n+ Texy *(je sexy)* (\"texy.info .{target:_blank}\":http://texy.info/)\n+ FSHL (\"fshl.kukulich.cz .{target:_blank}\":http://fshl.kukulich.cz/)\n+ Webloader (\"addons.nette.org .{target:_blank}\":http://addons.nette.org/janmarek/webloader)\n+ Kdyby\\Doctrine 2 (\"GitHub\":https://github.com/Kdyby/Doctrine)\n\nK dispozici je i databáze, protože si myslím, že bych se i s únikem databáze neměl nijak ohrozit... :-) Účelem tohoto nápadu a následně rozhodnutí je poskytnout pokud možno funkční a aktivní projekt, který staví právě na těchto technologiích. Důvodem je pak moje zkušenost s tvrdým začátkem. Mám příležitost občas pracovat s někým kdo se přesně toto chce naučit, bohužel pár lidí už to prostě vzdalo, protože je toho *moc* a není mnoho lidí kteří skutečně pomohou (rozhodně ne na fóru). Snažím se tedy zaplnit toto prázdné místo a nabídnout tento blog jako jeden z možných začátků. Mimochodem neříkám, že moje řešení je nejlepší, nebo správné. Je jedno z možných a funkčních. Stáhnout si jej můžete ze své oblíbené verzovací služby:\n\n/---html\n<div class=\"row\" style=\"margin-top:50px;margin-bottom:50px\">\n	<div class=\"col-lg-6 col-md-6 col-sm-6 text-right\">\n		<a class=\"btn btn-default\" href=\"https://bitbucket.org/mrtnzlml/www.zeminem.cz\" target=\"_blank\">\n			<img src=\"/img/loga/bitbucket.png\">\n		</a>\n	</div>\n	<div class=\"col-lg-6 col-md-6 col-sm-6\">\n		<a class=\"btn btn-default\" href=\"https://github.com/mrtnzlml/www.zeminem.cz\" target=\"_blank\">\n			<img src=\"/img/loga/github.png\">\n		</a>\n	</div>\n</div>\n\\---\n\nPodrobnější popis najdete na \"samostatné stránce\":http://www.zeminem.cz/develop věnované tomuto projektu. Byl bych moc rád, kdybych touto cestou pouze nenabídl něco chybějícího, ale také získal zpětnou vazbu. Nestojím o pochvaly. Ty samozřejmě potěší, ale mnohem přínosnější jsou praktické poznámky k implementaci, nebo funkcím. Nad takovou věcí se vždy rád zamyslím...',	'2014-05-19 11:00:51'),
(76,	'Disqus lazy loading',	'Tento článek ve skutečnosti odstartovalo zdánlivě nesouvisející vlákno na \"Nette fóru .{target:_blank}\":http://forum.nette.org/cs/19397-ako-sa-zbavit-fid-v-url-ak-sa-nemylim. V tomto vláknu se řeší parametr *_fid* v URL adrese, který tam Nette framework přikládá kvůli flash messages. Tato vlastnost někoho skutečně hodně štve, mě zase až tak moc ne. Jenže když jsem nad tím vláknem chvíli seděl, tak jsem si uvědomil, že mám komentářový systém Disqus implementovaný špatně. Čtěte dál a vyhněte se stejné chybě... (-:\n\nUniverzální kód\n===============\nDisqus poskytuje \"by default\" univerzální kód, který prakticky pouze zkopírujete na svůj web na požadované místo a je hotovo. Tento kód vypadá zhruba takto:\n\n/--code html\n<div id=\"disqus_thread\"></div>\n<script type=\"text/javascript\">\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n    var disqus_shortname = \'\'; // required: replace it with your forum shortname\n\n    /* * * DON\'T EDIT BELOW THIS LINE * * */\n    (function() {\n        var dsq = document.createElement(\'script\'); dsq.type = \'text/javascript\'; dsq.async = true;\n        dsq.src = \'//\' + disqus_shortname + \'.disqus.com/embed.js\';\n        (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n    })();\n</script>\n<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n\\--\n\nJe to pohodlné, ale je to úplně blbě. Nejenom pro Nette aplikace, ale myslím si, že tak nějak celkově pro všechny aplikace. Fungovat to sice bude, to ano. Ale jen tak zdánlivě. Problém je totiž v tom, že toto nastavení bere jako identifikátor diskuse URL adresu a pokud se jen drobně změní, tak se založí nová diskuse. Přehled těchto diskusí je pak vidět v Disqus administraci. To s sebou nese celou řadu problémů. Diskuse nejde pořádně zamknout a už to, že k jedné stránce může být více diskusí je problém. Každá diskuse totiž musí mít unikátní identifikátor \"disqus_identifier .{target:_blank}\":https://help.disqus.com/customer/portal/articles/472098-javascript-configuration-variables nezávisle na parametrech (pokud ovšem tyto parametry nejsou žádoucí).\n\nLazy loading\n============\nJá jsem sice nepoužil defaultní konfiguraci, ale udělal jsem prakticky tu samou chybu. Teď ale konečně k lazy loadingu. Na svém blogu to již používám dlouhou dobu a myslím si, že se to již osvědčilo. Inspirací k mé implementaci je \"tento gist .{target:_blank}\":https://gist.github.com/omgmog/2310982.\n\nStačí umístit následující kód do nějakého souboru *main.js*, který se spouští po načtení stránky:\n\n/--code javascript\nvar disqus_div = $(\"#disqus_thread\");\nif (disqus_div.size() > 0) {\n    var ds_loaded = false,\n    top = $(\'.load_disqus\').offset().top, //upravit podle potřeby\n    disqus_data = disqus_div.data(),\n    check = function () {\n        if (!ds_loaded && $(window).scrollTop() + $(window).height() > top) {\n            ds_loaded = true;\n            for (var key in disqus_data) {\n                if (key.substr(0, 6) == \'disqus\') {\n                    window[\'disqus_\' + key.replace(\'disqus\', \'\').toLowerCase()] = disqus_data[key];\n                }\n            }\n            var dsq = document.createElement(\'script\');\n            dsq.type = \'text/javascript\';\n            dsq.async = true;\n            dsq.src = \'http://\' + window.disqus_shortname + \'.disqus.com/embed.js\';\n            (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n        }\n    };\n    $(window).scroll(check);\n    check();\n}\n\\--\n\nTím to však nekončí. Je samozřejmě nutné určit kde se Disqus bude zobrazovat:\n\n/--code html\n<div class=\"hidden-print\">\n	<div id=\"disqus_thread\" data-disqus-shortname=\"mrtnzlml\" data-disqus-url=\"{link //this}\"></div>\n	<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n	<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n</div>\n\\--\n\nKlíčový je zde právě data atribut *disqus-url*. No a aby byl kod kompletní, tak je zapotřebí někam umístit CSS trídu *.load_disqus*. Tu doporučuji umístit někam nad diskusi a tím myslím třeba o celou viditelnou stránku. Disqus se tak začne načítat o něco dříve, než k němu čtenář doscrolluje, takže se stihne načíst a nebude to rušit. Ve výsledku se tedy Disqus nenačítá po otevření stránky, takže je načtení svižné, ale po např. přečtení článku je již načtený...\n\nA co vy? Máte Disqus na svém webu implementovaný správně? (-:',	'2014-06-12 21:36:26'),
(77,	'Čteme Data Matrix bez čtečky',	'[* 1fc11f25-abc2-453e-abb4-adb31d0ccf17/datamatrix.png <]\n\nDnešním článkem navazuji na dřívější článek \"Čteme QR kódy bez čtečky\":http://www.zeminem.cz/cteme-qr-kody-bez-ctecky, ve kterém jsem řešil čtení QR kódu bez použití jakéhokoliv čtecího zařízení. A dnes budu řešit téměř to samé, ale s jiným kódem. Data Matrix není tolik známý, ale myslím si, že patří, hned po QR kódech, mezi nejpoužívanější kódy vůbec. Po tomto článku si jich zajisté začnete všímat více. Naposledy jsem jej viděl na balíčku od jahod... (-: Opět platí, že hlavním cílem je kód přečíst, nikoliv mu úplně porozumět, takže nebudu rozebírat velké detaily.\n\nLevý obrázek je kód o kterém bude celou dobu řeč.\n\nTrocha nezbytné teorie\n======================\n[* 0dd271b6-21ea-4c3c-a447-723b76257b50/datamatrix-key.png <]\n\nTento kód je oproti QR kódu velmi jednoduchý, takže i teorie bude stručná. Veškerá data a korekce chyb je ukryta uvnitř rámu, který je z části plný. To umožňuje čtečkám poznat kde všude je ještě kód a jak je natočen. Z pohledu \"ručního\" čtení je tato část nezajímavá. Modře jsou zvýrazněny 4 bity, které k ničemu neslouží a zaplňují jen prázdné místo. Ne vždy je tento úkaz vidět. Bohužel tentokrát nemám k dispozici originální specifikaci, takže nevím jakým přesným pravidlům to podléhá.\n\nNejpodstatnější jsou však červeně zarámované oblasti. Všechny mají takovýto tvar a vždy mají přesně dané umístění. Toto umístění je vlastně dáno první oblastí s číslem 2. Nicméně z hlediska umístění dat je nejdůležitější pátý bit v prvním sloupci od kterého vše startuje. Pokud obrazec přesahuje to timing zón, tedy do nažloutlého rámu, tak pokračuje na druhé straně, tedy dole, nebo na pravé straně.\n\nData se v kódu čtou podle čísel, tedy podél takové diagonální vlnovky a to až do obrazce s číslem 5. Tento obrazec určuje konec zprávy. V našem případě se tedy jedná o zprávu, která má 4 znaky. A jak už to tak bývá, tak jsou všechny znaky přenášeny v binárním formátu. Zbytek kódu, který není nijak zvýrazněn je klasicky Reed–Solomon korekce chyb. Možná bych o tomto mechanismu také mohl někdy napsat článek. Nicméně napovažuji to za úplně jednoduchá záležitost, takže si to zatím nechám v zásobě.\n\nHrajeme si na čtečku\n====================\n\nPřečíst zprávu v takto teoreticky rozebraném kódu už je otázka chvilky. Najdříve si vytáhneme všechny potřebné části. V tomto případě je zbytečné řešit pátý člen, jelikož se jedná o poslední ukončovací. Jeho hodnota je 129 v desítkové soustavě. Získané útvary jsou vidět na obrázku níže.\n\n[* 76028c59-4e5f-42f4-a411-3452844a30d2/last.png *]\n\nČísla určují pozici bitů v binárním čísle. Po přepsání do binární podoby mají znaky následující hodnoty:\n\n/--code\n01100010 01101001 01110000 01101011\n\\--\n\nV desítkové podobě jsou to tedy čísla:\n\n/--code\n98 105 112 107\n\\--\n\nNásledně je zapotřebí od těchto čísel odečíst jednotku. Abych řekl pravdu, tak jsem po dlouhém uvažování nedokázal přijít s rozumným vysvětlením proč se to tak dělá. Původně mě napadadlo, že je to kvůli lepšímu rozložení bitů ve výsledném obrazci. Stejně tak jako se u QR kódů bity ještě maskují. To ale nedává smysl. Je to jen posunutí o jedna. Nic víc... Nicméně je zřejmé, že spousta věcí je v takovýchto kódech minimálně na zamyšlení. Ale zpět k poslednímu kroku. Z předchozího článku již všichni vědí, že číslo 97 je v ASCII tabulce hodnota znaku **a**, takže po odečtení jednotky a přepsání do čitelné podoby získáváme řešení:\n\n/--code\n97 104 111 106\na  h   o   j\n\\--\n\nTento kód je pro čtení bez čtečky daleko snadnější, komplikuje to jen nezvyklé uspořádání bitů. Jaký další kód bych měl dostat pod drobnohled? Snad to půjde. Mám zde totiž rozpracovaný ještě jiný a nemohu k němu sehnat normu pro nahlédnutí, takže jsem se zatím zasekl... (-:',	'2014-06-15 16:34:13'),
(78,	'Novinky na blogu a extension RFC',	'Kdo pravidelně sleduje \"můj twitter\":https://twitter.com/mrtnzlml, tak už to ví. A je to skvělé! Včera jsem totiž \"mergnul\":https://github.com/mrtnzlml/www.zeminem.cz/commit/b21775df522271e81302d2987ff44d5285b245eb důležitou část tohoto blogu a tím vydal verzi 1.1 snad stable... (-: Jedná se o celkem významný krok, ale stále je to nic oproti tomu co mám v plánu. V dnešním článku bych se rád podělil o většinu zajímavých novinek a v druhé části bych rád požádat o pomoc s rozvinutím jednoho zajímavého nápadu.\n\nNovinky v release 1.1\n=====================\nA hned první novinka je ta nejzajímavější. Zastávám názor, že by si měl programátor za svým kódem stát a to v každé situaci. Proto jsem se rozhodl, že pustím kohokoliv do své administrace. Ostatně proč ne. Je to výzva. Rád bych však napřed požádal kohokoliv kdo najde nějakou chybu, aby mi to dal vědět na základě nepsané programátorské etikety a nesnažil se celý blog hned zničit. Zálohu mám... :-) Administraci najdete na adrese www.zeminem.cz/admin a přístupové údaje jsou `demo / demo`. Enjoy.\n\nAčkoliv je první představená novinka asi nejzajímavější pro kohokoliv jiného, pro mě osobně je nejzajímavější nový systém vkládání obrázků. To je něco co mi na blogu dlouho chybělo. Představoval jsem si to tak, že bych obrázky jednoduše a rychle nahrál a stejně jednoduše bych je vložil do aktuálně psaného článku. A přesně to teď můžu udělat. Použil jsem \"fineuploader\":http://fineuploader.com/, protože je to skvělý program. Můžu AJAXově nahrávat souběžně několik obrázků s velikostí klidně až za PHP limitem `upload_max_filesize` a nebo navázat na přerušené nahrávání. To vše vlastně díky chunk uploadu. Umí toto váš blog? Zkuste si na sdíleném hostingu nahrát soubor o velikosti třeba 50MB...\n\nToto jsou dvě nejdůležitější změny, na kterých jsem v desetinkové verzi pracoval. Správa uživatelů a cool image uploader. Dále jsem udělal opět několik designových změn a fixů, ale už se nejedná o nic tak důležitého aby to stálo za řeč.\n\nDalší kroky a žádost o pomoc\n============================\nSvůj blog mám rád. A mám ho rád až tak, že bych byl rád, aby ho časem používal i někdo jiný. To ještě nějakou chvíli potrvá, ale už nějaký čas mi leží v hlavě nápad, jak se k tomuto požadavku přiblížit. Rád bych totiž blog přepsal do Nette extensions. Včera jsem popré \"nakousl\":https://github.com/mrtnzlml/www.zeminem.cz/commit/1ffc33bc5dddbadfc1b6ce7d30dccb09938800cb svojí myšlenku. Princip je jednoduchý. Přepíšu například funkcionalitu obrázků (nebo čehokoliv jiného) do extension a když bude někdo budovat nový blog, tak si jen v konfigu zvolí jaké moduly chce (to se dá snadno generovat):\n\n/--code neon\nextensions:\n	- ImageExtension\n    - SearchExtension\n    - ...\n\\--\n\nSamotné extension má potom za úkol se samo spustit (`afterCompile`) a přidat nějaké funkcionality do stacku (v metodě `initialize`). V prvním nakousnutí například přidávám položku do menu a skutečně to funguje tak jak píšu. Jakmile nějakou funkci nechci, prostě ji z konfigu zruším. Výhodné na tom je to, že můžu prošpikovat blog místy, kam lze nové feature zaregistrovat a dají se velmi jednoduše provázat přes composer. **Ale.** Má to háček.\n\nKdyž jsem si s touto myšlenkou hrál jen v hlavě, tak to bylo super, protože vše fungovalo perfektně. Bohužel jsem narazil na to, že nevím jak pěkně vyřešit šablony a routování na ně. Šablony jsou totiž jedna z dalších věcí které bych zde chtěl vyřešit. Bylo by fajn, kdyby mohl mít každý možnost si třeba šablony podědit a změnit si kompletně celý design. To zase takový problém není. Ale jak vyřešit to, když chci v extension např. přidat novou stránku? Kam umístit šablonu a jak ji naroutovat? Nějak jsem to dneska v noci už nedokázal vymyslet. Máte někdo prosím nějaký zajímavý nápad? Díky...\n\nNo a naposledy už snad jenom: \"Give me a star, please\":https://github.com/mrtnzlml/www.zeminem.cz...',	'2014-07-13 14:00:51'),
(79,	'SračkoAPI',	'Následující řádky budou čistý hate na několik tvůrců API, který má posloužit budoucím tvůrcům API. Sám totiž musím obsluhovat několik služeb a získávat z nich data. A ačkoliv se nebráním složitostem, některé věci jsou tak absurdní, že až rozum zůstává stát...\n\nNo to si ze mě děláte...\n------------------------\nPrvní místo na žebříčku debility získává API pro obsluhu a registraci domén od Web4U. Jedná se o klasické SOAP API, které mě však místy přivádí k šílenství. Začnu pěkně od začátku. Aby bylo vůbec možné API volat, musíte nejdříve získat identifikátor služby. Kde jej sehnat? Napadá vás někde v aministraci? Kde jinde také, že? Omyl! Identifikátor služby se získává tak, že zavoláte jakoukoliv funkci z jejich API špatně a identifikátor najdete ve vrácené exception. A to si nedělám prdel. To fakt mají napsané v dokumentaci. A aby toho nebylo málo, tak vrácené ID je ve formátu `IDxxxxxxx, ...`. Koho by však napadlo, že ID je tich prvních 9 znaků, tak je na omylu. ID je totiž to ID bez úvodního ID, tedy `xxxxxxx`. Takto je to možná jasné, ale když k tomu poprvé sednete, tak nad tím sedíte půl dne. Následně lze funkci opět volat s vráceným ID. A právě volání je další sranda.\n\nV dokumentaci je totiž jasně napsáno co jsou povinné vstupní hodnoty, volitelné hodnoty a občas i co to vrací. Takže je to jasné, prostě tam pošlu pole hodnot key-value a je to. Hahaha. Ne. Do tohoto API se totiž posílá pole polí s tím, že je zapotřebí dodržovat přesně stanovený formát a to takovýto:\n\n/--code php\narray(\n	array(\'name\' => \'key\', \'data\' => \'value\'),\n	//...\n)\n\\--\n\nJe to jedna z věcí, která je prostě hloupá. Pokaždé se musím sám sebe ptát, proč to tak je? Nerozumím tomu, nemá to žádnou přidanou hodnotu. Jdeme dál. Řekněme, že potřebujete pomocí API zjistit nějakou informaci o doméně, například kdy skutečně expiruje. Na to se stačí jednou týdně zeptat a aktualizovat si informace v databázi. To pro případ, že byla doména prodloužena u třetí strany. No, nebudeme to rozebírat dále. Přes API nelze tuto funkci zavolat. Proč? Vyžaduje totiž captchu. Jo, ta funkce v API se fakt volá přes obrázkovou captchu. Jako jediná. Chápu jak to použít, ale prakticky všechny své projekty dělám plně automatizované, takže jediné řešení je zde najmout \"armádu Indů\":http://www.root.cz/clanky/potrebujete-obejit-captcha-zaplatte-si-armadu-indu/ a captchy louskat ručně.\n\nA takových perel je tam nespočet. Potřebujete vědět, jestli proběhla funkce v pořádku? Nope. Výstupem z funkce je totiž číslo požadavku. Chybu si totiž musíte poměrně nepěkně vydlabat z exception. Další věc je čistě logická. České domény lze registrovat pouze s NSSETem. Jinak to nejde. U jiných domén se zadávají jednotlivé NS servery. U CZ domény se musí nejdříve vytvořit identifikátor držitele kontaktu. U jiných domén se vytváří při registraci domény. To se všechno může zdát jako maličkosti, ale takové věci vše zbytečně komplikují a použití takového API je spíš otrava. Přitom si myslím, že největší příliv např. domén musí být právě strojově přes API.\n\n...ale už fakt prdel!\n---------------------\nRychlá otázka k zamyšlení. Jak uděláte API, aby bylo možné jej snadno testovat? Změníte například přístupové údaje na testovací, nebo budete posílat nějaký testovací token? OK. Myšlenka je jasná. Kdykoliv se to dá snadno přehodit např. změnou jednoho hesla do ostrého režimu. Jenom v debilním API se metody pro testování jmenují jinak, než metody pro ostré použití. Kurva! To je další věc, která to celé nepříjemně zkomplikuje.\n\n[* d10561e0-aeec-4dae-a21e-17eb7c4ca36d/gif.gif <]\nDobře, poslední příklad. Nedávno jsem zase něco nevyčetl z dokumentace. Napsal jsem tedy na technickou podporu ať mi poradí, že to tam nemají napsané. Konkrétně se jednalo o povolené vstupní hodnoty do jedné funkce. Na odpověď jsem čekal dva dny, což by ani tak nevadilo, ale hodně jsem se nasmál u odpovědi, která přišla v tomto formátu (původně zapsáno pod sebou):\n\n/--code\n\'cs\', \'sk\', \'bg\', \'hr\', \'da\', \'nl\', \'en\', \'et\', \'fi\', \'fr\', \'de\', \'el\', \'hu\', \'ga\', \'it\', \'lv\', \'lt\', \'mt\', \'pl\', \'pt\', \'ro\', \'sl\', \'es\', \'sv\'\n\\--\n\nWhat? Takže podpora také nevěděla a tak mi poslala kus vykopírovaného zdrojového PHP kódu z aplikace? V tuto chvíli už mi začíná být všechno jedno... \n\nJde to i jinak?\n---------------\nVím, že ano, ale stále častěji mě někdo přesvědčuje o opaku. Druhé ukázkové API jsem zvolil pro porovnání také typu SOAP. V tomto API je již většina věcí na které jsem do této chvíle nadával vyřešena. Dokonce jsem potěšen z toho, že se jedná o API poměrně inteligentní a tak se mohu dotazovat hodně podobně jako v Doctrine 2. Paráda.\n\nJenže pak přijde, jak říká kolega, další jobovka. API je totiž totálně bez dokumentace, takže téměř jediné místo, kde lze získat informace o vstupních a výstupních hodnotách je prohlédnout si celý dump dané funkce. Dobře, to není problém. Vidím datum ve známém formátu jako string. Posílám tedy také datum ve stejném formátu jako string. Nic. Dobře, poslím ho jako DateTime. Nic. Až po hodně dlouhé době a nahlášeném bugu jsem dostat fuck off odpověď, že to datum zadávám špatně a musí to být v následujícím formátu:\n\n/--code php\n//...\narray(\n	\'year\' => ...->format(\'Y\'),\n	\'month\' => ...->format(\'m\'),\n	\'day\' => ...->format(\'d\'),\n	\'hour\' => ...->format(\'H\'),\n	\'minute\' => ...->format(\'i\'),\n)\n//...\n\\--\n\nA dost vole, seru na to. Na to nemám nervy. Zase ta samá otázka. Proč? Vždyť... Ale nic. Už raději nic.\n\nProsím všechny programátory, **snažte se víc**. Cílem by mělo být **usnadnit používání**, nikoliv však sobě, ale **uživatelům**. Prosím...\n\nHowgh.',	'2014-07-17 21:58:50'),
(80,	'Za hranicí ORM',	'Již mnohokrát jsem slyšel, že je ORM \"antipattern\":http://www.zdrojak.cz/clanky/orm-je-antipattern/. Já si to nemyslím. Je to hloupý a uspěchaný názor. V dnešním článku však nechci rozebírat co je a co není antipattern. To je jen zbytečnou ztrátou času. Rád bych ukázal použití jednoho ORM systému, který mě naprosto uchvátil.\n\nKdyž jsou potřeba firemní procesy\n=================================\nZejména začínající firmy mají na svém startu náročný úkol. Je zapotřebí vytvořit vnitrofiremní procesy, které striktně řídí běh různých akcí jako je například výroba, reklamace, nebo třeba koloběh dokumentů. Ve firmě \"taková řešení nabízíme\":http://www.orgis.cz/sluzby/in-house a je o ně velký zájem. Má to svůj smysl. Není žádným tajemstvím, že používáme ERP systém \"Odoo\":https://www.odoo.com/, protože je to velmi silný nástroj. I přes neuvěřitelnou modifikovatelnost této aplikace je občas zapotřebí sáhnout k daleko více sofistikovanému řešení. Proč? Občas jsou totiž vnitropodnikové procesy velmi složité a navíc jich je velké množství. V takovém případě, je téměř jedinou možností napsat si pro tento ERP systém rozšíření, které tento těžký úkol zvládne.\n\n[* 393212dc-381f-4b3a-a06c-fb5d33d6dc29/workflow.png *] *** *Ukázka struktury klasického firemního workflow*\n\nNechci však psát návod na to, jak si takový modul naprogramovat. O tom třeba někdy příště. Pojďme se raději podívat na to, jak téměř celé Odoo funguje, protože je to skutečně pozoruhodné. Bez kódů to však nepůjde.\n\nZáplava tabulek\n===============\nAbych byl upřímný, tak jsem se ještě nikdy nesetkal s tím, aby byl **každý** objekt v projektu skutečně realizován tabulkou v databázi. Nebo o tom alespoň nevím. Je to v podstatě jako když máte entity a ty jsou pak skutečně v databázi. Rozdíl je však v tom, že zde je v \"entitě\" i celá potřebná logika (které většinou moc není) a hlavně žádné jiné objekty nejsou potřeba.\n\nV nejprostším tvaru může tedy třída modulu vypadat skutečně pouze jako entita:\n\n/--code python\nclass project_wkf_activity(osv.osv):\n    _name = \'project.wkf.activity\'\n    _columns = {\n        \'sequence\': fields.integer(\'Sequence\'),\n        \'name\': fields.char(\'Workflow Activity Name\', required=True, size=64, translate=True),\n        \'type\': fields.many2one(\'project.wkf.type\', \'Workflow Type\'),\n        \'fold\': fields.boolean(\'Folded in Kanban View\'),\n    }\n    # ...\n    def jumptoseq(self, cr, uid, ids, sequence, context=None):\n    	#...\n\\--\n\nPři programování modulů toto vede k extrémní explozi tabulek v databázi. 500 tabulek uděláte v databázi jako nic. Stačí nainstalovat pár modulů. A to už mi přijde dost netradiční. Kromě modulových tabulek je v základní instalaci asi 100 tabulek, které v sobě drží vše možné, mimo jiné také informace o workflow. A právě definice workflow je to nejzajímavější. Veškerá sranda se totiž odehrává v XML souborech. Ve výsledku stačí pro napsání složitého workflow včetně veškeré logiky pouze XML...\n\nXML programování (-:\n====================\nKdyž jsem toto poprvé viděl, párkrát jsem se zastavil a přemýšlel jsem, jak to vlastně může fungovat. Je to však velmi jednoduché. V inicializačním souboru modulu si stačí nadefinovat jaké XML soubory se mají načítat. Následuje definice workflow. Žádné psaní okolo. Prostě to hned funguje. Začátek takového workflow může vypadat například takto:\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<record id=\"wkf1\" model=\"workflow\">\n            <field name=\"name\">project.wkf1</field>\n            <field name=\"osv\">project.project</field>\n            <field name=\"on_create\">True</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nTím je workflow založeno a při spuštění převedeno do databáze. Jádro má pak za úkol se těchto tabulek chytit a pracovat s nimi. Jsou jasně daná pravidla, takže s tím není žádný problém. Následuje definice akcí (to jsou ty bubliny na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        \n        <record id=\"a_1_0\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_start\">True</field>\n            <field name=\"name\">start-wkf1</field>\n            <field name=\"kind\">dummy</field>\n        </record>\n\n        <record id=\"a_1_10\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"name\">nazev-activity</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">jumptoseq(10)</field>\n        </record>\n        \n        <record id=\"a_1_500\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_stop\">True</field>\n            <field name=\"name\">end</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">orgis_close()</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nA následuje definice transitions (spojení na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        <!-- viz definice aktivit -->\n        \n        <record id=\"t_1_9\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_40\"/>\n            <field name=\"act_to\" ref=\"a_1_50\"/>\n            <field name=\"signal\">a_1_40toa_1_50</field>\n        </record>\n        <record id=\"c_1_7\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_36\"/>\n            <field name=\"act_to\" ref=\"a_1_500\"/>\n            <field name=\"signal\">close_wkf</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nUkázky jsou nekompletní, protože by se to sem všechno ani náhodou nevešlo. Výsledný XML soubor vlastně stačí k tomu, aby celé workflow fungovalo. Stačí nadefinovat funkce v příslušných třídách viz například volání `jumptoseq`.\n\nDost často je také zapotřebí definovat tlačítka pro view, což se dělá také pomocí XML kde je opět originálně vyřešeno přepisování defaultní šablony. Tlačítka mají vždy nějakou akci, která zajistí, že se posuneme ve workflow dále. Na takové workflow lze pověsit úplně všechno. Poslání emailů, vygenerování faktur, založení akce v kalendáři atd. Pokud se jedná o vyloženě automatické kroky, akce se na tlačítku nemusí definovat a pak systém celé workflow proskáče a spustí všechny akce popořadě sám. Zajímavé je však to, že se po spuštění všechno nahrne do databáze a jádro Odoo se strará pouze o to, aby tento interně složitý systém fungoval správně. Všem lidem, kteří nadávají na ORM bych tedy položil následující otázku. Jak uděláte takto sofistikovaný systém bez ORM? Nebo že toto snad není ORM? A uvědomte si, jak jsem se strašně rychle dokázal dostat z ORM až na celý komplexní systém workflow. Je to proto, že jsem vůbec neuvažoval něco jako je ActiveRow... (-: I když z velké části je to spíše plnění tabulek.\n\nV tomto reálně fungujícím řešení je velmi hluboká myšlenka. A udivuje mě, že v jiných systémech toto funguje úplně obráceně. Všichni se snaží programovat spíše to jádro. Ukazuje se však, že využít kvalitní jádro, které se stará o všechno je daleko přínosnější. Vzpomeňte si na tento článek, až budete ťukat do klávesnice entity, mappery, repository, DAO objekty a další a to pouze kvůli tomu, aby bylo možné udělat nějaké takové workflow, jako jsem zde teď popsal. Už zase...\n\nPoužíváte také nějakou netradiční implementaci ORM?',	'2014-08-01 22:55:45');

INSERT INTO `pictures` (`id`, `uuid`, `name`, `created`) VALUES
(1,	'2139a61c-efc4-4e3c-b630-5c3cbf9258df',	'qrcode-ahoj.png',	'2014-07-12 16:54:26'),
(2,	'0ed74ba7-ddec-40da-ab12-4e6b8d82103c',	'qrcode-decode.png',	'2014-07-12 16:54:26'),
(3,	'63e85abb-b86a-4877-9640-fb70b4cd2542',	'qrcode-important.png',	'2014-07-12 16:54:27'),
(4,	'312d5904-ab94-4877-9743-8ec902fbc50a',	'qrcode-parts.png',	'2014-07-12 16:54:27'),
(5,	'3951a3ea-5f53-4af9-9c01-a45fd71dd5b0',	'qrcode-unmasked.png',	'2014-07-12 16:54:28'),
(6,	'1fc11f25-abc2-453e-abb4-adb31d0ccf17',	'datamatrix.png',	'2014-07-12 17:04:53'),
(7,	'0dd271b6-21ea-4c3c-a447-723b76257b50',	'datamatrix-key.png',	'2014-07-12 17:04:54'),
(8,	'76028c59-4e5f-42f4-a411-3452844a30d2',	'last.png',	'2014-07-12 17:04:54'),
(9,	'd10561e0-aeec-4dae-a21e-17eb7c4ca36d',	'gif.gif',	'2014-07-17 21:54:31'),
(10,	'393212dc-381f-4b3a-a06c-fb5d33d6dc29',	'workflow.png',	'2014-08-01 21:35:34');


INSERT INTO `posts` (`id`, `title`, `slug`, `body`, `date`, `draft`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'asymetricka-sifra-s-verejnym-klicem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\n\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\n\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\n\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\n\n/--code\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\n\\--\n\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58',	0),
(3,	'Lovec matematik',	'lovec-matematik',	'Znáte následující hádanku?\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\n\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\n\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\n\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26',	0),
(4,	'Tabulkový masakr',	'tabulkovy-masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\r\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\r\n\r\nPodívejte se na první ukázku:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\r\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\\--\r\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\r\n\r\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" rowspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">B1</td>\r\n		<td width=\"33%\" rowspan=\"4\">B2</td>\r\n		<td width=\"33%\" colspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" rowspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" rowspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">A1</td>\r\n		<td width=\"33%\" colspan=\"4\">A2</td>\r\n		<td width=\"33%\" rowspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" colspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">C1</td>\r\n		<td width=\"33%\" colspan=\"4\">C2</td>\r\n		<td width=\"33%\" rowspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">D1</td>\r\n		<td width=\"33%\" colspan=\"4\">D2</td>\r\n		<td width=\"33%\" rowspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\r\n\r\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\\--\r\nVýsledek je vidět ve třetí ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\r\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12',	0),
(6,	'Výpočet mediánu',	'vypocet-medianu',	'Zadání\r\n======\r\n\r\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\r\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \r\njednoduchost a implementační nenáročnost, paměťová spotřeba.\r\n\r\nDefinice\r\n========\r\n\r\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\r\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\r\njako je tomu například u průměru.\r\n\r\nAnalýza problému\r\n================\r\n\r\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\r\ntotiž o způsob, který zřejmě napadne každého jako první.\r\n\r\nPřímočaré řešení\r\n----------------\r\n\r\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\r\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\r\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\r\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\r\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\r\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\r\npřípadě.\r\n\r\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\r\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\r\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\r\nřazení.\r\n\r\nAlgoritmus FIND\r\n---------------\r\n\r\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\r\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\r\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\r\nmediánu.\r\n\r\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\r\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\r\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\r\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\r\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\r\numístěny na levé straně a prvky větší než pivot zase na pravé.\r\n\r\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\r\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\r\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\r\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\r\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\r\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\r\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\r\nnaším mediánem.\r\n\r\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\r\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\r\nnásledující odstavce.\r\n\r\nAlgoritmus SELECT\r\n-----------------\r\n\r\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\r\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\r\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\r\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\r\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\r\ndělení celé posloupnosti.\r\n\r\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\r\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\r\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\r\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\r\n\r\nSrovnání zmíněných algoritmů\r\n============================\r\n\r\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\r\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\r\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\r\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\r\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\r\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\r\nnejlepší možné řešení.\r\n\r\nZávěr\r\n=====\r\n\r\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\r\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\r\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39',	0),
(7,	'Osm návrhových přikázání',	'osm-navrhovych-prikazani',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14',	0),
(9,	'Návrhový vzor Singleton',	'navrhovy-vzor-singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n}\r\n\\--\r\n\r\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = Object::getInstance();\r\n\\--\r\n\r\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\r\n\r\n/--code php\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\'; //TRUE\r\n} else {\r\n	echo \'$obj1 !== $obj2\';\r\n}\r\n\\--\r\n\r\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = new Object();\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n}\r\n\\--\r\n\r\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = clone $obj1;\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n}\r\n\\--\r\n\r\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = unserialize(serialize($obj1));\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n	private function __wakeup() {}\r\n}\r\n\\--\r\n\r\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	public final function __clone() {\r\n		throw new Exception(\'Objekt nelze klonovat!\');\r\n	}\r\n	public final function __wakeup() {\r\n		throw new Exception(\'Objekt nelze deserializovat!\');\r\n	}\r\n}\r\n\\--',	'2012-12-26 20:38:01',	0),
(10,	'Návrhový vzor Factory Method',	'navrhovy-vzor-factory-method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\r\n\r\n/--code php\r\n<?php\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\\--\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	public function test() {\r\n		echo $this->attribute;\r\n	}\r\n}\r\n\\--\r\n\r\nPřípadně jeho rozhraní:\r\n\r\n/--code php\r\n<?php\r\ninterface IObject {\r\n	public function test();\r\n}\r\n\\--\r\n\r\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\r\n\r\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\r\n\r\n/--code php\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance->test();\r\n\\--\r\n\r\nPři zapojení továrny je použití zdánlivě složitější.\r\n\r\n/--code php\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance->test();\r\n\\--\r\n\r\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nA teď přidejme nový atribut - aktuální rok.\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	// ...\r\n}\r\n\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\r\n\r\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39',	0),
(11,	'Nette 2.1-dev CliRouter',	'nette-2-1-dev-clirouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem <code>php index.php</code>. Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze <code>php index.php Front:Homepage:default</code>.',	'2013-03-17 22:02:36',	0),
(44,	'Portál ZČU dočasně mimo provoz',	'portal-zcu-docasne-mimo-provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n<div class=\"alert alert-danger\">Tak dlouho jsem s tímto blogem experimentoval, až jsem o obrázek \npřišel. :-( Představte si tedy prosím screen vyhledávání na kterém je portál ZČU se zaindexovaným\ntitle \"Portál ZČU dočasně mimo provoz&hellip;\"</div>\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:',	'2013-07-28 21:58:42',	0),
(45,	'Testování presenterů v Nette',	'testovani-presenteru-v-nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\r\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\r\nV následujících odstavcích bych rád předvedl myšlenku jak si\r\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\r\n\r\nNezbytná teorie\r\n===============\r\n\r\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\r\na následně daný presenter vyrobit. Například takto:\r\n\r\n/--code php\r\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\r\n\\--\r\n\r\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\r\npomocí inject anotace.\r\n\r\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\r\n\r\n/--code php\r\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n$response = $this->presenter->run($request);\r\n\\--\r\n\r\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \r\nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\r\n\r\n/--code php\r\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\\--\r\n\r\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\r\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\r\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\r\n\r\n/--code php\r\n$html = (string)$response->getSource();\r\n$dom = \\Tester\\DomQuery::fromHtml($html);\r\n\\Tester\\Assert::true($dom->has(\'title\'));\r\n\\--\r\n\r\nPsaní, psaní, psaní...\r\n======================\r\n\r\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\r\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\r\nzačne být lehce kopírovací nuda.\r\n\r\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\r\nMůj první návrh vypadá přibližně takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\nclass Presenter extends \\Nette\\Object {\r\n\r\n        private $container;\r\n        private $presenter;\r\n        private $presName;\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->container = $container;\r\n        }\r\n\r\n        /**\r\n         * @param $presName string Fully qualified presenter name.\r\n         */\r\n        public function init($presName) {\r\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n                $this->presenter = $presenterFactory->createPresenter($presName);\r\n                $this->presenter->autoCanonicalize = FALSE;\r\n                $this->presName = $presName;\r\n        }\r\n\r\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $params[\'action\'] = $action;\r\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n                $response = $this->presenter->run($request);\r\n                return $response;\r\n        }\r\n\r\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $response = $this->test($action, $method, $params, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\r\n                $html = (string)$response->getSource();\r\n                $dom = \\Tester\\DomQuery::fromHtml($html);\r\n                \\Tester\\Assert::true($dom->has(\'title\'));\r\n\r\n                return $response;\r\n        }\r\n\r\n        public function testForm($action, $method = \'POST\', $post = array()) {\r\n                $response = $this->test($action, $method, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\r\n\r\n                return $response;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nTestování samotných presenterů je pak již otázkou několika málo řádek:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\n$container = require __DIR__ . \'/../bootstrap.php\';\r\n\r\nclass HomepagePresenterTest extends \\Tester\\TestCase {\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->tester = new \\Test\\Presenter($container);\r\n        }\r\n\r\n        public function setUp() {\r\n                $this->tester->init(\'Front:Homepage\');\r\n        }\r\n\r\n        public function testRenderDefault() {\r\n                $this->tester->testAction(\'default\');\r\n        }\r\n\r\n}\r\n\r\nid(new HomepagePresenterTest($container))->run();\r\n\\--\r\n\r\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\r\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\r\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.',	'2013-07-28 22:36:38',	0),
(46,	'CRON validátor',	'cron-validator',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\r\n\r\nMůžeš tohle, nesmíš tamto\r\n=========================\r\n\r\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\r\n\r\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\r\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\r\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\r\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\r\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\r\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\r\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\r\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\r\n\r\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\r\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\r\numístit sem celý kód alespoň vytvoření:\r\n\r\n/--code php\r\n/**\r\n  * @return Nette\\Application\\UI\\Form\r\n  */\r\nprotected function createComponentAddCron() {\r\n	$form = new Nette\\Application\\UI\\Form;\r\n	$form->addProtection();\r\n	$form->addText(\'minutes\', \'Minuty:\')\r\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\r\n	$form->addText(\'hours\', \'Hodiny:\')\r\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\r\n	$form->addText(\'mdays\', \'Dny měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\r\n	$form->addText(\'months\', \'Měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\r\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\r\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\r\n	$form->addText(\'command\', \'Příkaz:\')\r\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\r\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\r\n	$form->onSuccess[] = $this->addCronSucceeded;\r\n	return $form;\r\n}\r\n\\--\r\n\r\nA rovnou bez hloupých povídání celý validátor:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Fresh;\r\n\r\n/**\r\n * Class ValidateCron - inspired by ISPConfig\r\n * @package Fresh\r\n */\r\nclass ValidateCron extends \\Nette\\Object {\r\n\r\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\r\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\r\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\r\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\r\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\r\n\r\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\r\n        }\r\n\r\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\r\n        }\r\n\r\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\r\n        }\r\n\r\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\r\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\r\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\r\n                } else {\r\n                        return TRUE;\r\n                }\r\n        }\r\n\r\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\r\n        }\r\n\r\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\r\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\r\n                        return FALSE;\r\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\r\n                        return FALSE;\r\n                }\r\n                $time_list = explode(\",\", $value);\r\n                foreach ($time_list as $entry) {\r\n                        // possible value combinations:\r\n                        // x               =>      ^(\\d+)$\r\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\r\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\r\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\r\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\r\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\r\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\r\n                                return FALSE;\r\n                        }\r\n                        // matches contains:\r\n                        // 1       =>      * or value or x-y range\r\n                        // 2       =>      unused\r\n                        // 3       =>      value if [1] != *\r\n                        // 4       =>      empty if no range was used\r\n                        // 5       =>      2nd value of range if [1] != * and range was used\r\n                        // 6       =>      empty if step was not used\r\n                        // 7       =>      step\r\n                        if ($matches[1] == \"*\") {\r\n                                // not to check\r\n                        } else {\r\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\r\n                                        return FALSE;\r\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\r\n                                        // check if value is in allowed range and not less or equal to first value\r\n                                        return FALSE;\r\n                                }\r\n                        }\r\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\r\n                                return FALSE;\r\n                        }\r\n                } // end foreach entry loop\r\n                return TRUE;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\r\n\r\n/--code html\r\n{form $form}\r\n\r\n<ul class=\"error\" n:if=\"$form->allErrors\">\r\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\r\n</ul>\r\n\r\n...\r\n\r\n{/form}\r\n\\--',	'2013-07-28 22:53:32',	0),
(47,	'Třída pro připojení k FIO API',	'trida-pro-pripojeni-k-fio-api',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://www.zeminem.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n\\--\n\nK tomu se hodí právě následující třída:\n\n/--code php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         * @return array|mixed\n         */\n        public function transactions($from = \'-1 month\', $to = \'now\') {\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date(\'Y\');\n                }\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . \'last/\' . $this->token . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded(\'curl\')) {\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n\\--\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n/--code neon\nparameters:\n	fio_token: \'\' #token pro přístup do FIO banky\n    \n...\n\nservices:\n	- Fresh\\Fio(token: %fio_token%)\n    \n...\n\\--\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.',	'2013-07-29 10:36:44',	0),
(49,	'Using fulltext searching with InnoDB',	'using-fulltext-searching-with-innodb',	'Sometimes is quite useful to use InnoDB engine. \r\nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \r\nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \r\nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \r\nLet me show you how to search via fulltext on InnoDB tables.\r\n\r\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \r\nbut there is possible workaround. At first you need a classic InnoDB structure. \r\nFor example database of  blog:\r\n\r\n/--code sql\r\nSET NAMES utf8;\r\nSET foreign_key_checks = 0;\r\nSET time_zone = \'SYSTEM\';\r\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\r\n\r\nDROP TABLE IF EXISTS `posts`;\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  `date` datetime NOT NULL,\r\n  `release_date` datetime NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `title_3` (`title`(200))\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `tags`;\r\nCREATE TABLE `tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(50) NOT NULL,\r\n  `color` varchar(6) NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `posts_tags`;\r\nCREATE TABLE `posts_tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) NOT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `tag_id` (`tag_id`),\r\n  KEY `post_id` (`post_id`),\r\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\r\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \r\nIt would be nice to be able search on database table **posts** using fulltext search:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\r\n\\--\r\n\r\nBut it is not possible. It returns something like:\r\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\r\n\r\nLet\'s create another one table with triggers and fulltext indexes. \r\nWe need to create mirror table. For example:\r\n\r\n/--code sql\r\nDROP TABLE IF EXISTS `mirror_posts`;\r\nCREATE TABLE `mirror_posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  FULLTEXT KEY `title_body` (`title`,`body`),\r\n  FULLTEXT KEY `title` (`title`),\r\n  FULLTEXT KEY `body` (`body`)\r\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nAnd than we need to create triggers:\r\n\r\n/--code sql\r\nDELIMITER ;;\r\n\r\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\r\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\r\n\r\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\r\nUPDATE mirror_posts SET\r\n    id = NEW.id,\r\n    title = NEW.title,\r\n    body = NEW.body\r\nWHERE id = OLD.id;;\r\n\r\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\r\nDELETE FROM mirror_posts WHERE id = OLD.id;;\r\n\\--\r\n\r\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\r\nFinally we can use more complex fulltext search feature:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM mirror_posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\r\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\r\n\\--\r\n\r\nAs I said, this is just workaround, not solution. \r\nSometimes it\'s bad practice, because you need copy of indexed columns. \r\nBut it works. And for small blogs it\'s sufficient.',	'2013-07-29 21:37:51',	0),
(50,	'Problémy fulltextu v Nette',	'problemy-fulltextu-v-nette',	'Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://www.zeminem.cz/using-fulltext-searching-with-innodb).\r\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\r\nbylo řešení \"Jakuba Vrány .{target:_blank}\":http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php.\r\n\r\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\r\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\r\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\r\n\r\nNette, ty jedna zrádná bestie...\r\n================================\r\n\r\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\r\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\r\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\r\npoužití **REGEXP**.\r\n\r\nBěžný kód pro fultextové dotazování může vypadat takto:\r\n\r\n/--code php\r\n/** @var Nette\\Database\\SelectionFactory @inject */\r\npublic $sf;\r\n    \r\n$this->sf->table(\'mirror_posts\')\r\n	->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\r\n	->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\r\n	->limit(50);\r\n\\--\r\n\r\nCož vygeneruje přibližně přesně následující:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE)) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\r\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\r\nposkládám složitější dotaz:\r\n\r\n/--code php\r\n$where = \"\";\r\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE \'ft_min_word_len\'\"), 0, 1);\r\n$ft_min_word_len = 4;\r\npreg_match_all(\"~[\\\\pL\\\\pN_]+(\'[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\r\nforeach ($matches[0] as $part) {\r\n	if (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\r\n		$regexp = \"REGEXP \'[[:<:]]\" . addslashes($part) . \"[[:>:]]\'\";\r\n		$where .= \" OR (title $regexp OR body $regexp)\";\r\n	}\r\n}\r\n\\--\r\n\r\nA doplníme fluidní dotaz:\r\n\r\n/--code php\r\n...\r\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\r\n...\r\n\\--\r\n\r\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\r\n\r\n/--code sql\r\nSELECT `id` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]`api`[[:>:]]\' OR `body` REGEXP \'[[:<:]]`api`[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\r\nDůvodem jsou zpětné uvozovky v regulárním výrazu **\'\'[[:<:]]`api`[[:>:]]\'\'**.\r\n\r\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\r\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\r\npřímo ptá databáze. Existuje však vyčůranější způsob.\r\n\r\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\r\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\r\n\r\n/--code php\r\n$regexp = \"REGEXP \'[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]\'\";\r\n\\--\r\n\r\nA dotaz se následně poskládá strávně:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]API[[:>:]]\' OR `body` REGEXP \'[[:<:]]API[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\r\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\r\n\r\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\r\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\r\nale je to divné.',	'2013-07-30 22:15:33',	0),
(51,	'Routování v Nette - prakticky',	'routovani-v-nette-prakticky',	'<div class=\"alert alert-success\">Tento článek byl naposledy revidován, aktualizován a rozšířen <strong>27. června 2014</strong>. Snažím se jej držet stále aktuální&hellip;</div>\n\nV následujícím článku se budu opírat o teorii napsanou v \"dokumentaci\":http://doc.nette.org/cs/routing.\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\n\nZáklad všeho je porozumět tomu, jak se v Nette vytváří \"odkazy\":http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu.\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\n\nPrvní kroky\n===========\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu:\n\n/--code\napp/\n├─── config/\n├─── model/\n├─── presenters/\n│     └── HomepagePresenter.php\n│\n├─── router/\n├─── templates/\n│     ├── Homepage/\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\n│     │    └── ...\n│     └── @layout.latte\n│\n└─── bootstrap.php\n\\--\n\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\n\n/--code php\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n\\--\n\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\n\n/--code\nhttp://www.zeminem.cz/homepage/kontakt\n\\--\n\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibližně následující:\nBude-li se někdo odkazovat v obecném tvaru `Presenter:view`, pochop `Presenter` jako název presenteru (např. **Homepage**Presenter) a hledej tedy soubor `HomepagePresenter.php`\na `view` bude šablona presenteru, hledej ji tedy ve složce `Presenter/view.latte` a sestav URL která bude přesně v tomto tvaru.\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\n\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\n\n/--code php\n$router[] = new Route(\'<action>\', \'Homepage:default\');\n\\--\n\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\nse mění cílová šablona podle URL:\n\n/--code\nhttp://www.zeminem.cz/kontakt\n\\--\n\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\n\n/--code php\npublic function createRouter() {\n	$router = new RouteList();\n	$router[] = new Route(\'<action>\', \'Homepage:default\');\n	$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\n	return $router;\n}\n\\--\n\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře jako šablony, routa je opět jednoduchá:\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\n\\--\n\nHledá se šablona <code>sitemap.latte</code>. Přečtěte si jak vytvořit tuto šablonu v článku \"RSS a Sitemap jednoduše a rychle\":http://www.zeminem.cz/rss-a-sitemap-jednoduse-a-rychle. Výsledná URL je tak jak má být:\n\n/--code\nhttp://www.zeminem.cz/sitemap.xml\n\\--\n\nTo samé lze udělal pro RSS.\n\nJdeme do hloubky\n================\nTrošku složitější routování přichází vždy když chcete udělat něco speciálního.\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\n\n/--code\nhttp://www.zeminem.cz/2\n\\--\n\n/--code php\n$router[] = new Route(\"[<paginator-page [1|2]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\n\n/--code\nhttp://www.zeminem.cz/using-fulltext-searching-with-innodb\n\\--\n\n/--code php\n$router[] = new Route(\'<id>\', array(\n	\'presenter\' => \'Single\',\n	\'action\' => \'article\',\n	\'id\' => array(\n		Route::FILTER_IN => function ($url) {\n			return $this->posts->getIdByUrl($url);\n		},\n		Route::FILTER_OUT => function ($id) {\n			return $this->posts->getUrlById($id);\n		},\n	),\n));\n\\--\n\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\n\n/--code\nhttp://www.zeminem.cz/search/fio%20api\n\\--\n\n/--code php\n$router[] = new Route(\'search[/<search>]\', \'Search:default\');\n\\--\n\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\n\n/--code\nhttp://www.zeminem.cz/rss.xml\n\\--\n\n/--code php\n$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n\\--\n\nChová se to stejně jako u předchozího příkladu se `sitemap.xml`, v tomto příkladu však routa hledá `BlogPresenter.php` ve složce `FrontModule` a šablonu `rss.latte`, také v tomto modulu. U rout pro modulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa zvládne jazykové mutace pro FrontModul, jinak je to opět ta nejobecnější routa vůbec:\n\n/--code\nhttp://www.zeminem.cz/en/site/kontakt\n\\--\n\n/--code php\n$router[] = new Route(\'[<lang cs|sk|en>/]<presenter>/<action>[/<id>]\', array(\n	\'module\' => \'Front\',\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n));\n\\--\n\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\n\n/--code\nhttp://www.zeminem.cz/user/en/setting/password\n\\--\n\n/--code php\n$router[] = new Route(\'user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]\', array(\n	\'module\' => \'User\',\n	\'presenter\' => \'Board\',\n	\'action\' => \'default\',\n));\n\\--\n\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\n\n/--code php\n$router[] = new Route(\'sitemap.xml\', \'Front:Export:sitemap\');\n$router[] = new Route(\'kategorie/<category>\', \'Front:Product:default\');\n$router[] = new Route(\'produkt/<product>\', \'Front:Product:detail\');\n$router[] = new Route(\'\', \'Front:Product:default\');\n$router[] = new Route(\'admin/sign-<action>\', \'Admin:Sign:\');\n$router[] = new Route(\'registrace/\', \'Front:Register:new\');\n$router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\n$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n$router[] = new \\App\\RestRouter(\'api[/<presenter>[/<id>]]\', array( //vyžaduje speciální objekt (není součástí Nette)\n	\'module\' => \'Rest\',\n	\'presenter\' => \'Resource\',\n	\'action\' => \'get\',\n), \\App\\RestRouter::RESTFUL);\n\\--\n\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\n\nJak na v posledním příkladu zmíněný CLI router se dočtete v článku \"Nette 2.1-dev CliRouter\":http://www.zeminem.cz/nette-2-1-dev-clirouter.\n\nMáte nějakou zajímavou routu? Podělte se o ni... (-:',	'2013-08-04 12:19:19',	0),
(52,	'Fluent interface a PCRE',	'fluent-interface-a-pcre',	'Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu (\"inspirace .{target:_blank}\":https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php), což je druhá věc o které bych se rád zmínil.\r\n\r\nRegulární výrazy jsou peklo\r\n=======================\r\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\r\n\r\n/--code\r\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\r\n\\--\r\n\r\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\r\n\r\n/--code php\r\n<?php\r\n\r\nclass Regexp {\r\n\r\n	private $regexp = \'\';\r\n\r\n	public function has($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function maybe($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")?\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function anythingBut($value) {\r\n		$this->regexp .= \"([^\" . preg_quote($value, \'/\') . \"]*)\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function __toString() {\r\n		return \"/^$this->regexp$/\";\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nS tím, že její použití je prosté:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\');\r\n$regexp->maybe(\'s\');\r\n$regexp->then(\'://\');\r\n$regexp->maybe(\'www.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->then(\'.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\r\n\r\nFluent interfaces, regulární peklo chladne\r\n===================================\r\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\')\r\n		->maybe(\'s\')\r\n		->then(\'://\')\r\n		->maybe(\'www.\')\r\n		->anythingBut(\' \')\r\n		->then(\'.\')\r\n		->anythingBut(\' \')\r\n		->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\r\n\r\nNe, peklo je opět peklem\r\n=====================\r\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\r\n\r\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.',	'2013-08-10 22:31:21',	0),
(53,	'RSS a Sitemap jednoduše a rychle',	'rss-a-sitemap-jednoduse-a-rychle',	'Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\r\n\r\nZačněme HomepagePresenterem (DEV Nette):\r\n\r\n/--code php\r\n<?php\r\n\r\nclass HomepagePresenter extends BasePresenter {\r\n\r\n	/** @var \\Model\\Posts @inject */\r\n	public $posts;\r\n\r\n	public function renderRss() {\r\n		$this->template->posts = $this->posts->getAllPosts()->order(\'date DESC\')->limit(50);\r\n	}\r\n\r\n	public function renderSitemap() {\r\n		$this->template->sitemap = $this->posts->getAllPosts();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\r\n\r\nPro úplnost ještě \\Model\\Posts:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Model;\r\n\r\nclass Posts extends \\Nette\\Object {\r\n\r\n	/** @var \\Nette\\Database\\SelectionFactory @inject */\r\n	public $sf;\r\n\r\n	/**\r\n	 * @return Nette\\Database\\Table\\Selection\r\n	 */\r\n	public function getAllPosts() {\r\n		return $this->sf->table(\'posts\');\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n	{foreach $sitemap as $s}\r\n		<url>\r\n			<loc>{link //Single:article $s->id}</loc>\r\n		</url>\r\n	{/foreach}\r\n</urlset>\r\n\\--\r\n\r\nRss.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<rss version=\"2.0\">\r\n	<channel>\r\n		<title>Martin Zlámal [BLOG]</title>\r\n		<link>{link //:Homepage:default}</link>\r\n		<description>Nejnovější články na blogu.</description>\r\n		<language>cs</language>\r\n\r\n		<item n:foreach=\"$posts as $post\">\r\n			<title>{$post->title}</title>\r\n			<link>{link //:Single:article $post->id}</link>\r\n			<description>{$post->body|texy|striptags}</description>\r\n		</item>\r\n	</channel>\r\n</rss>\r\n\\--\r\n\r\nA pro úplnou úplnost i router:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\nuse Nette;\r\nuse Nette\\Application\\Routers\\Route;\r\nuse Nette\\Application\\Routers\\RouteList;\r\nuse Nette\\Application\\Routers\\SimpleRouter;\r\n\r\nclass RouterFactory {\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n		// na RSS se dá odkazovat normálně bez routeru, nebo:\r\n		$router[] = new Route(\'rss.xml\', \'Homepage:rss\');\r\n		//...\r\n		$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nJednoduché a na pár řádek. Jen vědět jak na to... (-:',	'2013-08-10 23:10:22',	0),
(54,	'AJAX upload souborů v Nette pomocí Fine Uploaderu',	'ajax-upload-souboru-v-nette-pomoci-fine-uploaderu',	'<div class=\"alert alert-danger\">Následující text řeší starší verzi FineUploaderu `3.*`, nikoliv nejnovější. Hledáte-li aktuálnější návod, přečtěte si prosím http://www.zeminem.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2...</div>\n\nA je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\nnahrávání souborů v Nette pomocí \"Fine Uploaderu .{target:_blank}\":http://fineuploader.com/.\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\n\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\n\n/--code html\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\n\n/--code html\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\n<div id=\"triggerUpload\">Nahrát obrázky</div>\n\\--\n\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\n\n/--code javascript\n$(function () {\n	if ($(\'#image-uploader\').length != 0) { //test existence elementu\n		$.nette.ext(\'uploader\', {\n			complete: function () { //zavěšení na konec ajaxového požadavku\n				var uploader = $(\'#image-uploader\').fineUploader({\n					request: {\n						endpoint: \'product/default/\' + $(\'#image-uploader\').data(\'id\') + \'?do=upload\'\n					},\n					text: {\n						uploadButton: \'Klikněte, nebo přetáhněte obrázky\',\n						cancelButton: \'zrušit\',\n						failUpload: \'Nahrání obrázku se nezdařilo\',\n						dragZone: \'Přetáhněte soubory sem\',\n						dropProcessing: \'Zpracovávám přetažené soubory...\',\n						formatProgress: \'{percent}% z {total_size}\',\n						waitingForResponse: \'Zpracovávám...\'\n					},\n					autoUpload: false,\n					failedUploadTextDisplay: {\n						mode: \'custom\',\n						maxChars: 70,\n						responseProperty: \'error\',\n						enableTooltip: true\n					}\n				});\n				$(\'#triggerUpload\').click(function () {\n					uploader.fineUploader(\'uploadStoredFiles\');\n				});\n			}\n		});\n	}\n\n	$.nette.init(); //inicializace nette.ajax\n});\n\\--\n\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\nTen může vypadat například takto:\n\n/--code php\npublic function handleUpload($id) {\n	$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\n	$uploader = new \\qqFileUploader($allowedExtensions);\n	//...\n	try {\n		$result = $uploader->handleUpload(__DIR__ . \'/../../../www/uploads/\' . $id . \'/default\', NULL);\n		$result[\'uploadName\'] = $uploader->getUploadName();\n		//...\n	} catch (\\Exception $exc) {\n		$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\n			\'error\' => $exc->getMessage(),\n		)));\n	}\n	$this->invalidateControl();\n	$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\njako úspěšný upload.\n\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na \"GitHubu .{target:_blank}\":https://github.com/Widen/fine-uploader-server a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\no webalize názvů souborů.\n\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použít.\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2013-08-21 22:14:44',	0),
(55,	'Důležitost titulku podruhé (a naposled)',	'dulezitost-titulku-podruhe-a-naposled',	'Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://www.zeminem.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\r\n\r\nJak málo stačí k umístění ve vyhledávači\r\n========================================\r\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\r\n\r\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\r\n\r\nJenže není zobrazení jako zobrazení\r\n===================================\r\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\r\n\r\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://www.zeminem.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://www.zeminem.cz/navrhovy-vzor-factory-method).\r\n\r\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.',	'2013-10-21 23:20:36',	0),
(56,	'LaTeX šablona',	'latex-sablona',	'Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\r\n\r\n/--code tex\r\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\r\n\\usepackage[czech]{babel}\r\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\r\n\r\n%%% PAGE DIMENSIONS\r\n\\usepackage{geometry} % to change the page dimensions\r\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\r\n\\geometry{a4paper}\r\n\r\n\\usepackage{graphicx} % support the \\includegraphics command and options\r\n\\usepackage{wrapfig} % support the wrapfigure section\r\n\r\n\\usepackage{hyperref} % links in \\tableofcontents\r\n\\hypersetup{\r\n	colorlinks,\r\n	citecolor=black,\r\n	filecolor=black,\r\n	linkcolor=black,\r\n	urlcolor=black\r\n}\r\n\r\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\r\n\r\n%%% PACKAGES\r\n\\usepackage{booktabs} % for much better looking tables\r\n\\usepackage{array} % for better arrays (eg matrices) in maths\r\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\r\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\r\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\r\n% These packages are all incorporated in the memoir class to one degree or another...\r\n\\usepackage{tikz} % graphs\r\n\\usepackage{pgfplots}\r\n\\usepackage{float}\r\n\r\n%%% HEADERS & FOOTERS\r\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\r\n\\pagestyle{fancy} % options: empty , plain , fancy\r\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\r\n\\lhead{}\\chead{}\\rhead{}\r\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\r\n\r\n%%% SECTION TITLE APPEARANCE\r\n\\usepackage{sectsty}\r\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\r\n% (This matches ConTeXt defaults)\r\n\r\n%%% ToC (table of contents) APPEARANCE\r\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\r\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\r\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\r\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\r\n\\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\r\n\r\n%%% END Article customizations\r\n\r\n\\begin{document}\r\n\r\n	...\r\n\r\n\\end{document}\r\n\\--\r\n\r\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?',	'2013-10-21 23:42:14',	0),
(57,	'Změna URL struktury',	'zmena-url-struktury',	'Rád bych tímto upozornil na změny URL adres na tomto webu. A zároveň k technické povaze tohoto webu\nprozradím i bližší informace ze zákulisí.\n\nPřed úpravou URL struktury jsem definoval několik důležitých bodů, kterých jsem se držel:\n1) Musí zůstat maximální (úplná) zpětná kompatibilita\n2) Výsledné URL musí být maximálně jednoduché a cool\n\nPředtím a potom\n===============\nDůležité je, aby stará URL adresa nekončila chybou 404, ale aby přesměrovala na novou URL.\nRSS je nyní na adrese http://www.zeminem.cz/rss. Původně bylo na adrese http://www.zeminem.cz/homepage/rss.\nObě dvě adresy fungují stále, rozdíl je v tom, že homepage/rss nyní přesměrovává pomocí 301 na */rss.\nToho se dalo docílit velice jednoduše:\n\n/--code php\n$router[] = new Route(\'rss\', \'Homepage:rss\'); //nová routa\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\'); //původní\n//záleží na pořadí!\n\\--\n\nAčkoliv je teď druhá routa zbytečná, nechal jsem jí pro případ, že bych měl nějakou URL nezachycenou.\nV tom případě ji zachytí tato obecná.\n\nZpětná kompatibilita\n====================\nStejně tak jako změna adresy RSS, tak si i ostatní adresy musí zachovat stejné vlastnosti viz první bod.\nA vzhledem k tomu, že jsem se rozhodl změnit adresu vyhledávání a tagů, nezbývalo, než další\ndvě routy přidat. Opět záleží na pořadí:\n\n/--code php\n$router[] = new Route(\'s[/<search>]\', \'Search:default\'); //nová\n$router[] = new Route(\'t[/<search>]\', \'Tag:default\'); //nová\n\n//tyto routy (až uznám za vhodné) mohu smazat:\n$router[] = new Route(\'search[/<search>]\', \'Search:default\', Route::ONE_WAY); //původní\n$router[] = new Route(\'tag[/<search>]\', \'Tag:default\', Route::ONE_WAY); //původní\n\\--\n\nOpět platí, že funguje jak stará adresa http://www.zeminem.cz/search/nette s přesměrováním 301, tak i nová \nhttp://www.zeminem.cz/s/nette. Obdobně je tomu u tagů.\n\nČarodějnictví!\n==============\nNejvětší sranda však začíná u druhého požadavku. Už dlouho jsem si pohrával s myšlenkou,\nže chci názvy článků a adresy jednotlivých stránek v menu hned za lomítkem jako v kořenovém\nadresáři. Tedy aby článek měl adresu http://www.zeminem.cz/lovec-matematik a stránka http://www.zeminem.cz/about.\nZde jsem se však vždy dostával do velkého problému. Jak rozlišit a nabídnout z databáze článek a \njak poznat, kdy naopak nabídnout stránku například s referencemi?\n\nNo, tak nejdříve je zapotřebí routa pro články:\n/--code php\n$router[] = new Route(\'<slug>\', \'Single:article\');\n\\--\nKdy v presenteru tahám články z databáze podle slugu:\n/--code php\npublic function renderArticle($slug) {\n	$post = $this->posts->getBySlug($slug)->fetch(); //načetní článku podle slugu\n	if (!$post) { //článek neexistuje (db vrací FALSE)\n		$this->forward($slug); //nabídni statickou šablonu\n	} else { // zobrazení článku\n    	//...\n    }\n}\n\\--\nCož je podle mého dostatečně elegantní řešení. Jednoduše se pokusím o načtení stránky podle slugu\nz databáze a když se to nepodaří, nabídnu nějaký latte soubor, pokud existuje. Pokud neexistuje, \ntak ErrorPresenter již obstará vrácení 404, což je správně, protože není co nabídnout...\n\nJeště je zapotřebí vytvořit jednu routu:\n/--code php\n$router[] = new Route(\'<action>\', \'Single:article\');\n\\--\nBez této routy by to také fungovalo, ale latte ony latte soubory (action) bych našel na dvou URL\nadresách, což nechci. Takže se z původního http://www.zeminem.cz/single/about dostanu na http://www.zeminem.cz/about, \ncož je cool a splňuji tak druhý požadavek.\n\nPoslední routa, která stojí za zmíňku pak zajišťuje stránkování. Pouze rozpoznává čísla podle\nregulárního výrazu a podle toho stránkuje:\n/--code php\n$regex = \'1|2|3\'; //zjednodušeně\n$router[] = new Route(\"[<paginator-page [$regex]>]\", array(\n	\'presenter\' => \'Homepage\',\n	\'action\' => \'default\',\n	\'paginator-page\' => 1\n));\n\\--\n\nOstatně to jak mám v době psaní tohoto článku router vytvořený můžete zjistit na \"bitbucketu\":https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/0580e2e9f0e4edb162fe97ad563cfef766bea625/app/router/RouterFactory.php.\n',	'2013-10-27 21:27:00',	0),
(58,	'Nette 2.2-dev',	'nette-2-2-dev',	'Nedávno byla změněna vývojová verze Nette Frameworku na 2.2-dev (https://github.com/nette/nette/commit/3a426255084163ec1a2f324ea0d3e9b3139adccc).\nTato změna s sebou přinesla explozi změn. Na následujících řádcích bych rád přiblížil\nněkteré zásadní změny, které se odehrály a je zapotřebí je upravit, aby bylo možné z verze 2.1-dev\npřejít právě na verzi 2.2-dev.\n\nNutné úpravy\n============\nPrvě se změnilo umístění konfigurátoru. Tato změna se samozřejmě týká souboru `bootstrap.php`.\nNově je konfigurátor v novém umístění:\n\n/--code php\n//$configurator = new Nette\\Config\\Configurator;\n$configurator = new \\Nette\\Configurator;\n\\--\n\nDále jsem si zvykl používat automatické injektování závislostí pomocí anotace `@inject`.\nPro opětovné použití je nutné zapnout `nette.container.accessors`, což ostatně napoví chybová hláška,\njelikož je tato volba v nové developměnt verzi Nette ve výchozím stavu zakázána. Config.neon:\n\n/--code neon\nnette:\n	container:\n    	accessors: TRUE\n\\--\n\nNyní již bude možné anotace `@inject` používat. Další změna, které mě osobně moc nepotěšila\na nevím co jí předcházelo je zrušení podpory krátkého zápisu bloků:\n\n/--code html\n<!-- Předtím: -->\n{#content}\n	...\n{/#}\n<!-- Nyní: -->\n{block content}\n	...\n{/block}\n\\--\n\nTato změna se mi moc nelíbí, protože například stále funguje `{include #parent}`, což je prostě\nzvláštní... Za zmínku také stojí změna třídy pro práci s databází. Zatímco se ve verzi 2.0.13\nnormálně používá `Nette\\Database\\Connection`, ve verzi 2.1-dev se přešlo na `Nette\\Database\\SelectionFactory`, \nnicméně ve verzi 2.1.0RC2 se již pracuje s `Nette\\Database\\Context` a SelectionFactory již neexistuje. \nToto  platí i pro verzi 2.2-dev. Tato změna mi bude zřejmě dlouho trvat, než ji vstřebám.\nMyslím si, že obyčejné `Nette\\Database` by bylo v modelu daleko více vypovídající než nějaký Context, \nale budiž.\n\nTolik k podle mého zásadním změnám, které zabrání například spuštění projektu z quickstartu. Nyní\nbych rád poukázal na několik málo změn z celé té exploze, které mě zaujaly.\n\nDalší změny\n===========\nByla odstraněna celá řada zastaralých věcí. Nemá smysl je rozebírat. Je jich hodně a zastaralé jsou\nuž od 2.1. Každopádně například makro `n:input` se stalo zastaralé a k dispozici je nové makro\n`{inputError}`, které ošéfuje vykreslení chybové hlášky u příslušného políčka. Jééj! :-)\n\nLehce odlišně se také přistupuje k checkboxům a vůbec, formuláře jsou zase o něco lepší, což\npředpokládám souvisí s:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Chtěl jsem v rychlosti udělat příklad, jak v <a href=\"https://twitter.com/search?q=%23netteFw&amp;src=hash\">#netteFw</a> renderovat formuláře s Twitter Bootstrapem.&#10;&#10;Zabitej den a překopaný Nette…</p>&mdash; geekovo (@geekovo) <a href=\"https://twitter.com/geekovo/statuses/409064701369516032\">December 6, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nKonečně!\n========\nSvětlo světa spatřil nový \"quickstart\":http://doc.nette.org/cs/2.1/quickstart v češtině pro dnes již téměř nekatuální verzi 2.0.13.\nVěřím tomu, že se jedná o daleko přínosnější věc, než psaní pokročilých návodů v angličtině\n(navazujících na quickstart) a doufám, že tento počin pomůže pár lidí popostrčit dál...\n\nJaká změna vás zaujala nejvíce?',	'2013-12-15 14:10:23',	0),
(59,	'Přednáška z Nette na ZČU',	'prednaska-z-nette-na-zcu',	'Dnes jsem měl tu čest přednášet na ZČU studentům předmětu KIV/WEB - Webové aplikace.\nPřednášku a i celé povídání jsem se snažil chopit velmi realisticky, prakticky a pro studenty, \nkteří s tvorbou webových aplikací teprve začínají. Doufám, ze bylo mé povídání\ninspirativní, srozumitelné a pochopitelné. Ostatně sami si prezentaci můžete přečíst:\n<br><br>\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29326870\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe>\n\n<br>\nVěřím, že Nette bude používat zase o něco více začátečníků a že še jim podaří psát kvalitní\nwebové aplikace. Rád bych ještě jednou popřál všem studentům úspěšné složení zkoušky z předmětu KIV/WEB\na snad se ještě někdy potkáme... (-:',	'2013-12-18 17:54:22',	0),
(60,	'Veřejná distribuce klíčů',	'verejna-distribuce-klicu',	'<blockquote>\n  Inspirací a zdrojem informací pro tento článek byla kniha <strong>Simona Singha</strong> - Kniha kódu a šifer.\n  <small>Utajování od starého Egypta po kvantovou kryptografii</small>\n</blockquote>\n\nTímto článkem bych rád navázal na článek o asymetrickém šifrování http://www.zeminem.cz/asymetricka-sifra-s-verejnym-klicem a vyřešil tak několik restů. Zejména potom onu osudnou veřejnou distribuci klíčů o které jsem sice již dříve psal, ale článek již není k dispozici. Proto tento text budu brát jako revizi původního. Také bych na začátek chtěl říct, že tento problém je již dávno vyřešen a proto bude následující text ohlédnutím za vznikem této myšlenky s tím, že je však použití stále aktuální a reálně se používá (např.: http://nodejs.org/api/crypto.html#crypto_class_diffiehellman).\n\nDistribuce klíčů? Vždyť je to tak snadné...\n===========================================\nPokud si chtějí dvě osoby vyměnit zašifrované zprávy, je jasné, že musejí znát i klíče, které jim umožní tyto zprávy dešifrovat. Jenže jak si vyměnit tyto klíče? Mohou se tyto osoby někdy potkat a klíč si povědět. To však není vždy možné. Navíc klíče je dobé frekventovaně měnit, takže je v dnešní době toto řešení naprosto nesmyslné.\n\n<blockquote>\n  Dříve, než dva lidé mohou sdílet tajemství, musí již jedno tajemství sdílet.\n  <small>Dříve než dva lidé mohou sdílet šifrovanou zprávu, musí již sdílet klíč.</small>\n</blockquote>\n\nAčkoliv je osobní výměna bezpečná, jedná se tedy o metodu nereálnou a je třeba navrhnout jiné postupy. Co třeba najmou kurýra? Je to sice méně bezpečné, ale eliminují se některé předchozí problémy. Bohužel kurýr je až příliš nebezpečný způsob, protože pak lze klíč rovnou nějakým kanálem poslat a dostáváme se opět na začátek. Je tedy vůbec možné si vyměnit klíč bez nutnosti potkat se? Je tedy vůbec nutné si klíč vyměnit?\n\nMožná to jde i jinak\n====================\nExistuje skvělá hádanka, která na první pohled daný problém řeší. Představte si poštovní službu, která však všechny zásilky otevírá a čte si je. Nicméně Alice potřebuje poslat tajný balík Bobovi. Lze využít tuto poštu tak, aniž by balík otevřela?\n\nPřistupím rovnou k řešení, které je opravdu jednoduché. Alice pošle balík (schránku), který opatří vlastním zámkem a klíč od tohoto zámku si ponechá. V tom případě není pošta schopna balík otevřít. Bohužel ani Bob balík neumí otevřít, protože nemá k dispozici správný klíč. Proto Bob vezme vlastní zámek a schránku zamkne ještě vlastním zámkem. Klíč si opět ponechá. To může vyznít zvláštně, ale hned to začne být jasné. Bob balík opět odešle, Alice sundá vlastní zámek (protože od něj má klíč) a balík pošle opět Bobovi. Nyní je na balíku pouze Bobovo zámek a ten ho může jednoduše odemknout. Zdá se tedy, že lze cokoliv poslat zabezpečeně a výměna klíčů není potřeba! Toto je nesmírně důležitá myšlenka.\n\nMá to však háček. Ačkoliv se zdá být předchozí problém naprosto zřejmý a funkční, po převedení do světa kódů a šifer, celá myšlenka padá. Důvod je jednoduchý. Bylo velmi snadné na schránku umístit zámek **A**, poté zámek **B**, poté odstranit zámek **A** a nakonec odstranit zámek **B**. Takže posloupnost  šifrování byla +A => +B => -A => -B. Použijete-li však tento postup pomocí doposud známých šifer, zjistíte, že záleží na pořadí šifrování, resp. dešifrování. Zkrátka nelze toto pořadí zaměnit, jinak je výsledek zamíchaný a nepoužitelný.\n\nTak to je problém...\n====================\nAčkoliv byla myšlenka posílání balíku téměř ideální, ve světě šifer již nefunguje. Co teď? Na scénu přichází matematika. Konkrétně jednosměrné funkce a s nimi modulární aritmetika. Nemyslím si, že má smysl řešit co je to jednosměrná funkce, ale zkráceně jednosměrná funkce je taková funkce, která se nedá (nebo velmi těžce) zvrátit. Jeko velmi dobrý příklad takové funkce je například smíchání dvou barev (nelze získat zpět původní barvy). Obdobně pro matematické funkce. Zkrátky vždy je o to nalézt takovou funkci, kterou je velmi jednoduché použít a spočítat, ale již velmi složité invertovat výsledek. Právě pro tyto úlohy se perfektně hodí modulární aritmetika. Tam kde se běžná aritmetika chová předvídatelně a na základě pokusů lze konvergovat k výsledku, v modulární takováto chování neexistují.\n\nŘešení\n======\nNásledující algoritmus je zhruba použit v šifrách DES (pro velká čísla). Budu však používat malá, aby bylo vše lépe pochopitelné. Alice a Bob se <strong>veřejně</strong> dohodnou na funkci *Y<sup>x</sup>(mod P)*, kdy si číla např. Y=5 a P=8 vymění (a útočník je může odposlechnout).\n\nTeď tedy zná příjemnce, odesílatel i útočník danou funkci. Odesílatel a příjemnce si nyní zvolí jiné číslo <strong>které uchovají v tajnosti</strong>, toto číslo vloží do matematické funkce *Y<sup>x</sup>(mod P)* a výsledek odešlou. Například Bob zvolil x=4, tedy *5<sup>4</sup>(mod 8)=1*. Alice volí x=3, tedy *5<sup>3</sup>(mod 8)=5*. Tyto výsledky si vymění.\n\nZ pohledu útočníka lze říci, že zná funkci a zná také výsledky, konkrétně 1 a 5. S touto znalostí by šlo možná privátní číslo **x** dopočítat. Jenže vyzkoušejte si to. Pro malá čísla možná, ale pro velká je to téměř nemožné. A že se používají velká čísla...\n\nNyní vezme Alice výsledek od Boba a spočte *vysledek<sup>x</sup>(mod P)*, tedy *1<sup>3</sup>(mod 8)=1*. Nezapomeňte, že číslo **x** je stále privátní a zná ho jen Alice. Stejně teď postupuje i Bob, ale s vlastním privátním číslem a výsledkem od Alice: *5<sup>4</sup>(mod 8)=1*. A zde je vidět k čemu došlo. Výsledek obou výpočtů vyšel stejně a k přenosu priváního čísla **x** nikdy nedošlo. Vyzkoušejte si to na papír a nejlépe pro větší čísla. Pro útočníka nastává velký problém, protože nezná privátní číslo a je pro něj tedy nemožné provést tyto výpočty, nicméně Alice i Bob mají k dispozici jeden výsledek, tedy jeden klíč, který mohou používat.\n\nZávěr\n=====\nJeště zopakuji k čemu tedy došlo. Bylo zapotřebí dohodnout se mezi odesílatelem a příjemcem na společném klíči, podle kterého bude posílaná zpráva šifrována. To se pomocí vhodných matematických metod povedlo a navíc (což je to njdůležitější) není téměř možné tento přenos odposlechnout, jelikož se jedná o jednosměrné operace.\n\nAnalogicky lze použít opět míchání barev. Alice a Bob mají nádobu s litrem červené barvy. Stejnou nádobu má i útočník. Alice i Bob nyní nalijí vlastní privátní barvu do nádoby a tyto nádoby si vymění. Útočník je může vidět, ale nedokáže z nich odhadnout jaká je privátní barva. Nakonec Alice i Bob nalijí zbytek své tajné barvy do nádoby (již je mají vyměněné), čímž vznikne Alici i Bobovi stejná barva. Ani Alice, ani Bob, ani útočník neví co bylo přidáno za barvy od toho druhého, ale se znalostí vlastního privátního klíče se dostanou ke stejnému výsledku. útočník tyto klíče nezná a je nahraný.\n\nTak a zde by měl začínat článek http://www.zeminem.cz/asymetricka-sifra-s-verejnym-klicem.\n\nTento a daleko více inspirativních nápadů a příběhů naleznete v knize https://www.kosmas.cz/knihy/146743/kniha-kodu-a-sifer/.',	'2013-12-22 12:08:24',	0),
(61,	'Stáhněte si zdarma 897457 emailových adres',	'stahnete-si-zdarma-897457-emailovych-adres',	'V následujícím článku bych rád nastínil problematiku newsletterů nejen z programátorského hlediska <s>a také bych se rád opřel do bezpečnosti společnosti Wedos, které mnoho lidí tolik věří</s>... (-:\n\n<span style=\"color:green\">Tento projekt pravděpodobně nemá se společností Wedos nic společného jak jsem si zřejmě mylně myslel.</span>\n\nNa začátku byl email\n====================\nJednoho dne mi přišel email, který byl automaticky filtrován jako spam. Vzhledem k tomu, že když mě něco štve, tak to řeším, spam jsem otevřel a hledal odkaz na odhlášení. Ten byl dobře umístěn, stačilo kliknout a hotovo. Každý přece ví, že to takto má být. Když je odhlášení delší, než kliknutí na spam v email klientovi, je to problém. Bohužel tento odkaz vedlo na doménu <code>m-letter.eu</code>. Mě samozřejmě zajímá jak jsem se dostal do takového spam listu a jelikož jsem byl odkázán na mě neznámou doménu, byl jsem velmi rozezlen.\n\n<s>Zde je nutné říct, že jsem dříve jednal, než pátral. Nakonec se ukázalo, že jsem byl možná v tomto listu oprávněně, jelikož se jedná o doménu, ze které zřejmě Wedos odesílá podobné reklamní emaily, takže je dost pravděpodobné, že jsem s tím dříve souhlasil.</s>\n\n<span style=\"color:green\">Při hlubším pátrání jsem zjistil, že jsem stále nic nezjistil. Chybně jsem tento problém svedl na někoho jiného, což mě odvedlo na špatnou kolej. Stále tedy nevím, kde jsem se na tomto spam listu vzal a opět to beru osobně. Není mi to jedno...</span>\n\nNeštvi programátora\n===================\nCelý reklamní systém je udělán dosti nešťastně, takže než abych pátral jak jsem se tam dostal, soustředil jsem se na něco jiného, co pro mě z pohledu programátora webových aplikací bylo dost zajímavé. URL adresa. Celá adresa pro odhlášení je v následujícím formátu:\n\n/--code\nhttp://www.m-letter.eu/odh.html?c=XXXXXXX&s=53&q=51\n\\--\n\nKde **XXXXXXX** je číslo zhruba od 1300486 do 2197943. To mě zaujalo a tak jsem toto číslo začal měnit. A ukázalo se, že jsem odhlašoval další lidi. V té době ještě tato stránka vypsala informaci o úspěšném odhlášení včetně emailu, který byl odhlášen. Vzhledem k tomu, že stránka je velmi jednoduchá, lze programově stejně jednoduše získat onu emailovou adresu.\n\nJen si představte program, který iteruje tuto URL adresu a jen sbírá emaily. 897457. To je počet emailů které takto získáte. **897457**. Navíc tímto celý systém znehodnotíte, protože všechny odhlásíte. A pro takový počet emailů to již není zanedbatelné.\n\nTo má být jako oprava?\n======================\nNejde mi zrovna o to znehodnotit celý čupr dupr systém na spamování, ale proč ne. Tato informace se poměrně rychle rozšířila a o pár minut později mi byl odepřen přístup na tento server. Navíc výpis byl pozměněn tak, aby již nešlo stáhnout téměř 900 000 emailových adres. Nicméně celý systém zřejmě stále funguje stejně, takže můžete jednoduše iterovat URL adresy a tím celý systém znehodnotit:\n\n/--code php\n<?php\nfor ($i=2197943; $i > 1300486; $i--) {\n    file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\");\n}\n\\--\n\nDoporučuji spustit v příkazové řádce, kde není nastaven pro PHP timeout. Iterace je schválně pozpátku, protože se dá předpokládat, že ty nejnovější záznamy mají větší číslo a ty s malým číslem už dost možná nebudou aktuální. Celý program jsem měl daleko složitější, vzhledem k tomu, že jsem byl připraven na stáhnutí všech emailů. Po změně výpisu již většina programu není potřeba a stačí tedy tři řádky pro znehodnocení celého nezanedbatelně velkého systému.\n\n<s>Dejme tedy někomu z Wedos čas na opravu a pak hurá na hromadný lynč.</s> <span style=\"color:green\">Opět stejný problém jako předtím. Doufám, že mám tentokrát pravdu...</span> Sice jde jen o emailové adresy, ale vzpomeňte si na to až zase budete nadávat na spam, nebo souhlasit s tím, že vaše emailová adresa nebude nikde uveřejněna.',	'2014-01-27 12:33:57',	0),
(62,	'Představení projektu Vacuum - STATIC',	'predstaveni-projektu-vacuum-static',	'Vzhledem k tomu, že vzrostl zájem o Vacuum projekty, rozhodl jsem se zde uveřejnit postup jak pracovat s projektem **Vacuum - STATIC** (https://bitbucket.org/mrtnzlml/vacuum-static). Věřím, že je daleko lepší projekt ukázat a lehce popsat, než popsat a lehce ukázat, jak si Nette komunita občas myslí...\n\nCo to vlastně je\n================\nVacuum - STATIC je projekt, který vznikl z úplně základního Nette skeletonu, který jsem používal pro jednoduché statické firemní prezentace jako je například http://www.businessservice.cz/. Postupem času jsem dodával vylepšení a když už tento projekt dosáhl svého maxima, rozhodl jsem se do něj napsat jednoduchou administraci. V současné době tedy Vacuum - STATIC vlastně vůbec není statická prezentace. Obsahuje vestavenou SQLite databázi, díky které není potřeba nějaké MySQL databáze. Web prostě funguje zdánlivě bez databáze. Toto je velmi zásadní. Vacuum - STATIC pravděpodobně nikdy nebude mít externí databázi, takže se bude stále tvářit jako jednoduchá webová prezentace, která má však navíc jednoduchou administraci.\n\nStažení, instalace, spuštění\n============================\nCelý projekt se dá stáhnout různě, asi nejjednodušší je využít funkcionalit GITu:\n\n/--code\n>> git clone https://mrtnzlml@bitbucket.org/mrtnzlml/vacuum-static.git folder\nCloning into \'folder\'...\nremote: Counting objects: 433, done.\nremote: Compressing objects: 100% (401/401), done.\nremote: Total 433 (delta 201), reused 0 (delta 0)\nReceiving objects:  92% (399/433), 636.00 KiB | 192 KiB/s\nReceiving objects: 100% (433/433), 664.47 KiB | 192 KiB/s, done.\nResolving deltas: 100% (201/201), done.\n\\--\n\nTím vytvoříte složku `folder`, která bude obsahovat aktuální verzi projektu Vacuum - STATIC. Pokud v tuto chvíli projekt sputíte, vrátí chybu, že nemůže najít soubor `autoload.php`. Je to proto, že projekt ještě neobsahuje žádné knihovny (například Nette). Ty totiž nemá smysl udržovat v repozitáři. Veškeré potřebné knihovny lze doinstalovat jednoduše pomocí Composeru:\n\n/--code\n>> composer update\nLoading composer repositories with package information\nUpdating dependencies (including require-dev)\n  - Installing nette/tester (dev-master a60c379)\n    Cloning a60c379836617422c8df9d9846fea4efa2ca9d1d\n\n  - Installing nette/nette (dev-master a748c3d)\n    Cloning a748c3d344767ed1f0cc9ee40019f6a6f81afa97\n\n  - Installing janmarek/webloader (dev-master 3d44d30)\n    Cloning 3d44d306d59591dc94f6fdcb98f55c0990d98326\n\n  - Installing texy/texy (dev-release-2.x 79d0e15)\n    Cloning 79d0e1517363ab32edf2db8ec515e3dc84f50f0a\n\nnette/nette suggests installing ext-fileinfo (*)\njanmarek/webloader suggests installing leafo/lessphp (Lessphp is a composer for LESS written in PHP.)\nWriting lock file\nGenerating autoload files\n\\--\n\nV tuto chvíli je projekt připraven k použití. V některých systémech však bude potřeba ještě nastavit práva k zápisu složkám `temp` a `log`. Dokonce není potřeba ani nějakého XAMPP serveru. Stačí v té samé složce využít integrovaného PHP serveru v příkazové řádce:\n\n/--code\nphp -S localhost:8888 -t www\n\\--\n\nFunkční Vacuum - STATIC pak naleznete na adrese http://localhost:8888/. Trapně jednoduché a překvapivě funkční. (-: Vzhledem k tomu, že již vidíte funkční stránku, můžete se přihlásit do administrace (link v patičce). Přihlašovací údaje jsou *demo*/*demo*.\n\nUpdate projektu\n===============\nNa tomto projektu stále pracuji a čas od času v něm něco doplním nebo upravím. Vzhledem k tomu, že doporučuji použít ke stažení GIT, je update projektu velmi jednoduchý. Stejně jako jsem nedávno zapomněl přidat nahrát dva soubory:\n\n/--code\n>> git pull\nUpdating ead4a56..2439d5f\nFast-forward\n www/js/codemirror.js | 5516 ++++++++++++++++++++++++++++++++++++++++++++++++++\n www/js/xml.js        |  338 ++++\n 2 files changed, 5854 insertions(+)\n create mode 100644 www/js/codemirror.js\n create mode 100644 www/js/xml.js\n\\--\n\nTo je asi tak vše co se k tomu dá teď napsat. Nic na tom není, jen je třeba vědět jak na to. Přeji hodně úspěchů při používání tohoto projektu ať už je to ke studijním účelům, nebo k reálné webové prezentaci. Zpětnou vazbu samozřejmě rád uvítám.',	'2014-01-28 18:10:34',	0),
(63,	'Vlna na webu',	'vlna-na-webu',	'Vlna je program \"Petra Olšáka .{target:_blank}\":http://ftp.linux.cz/pub/tex/local/cstug/olsak/vlna/, který slouží k umístění nezalomitelné místo na místo v textu, kde by nemělo dojít k samovolnému zalomení řádku. Tento program slouží k dodatečné úpravě textů napsaných v LaTeXu. V tomto prostředí se nezalomitelná mezera nahrazuje znakem vlnovkou - tildou (~). U webového výstupu se používá zástupná entita <code>&amp;nbsp;</code>.\n\nKde by měla být nedělitelná mezera\n==================================\nV základu program Vlna umístí tildu za znaky <code>KkSsVvZzOoUuAI</code>. Více toho pokud vím nedělá. Podle Ústavu pro jazyk český AV ČR by však toto pravidlo mělo platit mimo jiné pro znaky <code>KkSsVvZzAaIiOoUu</code>. Neuvažuji další pravidla, která určují další nevhodné výrazy na konci řádku. Mezi tyto pravidla patří například mezery uvnitř číslic, mezery mezi číslicí a značkou, atd. Některá pravidla jsou totiž natolik specifická, že by je bylo náročné (nebo nepraktické) podchytit programově.\n\nImplementace\n============\nO samotné nahrazování se stará následující regulární výraz:\n/--code php\npreg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n\\--\nTento výraz říká, že nestojí-li bezprostředně před sadou znaků <code>KkSsVvZzAaIiOoUu</code> jiný alfanumerický znak a stojí-li za touto sadou jakýkoliv alfanumerický znak oddělený bílým znakem bude tento znak nahrazen entitou <code>&amp;nbsp;</code>. V konkrétní implementaci lze zaregistrovat Vlnu jako helper pro Latte šablony například takto (obsahuje i registraci Texy helperu):\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	$template->registerHelper(\'vlna\', function ($string) {\n		$string = preg_replace(\'<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i\', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n		return $string;\n	});\n	return $template;\n}\n\\--\n\nVlna se pak v Latte šablonách používá jako jakýkoliv jiný helper:\n\n/--code\n{$post->title|vlna}\n\\--\n\nJeště by možná stálo za to vrátit se k tomu, jaké problémy by způsobovala implementace i dalších pravidel a jak by to bylo náročné. Ještě nad tím budu přemýšlet, každopádně již teď mě napadají určité problémy. Například u čísel. Jak přesně identifikovat, kdy se má použít nedělitelná mezera a kdy ne? Možná je toto právě ten důvod, proč takové rozšířené chování program Vlna nepodporuje...',	'2014-02-01 22:09:38',	0),
(64,	'Použití Texy s FSHL',	'pouziti-texy-s-fshl',	'Někdy (hodně dávno) jsem kdesi našel poměrně hezký a jednoduchý postup jak implementovat \"Texy .{target:_blank}\":http://texy.info/ s použitím \"FSHL .{target:_blank}\":http://fshl.kukulich.cz/ na webu. Rád bych se zde podělil o postup, který používám již na řadě projektů, které potřebují zvýrazňování syntaxe.\n\nPoužití samotného Texy\n======================\nBěžně by se Texy zaregistrovalo do šablony jako helper:\n\n/--code php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n	$template = parent::createTemplate($class);\n	$texy = new \\Texy();\n	$template->registerHelper(\'texy\', callback($texy, \'process\'));\n	return $template;\n}\n\\--\n\nTento helper lze i nadále používat. Hodě se například pokud je potřeba Texy prvky naopak escapovat:\n\n/--code\n{$post->body|texy|striptags}\n\\--\n\nPoužití Texy s FSHL\n===================\nSamotné texy je sice geniální nástroj. Pro samotné zpracování se zvýrazněním se však hodí funkcionalitu Texy rozšířit, jelikož je potřeba zpracovat vstupující text a ty správná místa prohnat také tím správným lexxerem ve FSHL. K tomu dobře poslouží následující třída, která dědí právě od Texy:\n\n/--code php\n<?php\n\nclass fshlTexy extends Texy {\n\n	public function blockHandler($invocation, $blocktype, $content, $lang, $modifier) {\n		if ($blocktype !== \'block/code\') {\n			return $invocation->proceed(); //vstup se nebude zpracovavat\n		}\n\n		$highlighter = new \\FSHL\\Highlighter(\n			new \\FSHL\\Output\\Html(),\n			\\FSHL\\Highlighter::OPTION_TAB_INDENT | \\FSHL\\Highlighter::OPTION_LINE_COUNTER\n		);\n\n		$texy = $invocation->getTexy();\n		$content = Texy::outdent($content);\n\n		//Set correct lexer:\n		switch(strtoupper($lang)) {\n			case \'CPP\': $lexer = new \\FSHL\\Lexer\\Cpp(); break;\n			case \'CSS\': $lexer = new \\FSHL\\Lexer\\Css(); break;\n			case \'HTML\': $lexer = new \\FSHL\\Lexer\\Html(); break;\n			case \'JAVA\': $lexer = new \\FSHL\\Lexer\\Java(); break;\n			case \'JAVASCRIPT\': $lexer = new \\FSHL\\Lexer\\Javascript(); break;\n			case \'NEON\': $lexer = new \\FSHL\\Lexer\\Neon(); break;\n			case \'PHP\': $lexer = new \\FSHL\\Lexer\\Php(); break;\n			case \'PYTHON\': $lexer = new \\FSHL\\Lexer\\Python(); break;\n			case \'SQL\': $lexer = new \\FSHL\\Lexer\\Sql(); break;\n			case \'TEX\': $lexer = new \\FSHL\\Lexer\\Tex(); break; //WARNING: vlastní výroba!\n			case \'TEXY\': $lexer = new \\FSHL\\Lexer\\Texy(); break;\n			default: $lexer = new \\FSHL\\Lexer\\Minimal();\n		}\n\n		$content = $highlighter->highlight($content, $lexer);\n		$content = $texy->protect($content, Texy::CONTENT_BLOCK);\n\n		$elPre = TexyHtml::el(\'pre\');\n		if ($modifier) {\n			$modifier->decorate($texy, $elPre);\n		}\n		$elPre->attrs[\'class\'] = strtolower($lang);\n\n		$elCode = $elPre->create(\'code\', $content);\n\n		return $elPre;\n	}\n\n}\n\\--\n\nTato třída při správném použití zajistí, že se použije ten správný lexer a ještě na úrovni PHP zajistí změnu výstupu. Konkrétně obalí určitá klíčová slova (v závislosti na kontextu) tagem <code>&lt;span&gt;</code> se zvláštní třídou. Toho se následně lze chytit v CSS a HTML výstup obarvit. Použití této třídy například v metodě <code>render*()</code>:\n\n/--code php\n$texy = new \\fshlTexy();\n//registrace handleru z nové třídy:\n$texy->addHandler(\'block\', array($texy, \'blockHandler\'));\n//dále stejně jako klasické použití Texy:\n$texy->tabWidth = 4;\n$texy->headingModule->top = 3; //start at H3\n$this->template->body = $texy->process($post->body);\n\\--\n\nVýstup lze pak v Latte lehce podchytit a zobrazit:\n\n/--code\n{$body|noescape}\n\\--\n\nBarvy, barvy, barvičky\n======================\nProgramově je sice tělo dokumentu vypsáno s tagy <code>&lt;span&gt;</code> s příslušnou třídou. To se však nijak viditelně neprojeví. Celou krásu udělá teprve CSS. Lze použít výchozí hodoty FSHL a vložit je do vlastního souboru stylů:\n\n/--code css\n/* Common */\n.xlang { color: #ff0000; font-weight: bold; }\n.line { color: #888888; background-color: #ffffff; }\n\n/* CSS */\n.css-at-rule { color: #004a80; font-weight: bold; }\n.css-tag { color: #004a80; }\n.css-id { color: #7da7d9; font-weight: bold; }\n.css-class { color: #004a80; }\n.css-pseudo { color: #004a80; }\n.css-property { color: #003663; font-weight: bold; }\n.css-value { color: #448ccb; }\n.css-func { color: #448ccb; font-weight: bold; }\n.css-color { color: #0076a3; }\n.css-comment { background-color: #e5f8ff; color: #999999; }\n\n/* CPP */\n.cpp-keywords1 {color: #0000ff; font-weight: bold;}\n.cpp-num {color: #ff0000;}\n.cpp-quote {color: #a52a2a; font-weight: bold;}\n.cpp-comment {color: #00ff00;}\n.cpp-preproc {color: #c0c0c0;}\n\n/* HTML */\n.html-tag {color: #598527; font-weight: bold;}\n.html-tagin {color: #89a315}\n.html-quote {color: #598527; font-weight: bold;}\n.html-comment {color: #999999; background-color: #f1fae4;}\n.html-entity {color: #89a315;}\n\n/* Java */\n.java-keywords1 {color: #0000ff; font-weight: bold;}\n.java-num {color: #ff0000;}\n.java-quote {color: #a52a2a; font-weight: bold;}\n.java-comment {color: #009900;}\n.java-preproc {color: #c0c0c0;}\n\n/* Javascript */\n.js-out {color: #898993;}\n.js-keywords1 {color: #575757; font-weight: bold;}\n.js-num {color: #575757;}\n.js-quote {color: #575757; font-weight: bold;}\n.js-comment {color: #898993; background-color: #f4f4f4;}\n\n/* Neon */\n.neon-section {color: #598527;}\n.neon-sep {color: #ff0000;}\n.neon-key {color: #0000ff;}\n.neon-comment {color: #999999;}\n.neon-value {color: #000000;}\n.neon-quote {color: #884433;}\n.neon-num {color: #448ccb;}\n.neon-var {color: #ffaa00;}\n.neon-ref {color: #884433;}\n\n/* PHP */\n.php-keyword1 {color: #dd2244; font-weight: bold;}\n.php-keyword2 {color: #dd2244;}\n.php-var {color: #ffaa00; font-weight: bold;}\n.php-num {color: #ff0000;}\n.php-quote {color: #884433; font-weight: bold;}\n.php-comment {color: #999999; background-color: #ffffee;}\n\n/* Python */\n.py-keyword1 {color: #0033cc; font-weight: bold;}\n.py-keyword2 {color: #ce3333; font-weight: bold;}\n.py-keyword3 {color: #660066; font-weight: bold;}\n.py-num {color: #993300;}\n.py-docstring {color: #e86a18;}\n.py-quote {color: #878787; font-weight: bold;}\n.py-comment {color: #009900; font-style: italic;}\n\n/* SQL */\n.sql-keyword1 {color: #dd0000; font-weight: bold;}\n.sql-keyword2 {color: #dd2222;}\n.sql-keyword3 {color: #0000ff; font-weight: bold;}\n.sql-value {color: #5674b9;}\n.sql-comment {color: #ffaa00;}\n.sql-num {color: #ff0000;}\n.sql-option {color: #004a80; font-weight: bold;}\n\n/* Tex */\n.tex-func {color: #ffaa00; font-weight: bold;}\n.tex-comment {color: #999999; background-color: #ffffee;}\n.tex-attr1 {color: #dd2222;}\n.tex-attr2 {color: #0000ff; font-weight: bold;}\n.tex-math {color: #00AA00; font-weight: bold;}\n\n/* Texy */\n.texy-hlead {color: #4444bb; font-weight: bold;}\n.texy-hbody {background-color: #eeeeff; color: #4444bb;}\n.texy-hr {color: #bb4444;}\n.texy-code {color: #666666;}\n.texy-html {color: #66aa66;}\n.texy-text {color: #6666aa;}\n.texy-err {background-color: #ff0000; color: #ffffff;}\n\\--\n\nCelá krása tohoto řešení spočívá v tom, že nepoužívám žádné javascriptové knihovny, ale vše se provede pěkně na úrovni PHP a bude to tedy fungovat vždy, stejně tak jako Texy... (-:',	'2014-02-02 10:47:06',	0),
(65,	'Udržujete dokumentaci stále aktuální?',	'udrzujete-dokumentaci-stale-aktualni',	'Již dlouho si v hlavě pohrávám s jednou myšlenkou, kterou stále nemohu dovést do zdárného konce. Již na samém začátku jsem již však věděl, že se zajisté nezalíbí velké skupině programátorů. Přesto si myslím, že má něco do sebe. Jen jsem ji ještě nedomyslel tak, aby jsem s ním byl spokojen. Třeba bude mít někdo nějaký geniální nápad.\n\nNa začátku byl problém\n======================\nA každý problém by se měl řešit. Mluvím teď o jednom konkrétním. *Jak udržet dokumentaci projektu aktuální?* To je problém, který některé projekty dokáží bez větších problémů. Obdivuji člověka, který napíše kus kódu a k němu napíše přehlednou a užitečnou dokumentaci. Ještě více však obdivuji toho, kdo aktualizuje kus kódu a opět se pustí na přepisování dokumentace. V praxi je toto však bolístka, která trápí většinu projektů, které používá menší než obrovské množství...\n\nMyslím si, že tento postup je částečně zcestný. Není problém napsat dokumentaci, ale problém je se pak vracet k napsaným textům a číst je znova a znova a stále je upravovat. Má tento problém vůbec nějaké řešení? Možná ano. Pokud zůstanu u myšlenky, že jednou napsat dokumentace a dost, může se leckomu zdát, že při tomto postupu není možné dokumentaci aktualizovat. Definjme tedy alespoň rámcově tyto pojmy. Pod dokumentací si představuji webovou stránku s případnou obsahovou strukturou, která obsahuje jak veškeré naučné texty, tak ukázky kódů. Praktické ukázky. Tak jak to ve skutečnosti funguje.\n\nBěžné zadání dokumentace, že? Nikde jsem však nenapsal, že tato dokumentace musí obsahovat přímo napsané povídání. Musí tento text ve výsledku obsahovat, ale nemusí být součástí!\n\nCo prosím?\n==========\nMyslím to přesně tak jak jsem napsal. Dokumentace musí na výstupu obsahovat veškeré texty a prostě všechno, ale nemusí je při tvorbě obsahovat. To zní možná trošku divně. Není ta věta v rozporu sama se sebou? Ne nutně. Dokumentaci bych si opravdu představoval jako soubor pravidel obsahující nadpis, několik programových direktiv a to by bylo v podstatě všechno. Mohlo by to vypadat například takto pro nějaký tutoriál:\n\n/--code\nToto je nadpis stránky v dokumentaci\n\nindex.php\nbootstrap.php\nHomepagePresenter.php:renderDefault\n\\--\n\nSchválně jsem zvolil všem tolik známý sandbox z Nette Frameworku. V souboru bych tedy jen definoval jen (omáčku okolo), nadpis, soubory odkud se má dokumentace generovat, popř. nějaký výběr. Zde je nutné říct, že by byl projekt po programové stránce poněkud zvláštní a nejsem si jist, jestli je to úplně OK. usel by totiž obsahovat onu dokumentaci viz např. *index.php*:\n\n/--code php\n<?php\n\n/**\n ** Zde je umístněna dokumentace.\n ** Obsahuje kompletní poučný text, který se pak vyfiltruje do dokumentace včetně\n ** řádků, popř. metod ke kterám se vztahuje. Pro lepší použití by bylo potřeba\n ** definovat několik zřejmě anotací jako např:\n **\n ** @doc-lines 12-14\n ** @doc-highlight 14\n **/\n$container = require __DIR__ . \'/../app/bootstrap.php\'; ///>label\n\n$container->application->run();\n\\--\n\nTakovýto soubor je pak jednoduché vzít, rozebrat, naservírovat text, aplikovat funkci entit a vykreslit i kód ke kterému se tento komentář vztahuje. Možná by šlo vytvořit i nějaká návěští pro odkazování se do kódu, protože číslo řádky není úplně nejvhodnější (<code>///>label</code>).\n\nPro et Contra\n=============\nJednoznačně by tento postup vedl k tomu, aby programátor kromě psaní kódu udržoval i komentář, který by byl běžně velmi blízko. Jednalo by se tak vlastně o jednu práci. Netřeba otevírat celou dokumentaci, stačí změnit pouze malou část, která se s pushnutím zobrazí i v dokumentaci. Na druhou stranu, nedovedu si tento postup představit v kombinaci s klasickým PHPDOC. Nenapadá mě jiné řešení, než udržovat klasický projekt a vedle projekt, který by sloužil pouze pro dokumentaci. Například onen sandbox z NetteFW. Při takovém postupu mi to však dává docela dobrý smysl. Dokumentace by byla doslova stejně aktuální jako zdrojové kódy a to včetně ukázek! Co je u takových projektů důležitější?\n\nMimochodem. PHP k tomuto má velmi blízko. Minimálně podle jejich dokumentačních \"slohokomentářů\". S tímto problémem také lehce souvisí verzování projektů o kterém bych se chtěl rozepsat jindy.\n\nTeď však zpět k myšlence. Jak moc je to hloupý nápad? Co je jeho překážkou? Proč by ho nešlo prakticky použít?',	'2014-02-03 21:50:55',	0),
(66,	'Kde se berou spamy?',	'kde-se-berou-spamy',	'<div class=\"alert alert-info\">Tento článek navazuje na článek \"Stáhněte si zdarma 897457 emailových adres\":http://www.zeminem.cz/stahnete-si-zdarma-897457-emailovych-adres z ledna tohoto roku. Přečtěte si jej prosím, ať víte o co jde.</div>\n\nRád bych tímto všechny čtenáře poprosil o pomoc. Ačkoliv na internetu vystupuji veřejně a nemám s tím problém, jsem velmi háklivý na to, když někdo neoprávněně zneužívá mé osobní informace. Někteří přijmou moji žádost a problém odstraní - viz nedávno zrušená kopie tohoto blogu. Někteří však dělají všechno proto, abych pokračoval v rituálním podpalování válečné sekery a proto jsem neskončil tam kde jsem v minulém článku přestal psát.\n\nTrnitá cesta plná překážek\n==========================\nJe již známá věc, že jistý web má nemalou zásluhu na šíření reklamních emailů křížem krážem. Vzhledem k tomu, že takové email dorazil i ke mě a vzhledem k tomu, že upoutal moji pozornost, začal jsem zbrojit. Při prvních pokusech jsem oťukával jejich systém abych zjistil o co jde. Zde jsem mimo jiné udělal mylný myšlenkový pochod a vše jsem svedl na někoho kdo s tím nemá nic společného. Každopádně po několika minutách jsem měl celkem jasno a udělal jsem velkou chybu. Popsal jsem bezpečnostní chybu reklamního systému na G+, na což někdo velmi rychle zareagoval a já jsem dostal na tento reklamní server ban. Doufám, že to byla jen náhoda...\n\nToto řešení mi přišlo poněkud směšné, a tak jsem do tohoto systému přes IP anonymizér šťoural stále více. V tuto chvíli jsem to prakticky zabalil, protože chyba byla tak nějak opravena. Systém již při odhlašování nezobrazoval emailovou adresu, takže již nešlo použít něco jako:\n\n/--code php\npreg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n\\--\n\nNa necelý měsíc jsem to pustil z hlavy až včera jsem si na tento web opět vzpomněl. Také jsem byl již na jiné IP adrese což se mi stává celkem často, takže jsem opět vyzkoušel to co před měsícem a světe div se, bezpečností chyba opět funguje. To mě rozproudilo ještě víc, takže jsem opět usedl k editoru a začal jsem psát program, abych si ověřil, že jsem nekecal:\n\n/--code php\n<?php\ntry {\n    $db = new PDO(\'mysql:dbname=emails;host=127.0.0.1\', \'root\', \'\');\n    $stmt = $db->prepare(\"INSERT INTO emails (url_id, email) VALUES (:url_id, :email)\n							ON DUPLICATE KEY UPDATE url_id= :url_id, email= :email\");\n	$stmt->bindParam(\':url_id\', $url_id);\n	$stmt->bindParam(\':email\', $email);\n\n	//1300486 - 2197943\n	for ($i=2197943; $i > 1300486; $i--) {\n		preg_match(\'#<b>(.+)</b>#\', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n		if (preg_match(\"#@#\", $match[1])) {\n			$url_id = $i;\n		    $email = $match[1];\n		    echo $i . \': \' . $email . \"\\n\";\n			$stmt->execute();\n		}\n	}\n\n} catch (PDOException $e) {\n    echo \'Connection failed: \' . $e->getMessage();\n}\n\\--\n\nNejsem žádný extra programátor, ale na takovou věc ani být nemusím. Je asi zřejmé, že by tento program trval poměrně dlouhou dobu. Nemá však smysl řešit nějaké paralelní zpracování, když se o to server při vhodně zvoleném programu postará sám. Napsal jsem tedy celkem tři velmi podobné programy. Jeden bral URL adresy od nízkého čísla, druhý od vysokého a třetí na obě strany od středu číselného intervalu. Právě je 17:00, dávám si něco k jídlu a vyrážím do města na hokej...\n\nJak to bylo dál?\n================\nPo tom co hokej nedopadl moc dobře, strávil jsem nějaký čas u piva a vrátil jsem se domů. Bylo pozdě a program pořád běžel. Šel jsem spát a ráno do školy. Program stále běžel. V tuto chvíli již 16 hodin. Odhadem až někdy po 20ti hodinách dolování emailových adres z tohoto serveru jsem opět dostal IP ban. V tu chvíli jsem měl však získáno více než čtvrt milionu unikátních emailových adres. Ono to funguje! **Zde bych měl říct, že jsem tyto emailové adresy nedoloval kvůli nějakému zneužití, maximálně z nich udělám nějakou statistiku**... (-: Chtěl jsem také napsat na email který mají vystavený na webu, to bohužel nefungovalo, protože tento email byl pravděpodobně zrušen.\n\nV tuto chvíli adresy stále zpracovávám, protože celý systém psal někdo moc \"šikovný\" a tak občas systém vrátil místo emailu *Invalid key!* a jindy zase mix náhodných speciálních znaků s čímž jsem nepočítal. Také já jsem byl šikovný, takže jsem sice v programu počítal s unique klíčem, ale v DB jsem ho neudělal a v reklamním systému je jich cca 10% duplicitních.\n\nŽádám tedy o pomoc. Víte komu patří emailová adresa `b2bdm@email.cz`? Komu patří `m-letter.eu`? Kdo zneužívá tak obrovské množství emailových adres? A kde je vůbec bere? Skutečně mě to zajímá, protože takto je to těžko představitelné, ale několik set tisíc adres je skutečně obrovské množství a já stále nevím, kde jsem se tam vzal...',	'2014-02-20 23:48:22',	0),
(67,	'Jaký email je nejvíce využívaný?',	'jaky-email-je-nejvice-vyuzivany',	'Včera jsem psal o bezpečnostní chybě, která umožňuje získat podle mého názoru nezanedbatelně velký vzorek emailových adres. Krom toho, že bych byl rád, aby byla tato chyba opravena, nemám co jiného s touto kolekcí adres dělat. Tak jsem se rozhodl vytvořit nějakou statistiku. Svým způsobem se totiž jedná o dosti specifické uživatele, protože se pravděpodobně jedná z naprosté většiny pouze o ČR a SK uživatele, takže kdo čeká, že bude např. gmail umístěn nějak dobře, možná bude překvapen.\r\n\r\nA protože po diskusích krouží mnoho rádoby matematiků, rád bych teď přesně definoval všechny vstupní a výstupní hodnoty včetně jejich chyb, čímž doufám minimalizuji to, že výsledky někdo špatně pochopí. Všechny data jsou brány z kolekce čítající **384 392 unikátních** emailových adres s tím, že uvažuji zejména u rozložení poskytovatelů emailových schránek chybu 1%. Je to dáno tím, že vstupní data nejsou úplně korektní a ukazuje se, že se dost často vyskytují emaily jako `@seznam.czsms`, `@seznam.cztel`, `@seznam.czwww`, `@seznam.czweb`, `@senam.cz` atd. Většinu takových prohřešků jsem se snažil eliminovat, každopádně není to dokonalé. Osobně bych chybu odhadoval na desetiny, možná ani ne setiny procenta, ale raději ji nechávám větší. Tato chyba je v prvním grafu také graficky znázorněna. Zajímavé je také to, že někteří lidé evidentně chápu input pro zadání emailu jako deník, takže jsou schopni napsat do tohoto řádku všechny své emailové adresy. Stojí za zamyšlení jak správně navrhovat formuláře... Dále jsou pak z výpočtů zastoupení četnosti znaků prvních písmen emailových adres vypuštěny čísla, takže tato dílčí statistika počítá s o něco menší vstupní kolekcí 382 338 emailových adres.\r\n\r\nRozložení poskytovatelů emailových schránek\r\n===========================================\r\nNásledující graf ukazuje počet emailových adres příslušejících ke konkrétní doméně. Konkrétně je zobrazeno prvních 20 největších poskytovatelů a i tak již mají poslední méně než jedno procento velikosti prvního, tedy Seznamu. Ten je v českém zastoupení naprosto bezkonkurenční. Všímejte si prosím takových věcí. Většina programátorů se totiž potkává pouze s lidma \"od gmailu\", ale to je na českém trhu pouze minoritní složka. A je to tak u všeho. Je až překvapivě obrovský nepoměr mezi tím co si většina lidí myslí a skutečností. A tento vzorek již považuji za dostatečnou skutečnost.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=744207493\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nKolikrát jsem slyšel, že jsou Centrum a Atlas mrtvé projekty. To už ani nemá smysl počítat, ale reálně se ukazuje, že tomu tak vůbec není a těmto číslům momentálně věřím, protože už je zde přehazuji několik desítek hodin... (-: Bohužel nemám představu o tom, kolik existuje emailových adres v ČR, ale veřím, že se tvarově graf moc nepohne. Pouze se bude měnit počet na svislé ose.\r\n\r\nDalší zajímavá data\r\n===================\r\nDalší graf ukazuje skutečně velkou hloupost. Ani nevím proč jsem jí vlastně dělal. Jde o početné zastoupení prvních znaků emailových adres. To jsou ty modré pruhy. Červené pruhy jsou pak předpokládaná četnost znaků pro českou abecedu podle \"Jana Králíka .{target:_blank}\":http://www.czech-language.cz/alphabet/alph-prehled.html. Není to poprvé co tuto tabulku četností používám a dá se říci, že s ní souhlasím. Každopádně mám v plánu tyto četnosti ověřit a zaktualizovat, takže se možná tento graf časem malinko pozmění.\r\n\r\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=1555577201\" seamless frameborder=0 scrolling=no></iframe>\r\n\r\nDalší informací, která již však nemá pevně uchopitelný základ je počet TLD. Lze tedy pouze říci, že ze vzorku zkoumaných dat, tedy ze vzorku emailových adres českých uživatelů mají největší zastoupení koncovky `.cz` (290311), poté `.sk` (88764) a další v pořadí je `.com` (5183), která se však svojí četností již poněkud mimo hru. Zajímavé teké je, že většinu překlepů dělají češi. To může být tím, že jsme prostě nepozorní, nebo jsou programátoři lajdáci. Tato informace je založena na počtu korekcí doménových názvů.\r\n\r\nPoslední již nikterak využitelnou informací je délka adres. Nejdelší adresy jsou `butovice.zlicine.tel.728222069.pouzite.kalhotky@...`, `www.malirstvi.tym.czemail.malirstvi.hruby@...` a `martin.59kenvelo400500600300700800900201@...` Zakrývám alespoň domény, aby někdo neprskal, když už proti tomu tak zbrojím. Naopak nejkratší je adresa, která má se vším všudy 8 znaků: `in@.....`.\r\n\r\nZajímá vás ještě nějaká informace, která se dá z této kolekce emailových adres získat?',	'2014-02-21 17:12:09',	0),
(68,	'Omyly hashování hesel',	'omyly-hashovani-hesel',	'Někdy minulý rok jsem si četl prezentaci \"Michala Špačka .{target:_blank}\":http://www.michalspacek.cz/ o \"hashování hesel .{target:_blank}\":http://www.slideshare.net/spaze/hashe-hesla-develcz-2013 a byl jsem z toho poněkud zklamán. Naprosto souhlasím se vším co tam je, přesto však nemám rád, když se dojde k závěrům, které sice na první pohled dávají smysl a fakt dobře se tak dá argumentovat, ale ve výsledku jsou podle mého názoru některé opravdu chybné. Nedávno kolem mě tato prezentace proplula znova a protože již mám celkem setříděné myšlenky, rozhodl jsem se je sepsat.\n\nTímto článkem nehodlám hatit již zmíněnou prezentaci. Naopak se chci opřít do všech prezentací a výstupů, které něco tvrdí a není to tak docela pravda. Zároveň je také nutno říct, že nebudu řešit funkce typu MD5, protože doufám, že všichni v dnešní době vědí, že funkce MD5 prostě není určena na hashování hesel. Přesto si neodpustím několik vět i o konkrétních implementačních problémech.\n\nOmyl první\n==========\nKdyž jsem se opět dožadoval matematického důkazu o problému cyklického hashování, byl jsem dokázán na \"stackoverflow .{target:_blank}\":http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/17396367#17396367, což mě mělo uspokojit. Četl jsem to pozdě v noci, takže jsem to nechal na ráno a ani tak jsem s tím nesouhlasil.\n\nV podstatě se jedná o popsání preimage útoku, který se snaží najít stejný hash jako je hash známý a tím získat původní (nebo jinou fungující) hodnotu hesla, tedy v tuto chvíli jediný zajímavý způsob. Celý důkaz toho, že cyklické hashování není dobrý nápad je prováděn na vlastní funkci a směšně malé množině vstupů. To je první divná věc. Mnohem divnější však je závěr pokusu, který tvrdí, že nekonečný vstup lze namapovat na konečnou množinu. Jedná se tedy o surjektivní zobrazení první množiny na druhou, kdy se každý prvek z první množiny namapuje na všechny prvky menší výstupní podmnožiny. A právě v tomto kroku vidím celou teoretickou úvahu jako chybnou. Žádná hashovací funkce totiž nepočítá s libovolným, nebo dokonce s nekonečným vstupem. Když to rozvedu i na konkrétní funkci MD5, pak nekonečný počet vstupů mapuji na 2^128 výstupů. Reálně (což je to co nás primárně zajímá) však mapuji 2^64 vstupů na 2^128 výstupů (čti bitů). V tu chvíli se však bavíme o injektivním zobrazení, což bylo v původním textu odsouzeno. Jak jsem k tomumo názoru došel? Vycházím z \"RFC 1321 - The MD5 Message-Digest Algorithm .{target:_blank}\":http://www.faqs.org/rfcs/rfc1321.html\n\n> A 64-bit representation of b (the length of the message before the\n> padding bits were added) is appended to the result of the previous\n> step. In the unlikely event that b is greater than 2^64, then only\n> the low-order 64 bits of b are used. (These bits are appended as two\n> 32-bit words and appended low-order word first in accordance with the\n> previous conventions.)\n\nPak už je jen malý krůček k tomu uvědomit si, že 2^64 bitové heslo je jinak řečeno něco kolem 2 exabajtů, což je tak trošku hodně i na uložení, natož na zapamatování. A i kdybych to spočetl blbě - jakože doufám, že ne - několik řádů sem tam je úplně jedno, protože množina na kterou se to mapuje je daleko větší. Stejně tak mi přijde naprosto komická tato ukázka:\n\n/--code\n$output = md5($input); // 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n\\--\n\nPřepíšu to jinak:\n\n/--code\n$output = md5($input); // 340282366920938463463374607431768211456 possibilities\n$output = md5($output); // 340282366920938463463374607431768211455 possibilities\n$output = md5($output); // 340282366920938463463374607431768211454 possibilities\n$output = md5($output); // 340282366920938463463374607431768211453 possibilities\n$output = md5($output); // 340282366920938463463374607431768211452 possibilities\n\\--\n\nVycházíme tedy z 340 undecilionů 282 decilionů 366 nonilionů 920 octilionů 938 septilionů 463 sextilionů 463 quintilionů 374 quadrilionů 607 trilionů 431 bilionů 768 milionů 211 tisíc 456 možností. Jasné? Tuto teorii tedy považuji za čistě teoretickou. Klidně si to heslo zašifrujte undecilionkrát... Ostatně stejný problém byl při šifrování vždy. Klidně se mohlo stát, že klíč od zprávy zašifrované v Enigmě (nebo kdekoliv jinde) uhodnou. Ale nedělalo se to, protože je to prostě jen papírový nesmysl. Ostatně i když se to stane, tak je to prostě debilní smůla, jenže věří snad ještě někdo tomu, že se to stane u celé databáze?\n\nOmyl druhý\n==========\nNyní budu předpokládat, že bude nyní mým cílem zjistit skutečně takové heslo, jaké bylo před zahashováním. Úplně tím tedy odbourám fakt, že dva různé texty budou mít stejný hash. To se může stát, druhá možnost však bude svým charakterem tak úplně jinde, že ji stejně nepůjde např. při přihlašování použít. Pokud tedy chci zjistit heslo z hashe u kterého vím, že bylo několikrát hashováno, nezbývá mi, než jít postupně z hashe až k heslu:\n\n/--code\n7eaefb28c9c3fe4be6997cc5b7fb599f // původní hash\n92b7db0f6d7348d91e90651d31ff9e71\n651a9c9c86f3116a53e2bb6e80bfdf69\n1b929b62a2c822c4a59e688fde2a3a0b\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nJenže jaké teď skutečné heslo? Je to \"heslo\"? Pokud bych byl chytrý a uměl si zapamatovat 32 znaků, moje heslo by určitě bylo \"1b929b62a2c822c4a59e688fde2a3a0b\" a jen bych zmátl všechny okolo. A potom je celkem sranda to, když se vrátíme k čistě teoretickému uvažování a řekněme, že se může stát, že dva hashe budou totožné:\n\n/--code\n1b929b62a2c822c4a59e688fde2a3a0b // původní hash   <-\n... // dlouhá série hashů vedoucích k opakování     |\n651a9c9c86f3116a53e2bb6e80bfdf69                    |-- stejné hashe\n1b929b62a2c822c4a59e688fde2a3a0b   <-----------------\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n\\--\n\nVěřte, že mé heslo je teď \"651a9c9c86f3116a53e2bb6e80bfdf69\". Při pokusu o zjištění původu hashe mám dvě možnosti. Mohu najít takový hash, který je před tím prvním, ale jiný než \"955db0b81ef1989b4a4dfeae8061a9a6\", nebo právě \"955db0b81ef1989b4a4dfeae8061a9a6\". V prvním případě je to stejné jako předchozí případ. V druhém však naleznu nejdříve jinou shodu a nejen že dojdu k jinému heslu, ale také úplně přeskočím to správné heslo. Takže v určitém případě může být opakované hashování dokonce ještě bezpečnější! Opět je to pouze teorie, ale chci tím ukázat, že některé argumenty mohou být sice silné, mají však vždy i obrácenou stranu, která není o nic slabší...\n\nChtěl jsem tedy vyvrátit několik zažitých předpokladů, což se mi doufám podařilo. Musím však dodat nesmírně důležitou věc. Neobhajuji zde použití MD5 ani jiné podobné funkce (která tak jako MD5 není k hashování hesel určena). Používejte spíše funkce, které mají složitou výpočetní náročnost a jejich výstup je pro dva stejné vstupy různý. Takovou dobrou funkcí je pro PHP funcke `password_hash`, která byla vytvořena právě kvůli tomu, že v tom programátoři dělají neskutečný bordel. Použití je úplně jednoduché:\n\n/--code php\n<?php\necho password_hash(\'heslo\', PASSWORD_DEFAULT);\n\\--\n\nTato funkce momentálně používá bcrypt, do budoucna je možné použít konstantu PASSWORD_BCRYPT, protože defaultní konstanta může způsob šifrování změnit na nějaký lepší. Stejně jednoduché je i ověření hesla:\n\n/--code php\nif (password_verify(\'heslo\', \'$2y$10$2YOiYB9vFd11vTRBtqqKE.TnrT1ydXuCGsSHXbAKRvUgnpE9VaoES\')) {\n    echo \'Password is valid!\';\n} else {\n    echo \'Invalid password.\';\n}\n\\--\n\nTyto funkce, stejně tak jako dobře použitý kompatibilní `crypt` považuji za naprosto dostatečná řešení a víc se o tom není třeba již <s>nikdy</s> bavit. Tečka.\n\n<span style=\"color:green\">A pod tečkou ještě něco. Čím musím napravit nešťastně volená slova v předchozí větě. Tím že se o tom není již třeba nikdy bavit je myšleno to o čem se ve větě píše, tedy že bcrypt funkce považuji za naprosto dostatečné (v současné době i blízké budoucnosti) a za tím si stojím. Neznamená to však, že teď házím za hlavu celou tuto problematiku. Pokud bych měl tedy předchozí větu opravit, napsal bych asi, že tyto funkce považuji za naprosto dostatečné, nicméně stále má smysl tuto problematiku řešit, protože věřím, že v zřejmě ne malém horizontu let bude i tato funkce nedostatečná. Teď ale není.</span>',	'2014-02-22 14:02:31',	0),
(69,	'Čteme QR kódy bez čtečky',	'cteme-qr-kody-bez-ctecky',	'[* 2139a61c-efc4-4e3c-b630-5c3cbf9258df/qrcode-ahoj.png 200x200 <]\n\nPatříte mezi lidi, kteří se nespokojí pouze se čtečkou QR kódů, ale chcete vědět jak fungují? Nebo co víc jak je přečíst bez použité takové čtečky? Tak to jste na správné adrese. Dnes budu řešit zejména právě čtení QR kódu bez použití čtečky. Celou dobu budu řešit tento QR kód na levé straně, takže doporučuji nepoužívat telefon a počkat až na konec, kde se jeho obsah dozvíte. Zároveň se nebudu nijak opírat o korekci chyb a další jinak důležité věci, ale budu se co nejvíce soustředit právě na přečtení kódu bez použití jakéhokoliv přístroje. Pojďme na to...\n\nTrocha nezbytné teorie\n======================\n[* 312d5904-ab94-4877-9743-8ec902fbc50a/qrcode-parts.png <]\n\nQR kód asi viděl každý. Stejně tak předpokládám, že spoustu lidí tuší, že QR kód dodržuji určitá pravidla, aby jej šlo přečíst strojově. Jedná se zejména o \"finder pattern\", tedy ty velké čtverce, které slouží k zaměření čtečky a určení orientace kódu. Díky tomu, že jsou tři, tak lze QR kód přečíst i pokud je vzhůru nohama. Dalším významným prvkem jsou separátory, které obklopují právě tyto čtverce a slouží k oddělení zaměřovačů od zbytku kódu. Žlutě jsem zvýraznil tzv. \"timing patterns\". Ty se táhnout z rohu do rohu zaměřovacích čtverců, kdy se celou dobu střídá černá a bílá barva a slouží opět pro čtečky například k určení velikosti celého kódu. Na takto malém kódu nejsou žádní informace i verzi, ani korekční body.\n\nNejdůležitější jsou však červené a zelené části. Zde jsou uloženy informace i formátu, které následně také využijeme. Je zajímavé, že se jak červená část, tak zelená část na kódu vždy dvakrát opakuje. Informace je očíslována čísly 1-15 s tím, že kolem levého horního zaměřovače je informace celá a ta samá informace je ještě rozdělena a umístěna kolem zbylých dvou zaměřovačů. Je zde ještě jedna zajímavost. V levém dolním rohu nad číslem 9 je černé místo, tzv. \"dark module\". Toto místo by mělo být na všech kódech černé. Jedná se přebytečné místo, které vzniká při zdvojování informace o formátu. Podle specifikace by to tak mělo být, ale ne vždy to platí. Pro nás je však zajímavá jediná část z celé 15 bitů dlouhé informace a to konkrétně bity umístněné na pozici 11, 12 a 13, tedy v zelené části. Právě ty si nesou tu nejdůležitější informaci o masce. Všechny ostatní části informace slouží ke korekci chyb. Celkově se ve výsledku ukáže, že kromě samotné informace je v QR kódu sloustu \"zbytečných\" věcí, které informaci nenesou. V mašem případě je tedy maska `111` (černé místo je 1 a bílé 0). Tuto informaci je však ještě potřeba dekódovat pomocí XOR součtu přičtením hodnoty `101`, tedy:\n\n/--code\n111\n101 /XOR\n---\n010\n\\--\n\nCelá dekódovací maska je `101010000010010`, ale pro naší potřebu je potřeba pouze část `101`. Ještě než vysvětlím co to maska je, uvedu zde všechny hodnoty jaké může maska mít:\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr><td>Hodnota masky</td><td>Podmínka masky</td></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>000</td>\n      <td>(i + j) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>001</td>\n      <td>i mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>**010**</td>\n      <td>**j mod 3 = 0**</td>\n    </tr>\n    <tr>\n      <td>011</td>\n      <td>(i + j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>100</td>\n      <td>((i div 2) + (j div 3)) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>101</td>\n      <td>(i j) mod 2 + (i j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>110</td>\n      <td>((i j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>111</td>\n      <td>((i+j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n  </tbody>\n</table>\n\nTo může vypadat děsivě, ale hned vysvětlím. Podle toho jakou má kód masku vezmeme vzorec a dosadíme za **j** číslo sloupce. V našem případě se tedy bavíme o prvním a pak každém třetím sloupci. Pro tyto sloupce platí, že na nich musíme provést negaci, tedy otočit barvy. Tím QR kód odmaskujeme. Toto však platí pouze pro částí kde je opravdu nějaká informace, nikoliv pro zaměřovače, nebo například části nesoucí formátovací informaci. Toto maskování slouží k zamíchání barevných polí. Nestane se tak, že by byl kód nejednoznačný. Při kódování se totiž porovnávají jednotlivé masky, každá maska má nějaké skóré jednoznačnosti a ve výsledku se vybere ta nejjednoznačnější. Celé odmaskování je znázorněno na obrázku níže. Pravý černý QR kód je již odmaskovaný a nic nebrání jej přečíst. V tuto chvíli však již pouze bez použití čtečky.\n\n[* 63e85abb-b86a-4877-9640-fb70b4cd2542/qrcode-important.png 300x300 <]\n[* 3951a3ea-5f53-4af9-9c01-a45fd71dd5b0/qrcode-unmasked.png 300x300 *]\n\nHrajeme si na čtečku\n====================\n[* 0ed74ba7-ddec-40da-ab12-4e6b8d82103c/qrcode-decode.png <]\n\nPředchozí část byla možná trošku složitější, ale když se na to podíváte zpětně je to vlastně velice jednoduché. Stačí přečíst 3 bity z celého kódu, provést jednoduchý XOR a jak se ukáže dále, tak stačí invertovat pouze jeden sloupec, protože více jich není potřeba.\n\nPodívejte se nyní na levý obrázek. Ten ukazuje, jak budeme číst uloženou informaci. Barevně znázorněná část je kompletní informace. Zbytek kódu je pro nás v tuto chvíli jen odpad. Barevně zvýrazněná část se ještě dělí na tři podčásti. Červená oblast obsahuje informaci o módu. Bity čteme vždy podle čísel a šipek. Tento QR kód je tedy v módu `0100` což je mód \"BYTE\". Data tedy budeme rozdělovat tak, aby měla každý část 1 byte, tedy 8 bitů. Tyto módy a další informace jsou velmi podrobně popsány v oficiální dokumentaci. Modrá část nám ještě prozrazuje informaci o délce, binárně tedy `00000100` což je v desítkové soustavě číslo 4. Takže informace v tomto QR kódu má délku 4 znaky. Opíšeme si tedy řadu bitů:\n\n/--code\n01100001 01101000 01101111 01101010\n\\--\n\nZde by mohl být trošku zádrhel pro lidi, co neumí ASCII tabulku. Prozradím tedy malý fígl. Pokud binární čásla prevedeme do decimální soustavy, což je velmi jednoduché, získáme následující zápis:\n\n/--code\n97 104 111 106\n\\--\n\nA teď už je to jen posunutá abeceda, protože číslo 97 je malé **a**. Výsledkem je tedy po chvilce abecedování:\n\n/--code\na h o j\n\\--\n\nTo nebylo tak těžké, že? Je to sice absurdní a pravděpodobně nikdy nikoho neuvidím s tužkou a papírem před QR kódem, ale i tak si myslím, že je dobré tyto věci vědět, když už se QR kód používá tak často. Doporučuji všem přečíst si dokument *ISO/IEC 18004:2006*, který řeší právě QR kódy. Je to nesmírně zajímavý dokument plný obrázků a úplných popisků, ačkoliv je i v tomto dokumentu pár drobných chyb.',	'2014-02-28 12:49:05',	0),
(70,	'AJAX upload souborů v Nette pomocí Fine Uploaderu #2',	'ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2',	'\"Dříve\":http://www.zeminem.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu jsem psal o tom, jak použít Fine Uploader jakožto nástroj pro AJAXové nahrávání souborů na server. Původní článek však platí pouze pro verzi `3.*`, která je dnes již zastaralá. Pojďme si dnes ukázat v podstatě to samé, ale pro novější verzi `4.3+`, která se v učitých směrech poměrně zásadně liší od svého předchůdce. Tentokrát se to však pokusím vyřešit co nejjednodušeji.\n\nZačátek je vlastně úplně stejný. Musíme nalinkovat javascriptové soubory:\n\n/--code html\n<!-- jQuery -->\n<script src=\"{$basePath}/js/jquery.fineuploader-4.3.1.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n\\--\n\nPoužití je úplně jednoduché, ve zjednodušené formě:\n\n/--code html\n<div id=\"image-uploader\"></div>\n\\--\n\nSnažím se ukázat opravdu jen kritické minimum, protože ty základní věci jsou stejné, případně dohledatelné v dokumentaci, takže se dají oba dva návody z velké části doplnit. Minule jsem však zatáhl do ukázek i poměrně hodně balastu, takže ten u staré verze nechám, ale bude následovat opravdu jen to nejnutnější.\n\nStejně tedy jako v předchozí verzi následuje javascriptový spouštěcí kód. Zde již vznikají určité odlišnosti:\n\n/--code javascript\n$(function () {\n	$(\'#image-uploader\').fineUploader({\n		debug: true, //hodí se pro lazení\n		request: {\n			endpoint: \'pictures?do=uploadPicture\'\n		},\n		retry: {\n			enableAuto: true\n		}\n	});\n});\n\\--\n\nPoužití je tedy téměř stejné, až na to, že jsem úplně vypustil překlad textů. V této nové verzi jsou totiž novinkou šablony (ostatně proto také nové číslo verze). Uživatel-programátor má tak více pod kontrolou výsledný vzhled uploaderu:\n\n/--code html\n<script type=\"text/template\" id=\"qq-template\">\n	<div class=\"qq-uploader-selector qq-uploader\">\n		<div class=\"qq-upload-drop-area-selector qq-upload-drop-area\" qq-hide-dropzone>\n			<span>Přetáhněte soubory sem</span>\n		</div>\n		<div class=\"qq-upload-button-selector qq-upload-button\">\n			<div>Klikněte, nebo přetáhněte obrázky</div>\n		</div>\n        <span class=\"qq-drop-processing-selector qq-drop-processing\">\n           <span>Zpracovávám přetažené soubory...</span>\n           <span class=\"qq-drop-processing-spinner-selector qq-drop-processing-spinner\"></span>\n        </span>\n		<ul class=\"qq-upload-list-selector qq-upload-list\">\n			<li>\n				<div class=\"qq-progress-bar-container-selector\">\n					<div class=\"qq-progress-bar-selector qq-progress-bar\"></div>\n				</div>\n				<span class=\"qq-upload-spinner-selector qq-upload-spinner\"></span>\n				<img class=\"qq-thumbnail-selector\" qq-max-size=\"100\" qq-server-scale>\n				<span class=\"qq-edit-filename-icon-selector qq-edit-filename-icon\"></span>\n				<span class=\"qq-upload-file-selector qq-upload-file\"></span>\n				<input class=\"qq-edit-filename-selector qq-edit-filename\" tabindex=\"0\" type=\"text\">\n				<span class=\"qq-upload-size-selector qq-upload-size\"></span>\n				<a class=\"qq-upload-cancel-selector qq-upload-cancel\" href=\"#\">Zrušit</a>\n				<a class=\"qq-upload-retry-selector qq-upload-retry\" href=\"#\">Opakovat</a>\n				<a class=\"qq-upload-delete-selector qq-upload-delete\" href=\"#\">Smazat</a>\n				<span class=\"qq-upload-status-text-selector qq-upload-status-text\"></span>\n			</li>\n		</ul>\n	</div>\n</script>\n\\--\n\nA opět následuje zpracování v handleru:\n\n/--code php\npublic function handleUploadPicture() {\n	$uploader = new \\UploadHandler();\n	$uploader->allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\");\n	$result = $uploader->handleUpload(__DIR__ . \'/../../www/uploads\');\n	$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse($result));\n}\n\\--\n\nZde celkem není co pokazit, ale pokud by bylo potřeba vrátit chybu, provede se to opět pomocí `JsonResponse`:\n\n/--code php\n$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse(array(\n		\'error\' => $exc->getMessage(),\n)));\n\\--\n\nSamotná třída `UploadHandler` je pak opět k nalezení na \"GitHubu\":https://github.com/Widen/fine-uploader-server/blob/master/php/traditional/handler.php. Tento návod tedy mohu zakončit vlastní citací:\n\n> A to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například podle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit. To konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2014-03-03 21:15:13',	0),
(71,	'Sbohem NDBT, vítej Doctrine',	'sbohem-ndbt-vitej-doctrine',	'Byl jsem požádán, abych napsal nejenom důvod přechodu z Nette Database na Doctrine, ale obecně co mě k tomu vedlo a jak takový přechod vlastně učinit. Na úvod bych však chtěl zdůraznit, že nejsem žádný extra programátor, vlastně to ani nestuduji, takže vše co budu ukazovat a vysvětlovat je tedy z mého pohledu a lecjakého OOP znalce by tento text mohl pobouřit... (-:\n\nNásledující text používá \"Kdyby\\Doctrine\":https://github.com/Kdyby/Doctrine, nevidím důvod proč ve spojení s Nette používat něco jiného. Je to dobrá knihovna.\n\nSbohem NDBT\n===========\nNette Database Table a obecně celé Nette Database je úžasná část frameworku a spokojeně jsem ji používal po velmi dlouhou dobu. Nikdy jsem neholdoval pokřikům, že je NDBT zabugované (jako někteří) a i když jsem vyzkoušel i jiné alternativy, vždy jsem se spokojeně vracel právě k NDBT. Použití je velice intuitivní a dobře se s tím zachází:\n\nModel:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Nette\\Database\\Context */\n	private $database;\n\n	public function __construct(Nette\\Database\\Context $context) {\n		$this->database = $context;\n	}\n\n	public function getAllPosts() {\n		return $this->database->table(\'posts\')->where(\'release_date < NOW()\');\n	}\n\n}\n\\--\n\nPresenter:\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$this->template->posts = $this->posts->getAllPosts();\n	}\n\n}\n\\--\n\nJe to jednoduché a jasné. Takové věci mám prostě rád. V modelové třídě mám jak select metody, tak insert metody, takže bych tomu správně neměl říkat repository, ale abych byl upřímný, tak je mi toto názvosloví celkem volné. Do takové objektu si prostě dám to co chci (tak jak mi to dává smysl). Nepřijde mi to vůbec podstatné. Tahání dat z databáze má však ještě jednu vrstvu a tou je vykreslování.\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->related(\'posts_tags\')->order(\'tag_id ASC\') as $post_tag}\n			<a n:href=\"Tag:default, $post_tag->tag->name\">\n				<span style=\"background: #{$post_tag->tag->color}\">{$post_tag->tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nA to je věc, která mě dlouhou dobu trápila. Dá se čekat, že když v databázi existuje jakási vazba mezi příspěvkem a tagem, tak že tuto vazbu budu chtít nějak využít. A to pokud možno co nejvíce pohodlně. A co nejvíce pohodlně znamená, že v okamžik, kdy budu pracovat s příspěvkem a vzpomenu si, že potřebuji také tagy, tak tyto tagy také dostanu. Bohužel musím znát také spojovací tabulku, která nemá (minimálně v tomto případě) žádný faktický smysl a celkově práce s takto \"dopřivázanou\" tabulkou není vůbec pohodlná a už vůbec ne intuitivní. Dává to smysl a asi to tak být musí, takže proti NDBT žádná, ale tak nějak vnitřně jsem hledal něco lepšího (čti více vyhovujícího mým požadavkům).\n\nVítej Doctrine\n==============\nSchválně se snažím vše popisovat podle mých myšlenkových pochodů, proto i nadále budu řešit úplně ten samý problém, jen s použitím Doctrine. Nutno ještě dodat, že Doctrine rozhodně nebyla jasná volba. Opět mi dlouho trvalo, než jsem obecně ORM přišel na chuť. Ještě před Doctrine jsem nějakou dobu experimentoval s \"Lean Mapperem\":http://www.leanmapper.com/ od Vojtěcha Kohouta (Tharos). Malou nevýhodou je, že téměř veškerá dokumentace je v brutálně dlouhém vláknu na Nette fóru, které má v tuto chvíli **1023 příspěvků**, takže je to občas dřina, ale myslím si, že je to skutečně povedená knihovna. Vojtěch Kohout má skutečně dobré myšlenky. Nicméně jsem prostě chtěl přijít Doctrine na chuť, takže jsem i Lean Mapper opustil. Občas dělám radikální změny, pokud by však někdo vyloženě potřeboval důvod k tomu začít s Doctrine (alespoň dočasně), pak tedy jeden mohu nabídnout. A bude velmi krátký. Vidíte někdy jako požadavek na zaměstnance znalost Lean Mapperu, nebo ActiveRow? Pokud ne, tak začněte s tím co se tam ukazuje často. Doctrine.\n\nAle zpět k tématu. Pojďme si ukázat modelovou část podle mě:\n/--code php\nclass Posts extends Nette\\Object {\n\n	/** @var \\Kdyby\\Doctrine\\EntityDao */\n	private $dao;\n\n	public function __construct(Kdyby\\Doctrine\\EntityDao $dao) {\n		$this->dao = $dao;\n	}\n\n	public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {\n		return $this->dao->findBy($criteria, $orderBy, $limit, $offset);\n	}\n\n}\n\\--\n\nVelmi podobné jako u předchozího modelu. Asi by šlo si napsat nějakou `__call` metodu, protože se dost často volá to co už je v DAO objektu (viz níže), ale kdo si to jak poslepuje, tak to bude mít... A co prezentační vrstva?\n/--code php\nclass HomepagePresenter extends BasePresenter {\n\n	/** @var \\Posts @inject */\n	public $posts;\n\n	public function renderDefault() {\n		$posts = $this->posts->findBy(array());\n	}\n\n}\n\\--\n\nTo je také dost podobné. Pole kritérií potom slouží k dodatečnému filtrování ve tvaru např. `[\'id\' => 21]`, tedy předává se to, co se má použít i v SQL WHERE klauzuli. Tento zápis je mi poměrně blízký, protože jsem ho používal při komunikaci s jedním SOAP serverem. Ok, co na to šablona?\n\n/--code html\n{foreach $posts as $post}\n	<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n	<p>\n		{foreach $post->tags as $tag}\n			<a n:href=\"Search:default, $tag->name\">\n				<span style=\"background: #{$tag->color}\">{$tag->name}</span>\n			</a>\n		{/foreach}\n		{$post->body|truncate:450}\n	</p>\n{/foreach}\n\\--\n\nTak to je podle mě úplně super výsledek. Maximálně intuitivní a nic víc splňuje to má očekávání. Je však asi zřejmé, že jsem úplně vypustil jakoukoliv informaci o spojovací tabulce. A také jsem ještě neřekl, co je to `EntityDao`, se kterým se pracuje v modelu. Vlastně je to úplně jednoduché. V konfiguračním souboru definuji, že chci pracovat s jakýmsi DAO objektem, tedy objektem, který oproti repository umožňuje data nejen číst, ale také ukládat (opět pouze OOP slovíčkaření).\n\n/--code neon\nservices:\n	- App\\Pictures(@doctrine.dao(Entity\\Picture))\n	- App\\Posts(@doctrine.dao(Entity\\Post))\n	- App\\Tags(@doctrine.dao(Entity\\Tag))\n	- App\\Users(@doctrine.dao(Entity\\User))\n\\--\n\nFajn, teď mám tedy v každé modelové třídě DAO objekt. Ten obsahuje několik metod, které výrazně usnadňují práci s Doctrine (\"source\":https://github.com/Kdyby/Doctrine/blob/master/src/Kdyby/Doctrine/EntityDao.php). Do tohoto objektu předávám jakousi entitu. To je objekt, který reprezentuje strukturu databázové tabulky. To možná není napsáno úplně šťastně, ale prakticky to tak skutečně většinou je. Taková entita může vypadat například takto:\n\n/--code php\nnamespace Entity;\n\n/**\n * @ORM\\Entity\n * @ORM\\Table(name=\"posts\")\n */\nclass Post extends Doctrine\\Entities\\BaseEntity {\n\n	/**\n	 * @ORM\\ManyToMany(targetEntity=\"Tag\", inversedBy=\"posts\", cascade={\"persist\"})\n	 * @ORM\\JoinTable(name=\"posts_tags\")\n	 * @ORM\\OrderBy({\"name\" = \"ASC\"})\n	 */\n	protected $tags;\n\n	/**\n	 * @ORM\\Id\n	 * @ORM\\Column(type=\"integer\")\n	 * @ORM\\GeneratedValue\n	 */\n	protected $id;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $title;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $slug;\n\n	/** @ORM\\Column(type=\"text\") */\n	protected $body;\n\n	/** @ORM\\Column(type=\"datetime\") */\n	protected $date;\n\n}\n\\--\n\nZde je právě důležité to, že rovnou ukazuji, kde je entita reprezentující tagy (která vypadá podobně jako tato), jak se k ní dostanu a dokonce jak se má řadit. Tedy všechny tyto informace jsem ze šablony odstranil. Pro mě je to tedy úžasný pokrok, protože jsem dosáhl toho co jsem chtěl. Aby se mi s databází pracovalo dobře.\n\nNo dobře, ale...\n================\nA teď je právě čas na některé dotazy, které vznikly při přípravě tohoto článku. Tak například co když chceš položit vlastní dotaz, v Nette Database je to přeci snadné. V Doctrine \"také\":https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/Posts.php?at=master#cl-128. V tom by ORM nemělo nijak zásadně bránit...\n\nDalší věc je, že v presenteru stále zůstává jistá závislost na struktuře tabulek. Konkrétně opět mluvím o poli kritérií. Jak se úplně zbavit této závislosti a mít pokud možno vše tak, aby když změním strukturu, tak to změním jen někde a ne všude? K tomu se dají použít třeba query objekty, které v sobě drží podobu potřebného SQL dotazu, takže místo toho, abych stále ťukal ten samý dotaz, jen jinde, tak jej schovám do třídy a právě tu pak používám. Budoucí změna se pak pravděpodobně bude týkat právě pouze toho objektu a případně entit. Ono toto asi nejde úplně odstínit (nebo spíš nevím jak), protože vždy je potřeba data i nahrávat a tedy stanovit určitou hranici mezi tím co je závislé na databázi a co už není. Nicméně uvážím-li, že budu měnit strukturu tabulky třeba kvůli tomu, že chci přidat nová data, stejně budu do kódu muset jít a někde ty data vzít a někam je dát. Proto je toto možná úplně zbytečné řešit, protože tato závislost nikdy nepůjde úplně odstranit.\n\nDalší věc je trošku záludná. Týká se tříd pro vazební tabulky. Pokud tedy ukládám M:N vazbu jako v předchozím textu, tím myslím, že mi jde pouze o to, že chci uložit do této tabulky cizí klíče, tak se o nic nemusím starat a stačí mi pouze onen dokumentační komentář v entitě `Post` nad proměnnou `protected $tags`, kde je definováno vše potřebné. Problémové je, když chci uložit data i do vazební tabulky. Zde bych rád citoval jeden příspěvek ze StackOverflow, protože si myslím, že tam je vše řečeno naprosto přesně.\n\n> A Many-To-Many association with additional values is not a Many-To-Many, but is indeed a new entity, since it now has an identifier (the two relations to the connected entities) and values.\n\nA přesně takto je s tím tedy potřeba zacházet. Už se nebavíme o vazební tabulce. Už se bavíme o normální tabulce, která vyžaduje svoji entitu a pouze obsahuje dva cizí klíče místo běžného jednoho.\n\nDoufám, že se mi v tomto článku svojí délkou limitně blížící se k nekonečnu podařilo zodpovědět všechny dotazy a objasnit všechny pochybnosti. Pokud ne, můžete se na celou problematiku podívat pod drobnohledem ještě \"zde\":https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/?at=master. Máte na celou problematiku jiný názor, nebo to jak to dělám já je kompletně špatně? Sem s tím... (-:',	'2014-03-11 19:34:00',	0),
(72,	'Orion login stojí za prd',	'orion-login-stoji-za-prd',	'Když jsem dříve připravoval \"prezentaci o Nette Frameworku\":http://www.zeminem.cz/prednaska-z-nette-na-zcu, hledal jsem nějaký vhodný příklad, na kterém bych demonstroval zranitelnost webových aplikací. Úspešně jsem vyzkoušel pár eshopů a jednu stránku, která slouží ke školním účelům, ale není nijak oficiálně vedená pod univerzitou. Právě zde mě napadlo vyzkoušet také univerzitní systémy. A nestačil jsem se divit.\n\nPozadí univerzitního přihlašování\n=================================\nVeškeré ověřování práv a identit putuje přes WebKDC server. Tento server komunikuje s Kerberosem a dohromady tvoří systém, který umožní přihlášení pomocí univerzitních loginů. Celkově proti tomuto systému nemám vůbec nic. Mám však hodně výhrad k jeho konkrétní implementaci. Konkrétní web servery (tam kde jsou umístěny aplikace vyžadující přihlášení) komunikují se vzdáleným WebKDC serverem. Tento server zajistí korektní ověření uživatele (spolupráce s Kerberos) a vráti informaci o úspěšném ověření. Paráda. Vnitřně velmi sofistikovaný systém funguje a umožňuje SSO (Single Sign-On) napříč celou infrastrukturou. Platí to tedy i pro aplikace mimo univerzitní doménu. Zjednodušeně popsáno, ale tématem tohoto článku není ta část, která \"spolehlivě funguje\":http://webauth.stanford.edu/, ale ta část, která nefunguje.\n\n/--code\n WEBKDC <----------> KERBEROS\n   |||\n   |||\n WEBAUTH (server s aplikací vyžadující přihlášení)\n    |\n    |\n STUDENT\n\\--\n\nJako poměrně zásadní fakt vidím to, že dokud student neklikne na \"LOGIN\", tak ho tento systém nepřihlásí (většinou). Nachází se tedy na úrovni \"WEBAUTH\", ale vidí jen omezenou stránku. Jakmile se chce přihlásit, aplikace jej přesměruje na WebKDC login-server, kde může vyplnit své přihlašovací informace, nebo je již přihlášen někdy z dřívější doby a v obou případech je přesměrován zpět na server s webovou aplikací. Už vidíte ten problém? :-)\n\nXSS\" onclick=\"alert(document.cookie); //:-)\n===========================================\nPrávě komunikace mezi WEBAUTH a WEBKDC je pro ověření naprosto zásadní, ale díky tomu, že zřejmě není nastavena žádná implementační laťka, tzn. že kdokoliv chce přihlašovat pomocí tohoto systému tak si to prostě nějak naprogramuje, vznikají bezpečnostní bublinky. Pravděpodobně neexistuje žádná konvence jak tento systém implementovat, takže neexistují ani takové funkce, jako je třeba ověřování již aktivního přihlášení atd. Může se tedy stát, že budu přihlášen (ověřen) ve webové aplikaci, ale na WEBKDC jsem odhlášen, protože WEBAUTH už se o to v tuto chvíli nestará (ten je přihlášen).\n\nDíky tomuto poznatku mohu velmi jednoduše vše co jsem teď napsal zapomenout, protože se dá celé složité schéma zjednodušit na toto:\n\n/--code\n WEBAUTH                   WEB-APP\n    |          resp.          |\n    |                         |\n STUDENT                   STUDENT\n\\--\n\nTak moment. Není to úplně normální přihlášení tak jako je na jakékoliv jiné úplně obyčejné stránce? Uživatel (student, profesor, administrátor) je přihlášen a teď už je to pouze nudná otrocká práce. Myslím, že mohu prozradit, že je stránka (čti univerzitní projekty) náchylná na session hijacking, na to přijde každý blbec, který o tom četl na wiki. A asi nemá smysl tajit, že XSS je naprosto reálná (a vyzkoušená) hrozba. Nebudu však říkat kde. A vzhledem k tomu, že tento systém webových portálů (IBM Web-Sphere Portal) není žádná domácí výroba, tak předpokládám, že stejný problém budou mít i další univerzity.\n\n/--code\n WEB-APP1     WEB-APP2\n    |            |\n    |----------EVA\n STUDENT\n\\--\n\nOd první chvíle, kdy jsem na tento problém upozorňoval poprvé jsou některé věci v současné době na serverech pozměněny, ale to zásadní zůstává pořád stejné. Nezáleží na tom co je v pozadí, když je řetěz tak silný, jak je silný jeho nejslabší článek a zvlášť, když ten silný zbytek řetězu skoro ani není potřeba...',	'2014-03-16 17:00:29',	0),
(73,	'Plzeňský Barcamp - láska na první pohled',	'plzensky-barcamp-laska-na-prvni-pohled',	'Ačkoliv jsem z dřívějších barcampů sledoval záznamy, tak jsem byl fakticky na barcampu úplně poprvé a rovnou jsem měl tu čest přednášet. Než se však dostanu k samotné přednášce, rád bych zde napsal nějaký feedback. Celkově jsem z Plzeňského Barcampu skutečně nadšen. Skvělá atmosféra, fajn lidi, spoustu jídla, alkoholu možná až moc... :-))\n\nNa druhou stranu došlo i k pár přešlapům. Některé mě mrzí více, jiné ani tak ne, každopádně... Skutečně mě mrzí to, že nebyla nahrávána na video každá přednáška.\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/eshopkonzultant\">@eshopkonzultant</a> Honzo, máme to v plánu. Pokud nám ho nic nenaruší, chtěli bychom určitě záznamy dodat nejdéle do měsíce po skončení akce.</p>&mdash; Plzeňský Barcamp (@PlzenskyBarcamp) <a href=\"https://twitter.com/PlzenskyBarcamp/statuses/454275681665687552\">April 10, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nTo se moc nepovedlo. Mrzí mě to ze dvou důvodů. Jednak jsem tak nějak slíbil, že má přednáška bude potom na netu, to však není ten závažnější problém. Daleko více mě mrzí fakt, že se teď nemohu podívat na přednášky ostatních protože jsem byl jinde. Na barcampu bylo totiž spoustu zajímavých témat.\n\nDalší už jen krátce abych nezněl moc negativně, protože se mi na barcampu opravdu líbilo a zase tak moc mě tyto věci neštvou. Přístup k netu jen pro přednášející. Měl jsem možnost toho využít, nevyužil jsem, takže o nic nejde, jen bych veřejnou wifi na takových akcích čekal. Další jsou samolepky se jménem při registraci. No já nevím jak ostatním, mě prostě vůbec nedržela a než jsem došel do prvního patra, tak jsem měl na zádech jmenovku se jménem Martina. Bohužel bez čísla. Zdravím Martinu! :-) Poslední věc, která mě mohla dost uzemnit byla ztracená prezentace. Svojí prezentaci jsem na barcamp odeslal předem jak stálo v emailu, ale když jsem se po ní ptal, tak nebyla k nalezení. Naštěstí jsem měl plán B. Uff...\n\nPřednášky\n=========\nPostupně jsem se snažil projít ty nejzajímavější přednášky. Zde je jejich přehled:\n\n*Machine learning, aneb od našeptávače k porozumění řeči (\"Jan Švec .{target:_blank}\":https://twitter.com/honza_svec)* - přednáška o strojovém učení, porozumění řeči a chápání významu psaného i mluveného textu. Některým lidem tato přednáška přišla obsahově zajímavá a skutečně byla, každopádně tyto informace jsem z velké většiny již znal, protože jsem je slyšel již dříve a zase tolik se toho v tomto oboru nemění.\n\n*Procesory letajici, tikajici, hrajici a komunikujici (\"Radek Voltr .{target:_blank}\":https://twitter.com/crawlerdev)* - to je zase opak toho prvního. Některým lidem to nepřišlo moc zajímavé, protože tyto věci znají. Já je tolik neznám a i z důvodu svých budoucích prací do školy pro mě byla tato přednáška přínosným přehledem toho jak lze nacpat slušný výpočetní výkon na malou mršku.\n\n*Virtualizace a cloudy v dnešním IT (\"Milan Brych .{target:_blank}\":http://www.orgis.cz/cs/)* - nejvíce debatované a kontroverzní téma. Každopádně Milan se toho ujal dobře a ačkoliv tam bylo spoustu lidí z oboru, tak i v publiku došlo k debatám lidí s naprosto odlišným názorem. A zpětně musím dodat, že jednoznačně souhlasím s tím, že cloud jako takový je cloudem teprve tehdy, pokud je geograficky rozložen a má dostatečnou redundanci strojů. Někdo na přednášce zmiňoval cloud funkci u NAS serverů. V tu chvíli jsem se musel pousmát...\n\n*Věrnostní program a jeho odvrácená tvář (\"Marek Mencl .{target:_blank}\":https://twitter.com/mmencl)* - asi nejlepší přenáška. Zpětný pohled za projektem, který sice nějak dopadl, ale jeho průběh nebyl úplně hladký. Přednáška byla plná reálných problémů z praxe. Super. Prostě super. Jestli bude záznam, tak doporučuji!\n\n*Pracujte v trenýrkách z kavárny. Nebo ne? (\"David Šmehlík .{target:_blank}\":https://twitter.com/davidsmehlik)* - abych byl upřímný, tak na tuto přednášku jsem šel jen proto, že jsem neměl kam jinam a vybral jsem tak nejmenší zlo. Každopádně rychle jsem zjistil, že jsem udělal dobře, protože celé povídání bylo velmi zajímavé a motivující. I přes původní nedůvěru považuji tuto přednášku za druhou nejlepší. Sorry, Marek byl lepší... :-))\n\n*O e-shopech, o automatickém výpočtu nabídek za prokliky na Heurece a o tom, kde je problém doopravdy (\"Michal Janík .{target:_blank}\":https://twitter.com/michaljanik)* - zde to bylo celkem jednoduché. Jít na populární blbost (dle zpětných názorů ostatních), nebo na SEO (jak slyším SEO, tak utíkám), nebo na prezentaci neúspěšného portálu? Vybral jsem si tedy přednášku o e-shopech. Nejsem eshopista, takže to pro mě nemělo takovou přidanou hodnotu a myslím si, že kdokoliv nad problémy obchodu přemýšlí, tak dokonverguje ke stejným závěrům jako jsou v prezentaci. Každopádně říct, že to bylo nezajímavé by bylo nejen nefér, ale ani by to nebyla pravda.\n\nOpět musím zopakovat, že mě mrzí absence kamer u ostatních přednášek.\n\nOd Caesara ke QR kódům\n======================\nA konečně k mé přednášce. :-))\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Přednáška o kódování a Thomasu Youngovi na <a href=\"https://twitter.com/search?q=%23barcampcz&amp;src=hash\">#barcampcz</a> je kulervoucí.</p>&mdash; Pavel Pajkrt (@PavelAbbePajkrt) <a href=\"https://twitter.com/PavelAbbePajkrt/statuses/455008230444638208\">April 12, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nA zde je:\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/33460846\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nDěkuji všem posluchačům. Byl jsem skutečně nadšen, když za mnou pak někdo v průběhu dne přišel a děkoval. To bylo kouzelné. Nesmírně si toho vážím. Každopádně abych se jen nevychvaloval, tak cítím určitý dluh vůči posluchačům, protože ačkoliv se mi s tím Luboš Majner i Milan Brych snažili pomoct (díky!), tak jsem nedokázal závěrečnou problematiku úplně objasnit. A vzhledem k tomu, že jsem se pak ještě o těchto věcech několikrát bavil, tak přibližně tuším v čem byly problémy.\n\nTak prvně padl dotaz z kterého bylo jasné, že jsem něco řekl fakt špatně. Proč to šifrovat tak složitě? Proč neposlat rovnou surovou zprávu, když to nejde odposlechnout? To je velice jednoduché. Je sice pravda, že (alespoň v současné době) kvantový signál nelze odposlechnout, nic však nebrání Evě zastřelit Boba a zprávu si jednoduše přečíst. To se u šifrovaného signálu nemůže stát.\n\nA jak je tedy možné že ten signál nelze odposlechnout? Jde o to, že přenášená zpráva není ve formě informace, ale přenáší se pomocí nějakého fyzikálního principu. Takže se nelze připojit na optický kabel aniž by to nebylo zjistitelné. Každopádně jsem rád za závěrečnou diskusi, jelikož byla velmi přínosná a uvědomil jsem si věci, které jsem předtím neřešil. Například komunikaci po veřejném kanálu a ověření, že Alice skutečně mluví s Bobem a ne s Evou. Přečtěte si článek tento \"http://aldebaran.cz/bulletin/2005_14_kry.php .{target:_blank}\":http://aldebaran.cz/bulletin/2005_14_kry.php. Konkrétně poslední část o spolehlivosti metody. Již rozumím padlým dotazům a dávám posluchačům za pravdu. Beru to jako poučení a příští rok už budu tento problém schopen podat ještě líp. Doufám... :-)\n\nJo a přišel si to poslechnout i David Grudl. Yaaay! :-D',	'2014-04-13 13:31:22',	0),
(74,	'Znovupoužitelný formulář',	'znovupouzitelny-formular',	'Každý kdo nějakou chvíli pracuje s Nette Frameworkem již jistě narazil na prvky, které lze použít v aplikaci opakovaně. Říkejme jim znovupoužitelné komponenty, nebo prostě jen komponenty. Následující text má za úkol ukázat opět maximálně prakticky a uceleně jedno z možných řešení jak k tomuto problému přistupovat a co se mi na tomto řešení líbí, nebo naopak nelíbí.\n\nMotivace\n========\nProč vůbec přemýšlet o komponentách? Na tuto věc má pravděpodobně dost lidí zcela jiný názor. Pro mě je havní motivací to, že si vyčistím presentery. Chci toho mít v presenterech skutečně tak akorát. Vždyť podle MVP struktury bych v presenterech neměl mít nic složitého. A pak je zde ta znovupoužitelnost. Co když se rozhodnu, že potřebuji použít stejný formulář na více místech? Přece ho nebudu kopírovat. A že takový požadavek je sice často někdo zmíní, ale prakticky není moc reálný? Ale kdepak. Zrovna nedávno jsem vytvářel mnoho stránek a na každé jsem chtěl mít právě kontaktní formulář. To je požadavek na komponentu jako dělaný...\n\nPresenter\n=========\nVždy když programuji něco takového, tak se nedívám na to, jak je to správně z hlediska OOP a bůh ví čeho všeho ještě. Pro mě je v současné chvíli klíčové to, jak se dané řešení bude používat. Přesenter by tedy mohl vypadat třeba takto:\n\n/--code php\n<?php\n\nclass AdminPresenter extends BasePresenter {\n\n	/** @var \\ActualityFactory @inject */\n	public $actualityFactory;\n\n	private $id;\n\n	public function actionAktualita($id = NULL) {\n		$this->id = $id;\n	}\n\n	protected function createComponentForm() {\n		$control = $this->actualityFactory->create($this->id);\n		$control[\'form\']->onSuccess[] = function () {\n			$this->redirect(\'default\');\n		};\n		return $control;\n	}\n\n}\n\\--\n\nMám tedy presenter, který je například pro administraci a jednu podstránku, která bude sloužit jak pro editaci aktuality, tak i pro přidání nové aktuality. Proto je parametrem *action* právě `id = NULL`. Tim totiž říkám, že může přijít jako parametr *ID* aktuality (v tom případě ji budu chtít upravovat), nebo toto *ID* nebude předáno a v tom případě bude hodnota *NULL* a budu s tím později patřičně nakládat.\n\nV poslední metodě si daný formulář vytvořím. Teoreticky by stačila pouze první řádka. Přidávám však ještě další chování do pole `onSuccess[]`, protože chci komponentu používat na více místech, ale pokaždé po úspěchu přesměrovat na jinou stránku. Zde je jedna z věcí které se mi nelíbí. A to je právě to volání `$control[\'form\']->onSuccess[] = ...`. Musím totiž vědět jak je pojmenovaný formulář uvnitř komponenty, což mě ale je skutečnosti vůbec nezajímá. Mnohem raději bych byl třeba za zápis `$control->onSuccess[] = ...`. Chápu, že se nemusí použít komponenta pouze na fomulář, ale přesto. **Neznáte někdo lepší řešení?**\n\nA teď přijde záludná otázka. Co je to ta factory a proč jí vlastně používám?\n\nFactory\n=======\nProtože v komponentách velmi často potřebuji nějaké závislosti, musím je tam nějak dostat. K tomu slouží například generované továrničky. Jedná se vlastně pouze o interface:\n\n/--code php\n<?php\n\ninterface IActualityFactory {\n\n	/** @return \\Cntrl\\Actuality */\n	public function create();\n\n}\n\\--\n\nNette se této továrničky chytí a vytvoří zhruba tento kód:\n\n/--code php\n<?php\n\nfinal class SystemContainer_IActualityFactoryImpl_58_IActualityFactory implements IActualityFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	public function create() {\n		$service = new Cntrl\\Actuality;\n		return $service;\n	}\n\n}\n\\--\n\nZde je tedy (když bude potřeba) možné vytvořit nějaké závislosti a v metodě `create()` je komponentě předat. To vše lze udělat automaticky a Nette se o to postará. Dokonce lze předávat i parametry z konfiguračního souboru. Je to nesmírně elegantní řešení. Kdybych továrničky nepoužil, musel bych vytvářet ručně komponentu, to by ale znamenalo, že bych také musel předávat všechny závislosti ručně a jen bych si tím přidělal práci. Zkuste si vytvořit komponentu bez použití factory. Je nesmysl tahat si v presenteru nepotřebné závislosti přes presenter... Jak však předat parametry z presenteru? Netuším, jestli to lze nějak generovanou továrničku naučit, nic nám však nebrání napsat si vlastní factory:\n\n/--code php\n<?php\n\nclass ActualityFactory extends Nette\\Object {\n\n	private $actualities;\n\n	public function __construct(App\\Actualities $actualities) {\n		$this->actualities = $actualities;\n	}\n\n	public function create($id) {\n		return new \\Cntrl\\Actuality($this->actualities, $id);\n	}\n\n}\n\\--\n\nJe jasně vidět, že tato ručně napsaná factory vypadá velmi podobně jako automaticky vygenerovaná, ale navíc teď můžu předat metodě `create($id)` parametr, což je přesně to co potřebuji viz presenter. Chci si předat číslo aktuality a nevidím důvod proč bych to měl dělat až v komponentě. Komponenta potřebuje *ID* aktuality, ale kde ho vezme nemusí řešit. Je otázka, jestli bych si už rovnou neměl vytáhnout data z databáze v presenteru. Takto se mi to ale zatím líbí víc...\n\nRučně vytvořenou factory musíme ještě zaregistrovat v konfiguračním souboru:\n\n/--code neon\nservices:\n	- ActualityFactory\n\\--\n\nTo je vše. Už jsme pouze krůček od funkčního formuláře.\n\nSamotná komponenta\n==================\nSamotný kód komponenty už není téměř ničím zvláštní, nebo nějak nepochopitelný:\n\n/--code php\n<?php\n\nnamespace Cntrl;\n\nuse App;\nuse Entity;\nuse Nette\\Application\\UI;\nuse Nette;\n\nclass Actuality extends UI\\Control {\n\n	private $actualities;\n	private $actuality;\n\n	public function __construct(App\\Actualities $actualities, $id) {\n		parent::__construct();\n		$this->actualities = $actualities;\n		$this->actuality = $this->actualities->findOneBy([\'id\' => $id]);\n	}\n\n	public function render() {\n		$this->template->setFile(__DIR__ . \'/Actuality.latte\');\n		$this->template->render();\n	}\n\n	protected function createComponentForm() {\n		$form = new UI\\Form;\n		$form->addText(\'headline\', \'Titulek:\');\n		$form->addTextArea(\'text\', \'Text:\');\n		$form->addSubmit(\'send\', \'Uložit\');\n		if($this->actuality) { //výchozí hodnoty jen pokud aktualita již existuje\n			$form->setDefaults(array(\n				\'headline\' => $this->actuality->headline,\n				\'text\' => $this->actuality->text,\n			));\n		}\n		$form->onSuccess[] = $this->actualityFormSucceeded;\n		return $form;\n	}\n\n	public function actualityFormSucceeded(UI\\Form $form) {\n		$values = $form->getValues();\n		try {\n			if(!$this->actuality) { //pokud ještě neexistuje vytvořím novou entitu\n				$this->actuality = new Entity\\Actuality();\n			}\n			$this->actuality->headline = $values->headline;\n			$this->actuality->text = $values->text;\n			$this->actuality->date = new \\DateTime();\n			$this->actualities->save($this->actuality);\n			$this->presenter->flashMessage(\'Aktualita byla úspěšně uložena.\', \'success\');\n		} catch (\\Exception $exc) {\n			$this->presenter->flashMessage($exc->getMessage(), \'danger\');\n		}\n		//žádný redirect, až v presenteru!\n	}\n\n}\n\\--\n\nV konstruktoru jednak získám nějakou modelovou třídu pro práci s databází (o to se krom factory  vůbec nestarám) a také *ID*, které přišlo z presenteru. A rovnou toto *ID* použiju k vytáhnutí si dat z databáze, protože konstruktor se spustí vždy a já také vím, že tyto data budu vždy potřebovat. V `render()` metodě pouze předám šablonu komponenty, která ve své nejprimitivnější podobě může vypada pouze takto:\n\n/--code\n{control form}\n\\--\n\nOstatně stejný kód mohu použít pro šablonu do které předávám komponentu z presenteru. Výsledkem celého snažení je tedy poměrně jednoduchý přesenter a jedna stránka na které je formulář, který zvládne jak editaci, tak vytváření nového záznamu v databázi.\n\nPoužíváte nějaké lepší (jiné) řešení? Podělte se o něj... :-)',	'2014-05-13 11:54:22',	0),
(75,	'Stáhněte si lepší blog',	'stahnete-si-lepsi-blog',	'Čas od času se na Nette fóru najde někdo, kdo hledá vzorový projekt do kterého by se mohl podívat. Vlastně se většinou hledá cokoliv, jakákoliv inspirace. Bohužel se zřejmě všichni bojí toho, že o svůj projekt přijdou, protože v něm někdo najde bezpečnostní chybu. Já se toho také bojím, ale lepší než před tím utíkat je se tomu postavit čelem. A tak je to tady.\n\nKdokoliv cokoliv\n================\nK dispozici je pro nahlédnutí tento blog. A nejen k nahlédnutí, ale také k \"volnému používání\":http://www.zeminem.cz/develop.\nNa pozadí běží hned několik technologií, které si můžete prakticky osahat:\n\n+ Nette Framework (\"nette.org .{target:_blank}\":http://nette.org/)\n+ Nette Tester (\"tester.nette.org .{target:_blank}\":http://tester.nette.org/)\n+ Texy *(je sexy)* (\"texy.info .{target:_blank}\":http://texy.info/)\n+ FSHL (\"fshl.kukulich.cz .{target:_blank}\":http://fshl.kukulich.cz/)\n+ Webloader (\"addons.nette.org .{target:_blank}\":http://addons.nette.org/janmarek/webloader)\n+ Kdyby\\Doctrine 2 (\"GitHub\":https://github.com/Kdyby/Doctrine)\n\nK dispozici je i databáze, protože si myslím, že bych se i s únikem databáze neměl nijak ohrozit... :-) Účelem tohoto nápadu a následně rozhodnutí je poskytnout pokud možno funkční a aktivní projekt, který staví právě na těchto technologiích. Důvodem je pak moje zkušenost s tvrdým začátkem. Mám příležitost občas pracovat s někým kdo se přesně toto chce naučit, bohužel pár lidí už to prostě vzdalo, protože je toho *moc* a není mnoho lidí kteří skutečně pomohou (rozhodně ne na fóru). Snažím se tedy zaplnit toto prázdné místo a nabídnout tento blog jako jeden z možných začátků. Mimochodem neříkám, že moje řešení je nejlepší, nebo správné. Je jedno z možných a funkčních. Stáhnout si jej můžete ze své oblíbené verzovací služby:\n\n/---html\n<div class=\"row\" style=\"margin-top:50px;margin-bottom:50px\">\n	<div class=\"col-lg-6 col-md-6 col-sm-6 text-right\">\n		<a class=\"btn btn-default\" href=\"https://bitbucket.org/mrtnzlml/www.zeminem.cz\" target=\"_blank\">\n			<img src=\"/img/loga/bitbucket.png\">\n		</a>\n	</div>\n	<div class=\"col-lg-6 col-md-6 col-sm-6\">\n		<a class=\"btn btn-default\" href=\"https://github.com/mrtnzlml/www.zeminem.cz\" target=\"_blank\">\n			<img src=\"/img/loga/github.png\">\n		</a>\n	</div>\n</div>\n\\---\n\nPodrobnější popis najdete na \"samostatné stránce\":http://www.zeminem.cz/develop věnované tomuto projektu. Byl bych moc rád, kdybych touto cestou pouze nenabídl něco chybějícího, ale také získal zpětnou vazbu. Nestojím o pochvaly. Ty samozřejmě potěší, ale mnohem přínosnější jsou praktické poznámky k implementaci, nebo funkcím. Nad takovou věcí se vždy rád zamyslím...',	'2014-05-19 11:00:51',	0),
(76,	'Disqus lazy loading',	'disqus-lazy-loading',	'Tento článek ve skutečnosti odstartovalo zdánlivě nesouvisející vlákno na \"Nette fóru .{target:_blank}\":http://forum.nette.org/cs/19397-ako-sa-zbavit-fid-v-url-ak-sa-nemylim. V tomto vláknu se řeší parametr *_fid* v URL adrese, který tam Nette framework přikládá kvůli flash messages. Tato vlastnost někoho skutečně hodně štve, mě zase až tak moc ne. Jenže když jsem nad tím vláknem chvíli seděl, tak jsem si uvědomil, že mám komentářový systém Disqus implementovaný špatně. Čtěte dál a vyhněte se stejné chybě... (-:\n\nUniverzální kód\n===============\nDisqus poskytuje \"by default\" univerzální kód, který prakticky pouze zkopírujete na svůj web na požadované místo a je hotovo. Tento kód vypadá zhruba takto:\n\n/--code html\n<div id=\"disqus_thread\"></div>\n<script type=\"text/javascript\">\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n    var disqus_shortname = \'\'; // required: replace it with your forum shortname\n\n    /* * * DON\'T EDIT BELOW THIS LINE * * */\n    (function() {\n        var dsq = document.createElement(\'script\'); dsq.type = \'text/javascript\'; dsq.async = true;\n        dsq.src = \'//\' + disqus_shortname + \'.disqus.com/embed.js\';\n        (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n    })();\n</script>\n<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n\\--\n\nJe to pohodlné, ale je to úplně blbě. Nejenom pro Nette aplikace, ale myslím si, že tak nějak celkově pro všechny aplikace. Fungovat to sice bude, to ano. Ale jen tak zdánlivě. Problém je totiž v tom, že toto nastavení bere jako identifikátor diskuse URL adresu a pokud se jen drobně změní, tak se založí nová diskuse. Přehled těchto diskusí je pak vidět v Disqus administraci. To s sebou nese celou řadu problémů. Diskuse nejde pořádně zamknout a už to, že k jedné stránce může být více diskusí je problém. Každá diskuse totiž musí mít unikátní identifikátor \"disqus_identifier .{target:_blank}\":https://help.disqus.com/customer/portal/articles/472098-javascript-configuration-variables nezávisle na parametrech (pokud ovšem tyto parametry nejsou žádoucí).\n\nLazy loading\n============\nJá jsem sice nepoužil defaultní konfiguraci, ale udělal jsem prakticky tu samou chybu. Teď ale konečně k lazy loadingu. Na svém blogu to již používám dlouhou dobu a myslím si, že se to již osvědčilo. Inspirací k mé implementaci je \"tento gist .{target:_blank}\":https://gist.github.com/omgmog/2310982.\n\nStačí umístit následující kód do nějakého souboru *main.js*, který se spouští po načtení stránky:\n\n/--code javascript\nvar disqus_div = $(\"#disqus_thread\");\nif (disqus_div.size() > 0) {\n    var ds_loaded = false,\n    top = $(\'.load_disqus\').offset().top, //upravit podle potřeby\n    disqus_data = disqus_div.data(),\n    check = function () {\n        if (!ds_loaded && $(window).scrollTop() + $(window).height() > top) {\n            ds_loaded = true;\n            for (var key in disqus_data) {\n                if (key.substr(0, 6) == \'disqus\') {\n                    window[\'disqus_\' + key.replace(\'disqus\', \'\').toLowerCase()] = disqus_data[key];\n                }\n            }\n            var dsq = document.createElement(\'script\');\n            dsq.type = \'text/javascript\';\n            dsq.async = true;\n            dsq.src = \'http://\' + window.disqus_shortname + \'.disqus.com/embed.js\';\n            (document.getElementsByTagName(\'head\')[0] || document.getElementsByTagName(\'body\')[0]).appendChild(dsq);\n        }\n    };\n    $(window).scroll(check);\n    check();\n}\n\\--\n\nTím to však nekončí. Je samozřejmě nutné určit kde se Disqus bude zobrazovat:\n\n/--code html\n<div class=\"hidden-print\">\n	<div id=\"disqus_thread\" data-disqus-shortname=\"mrtnzlml\" data-disqus-url=\"{link //this}\"></div>\n	<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n	<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n</div>\n\\--\n\nKlíčový je zde právě data atribut *disqus-url*. No a aby byl kod kompletní, tak je zapotřebí někam umístit CSS trídu *.load_disqus*. Tu doporučuji umístit někam nad diskusi a tím myslím třeba o celou viditelnou stránku. Disqus se tak začne načítat o něco dříve, než k němu čtenář doscrolluje, takže se stihne načíst a nebude to rušit. Ve výsledku se tedy Disqus nenačítá po otevření stránky, takže je načtení svižné, ale po např. přečtení článku je již načtený...\n\nA co vy? Máte Disqus na svém webu implementovaný správně? (-:',	'2014-06-12 21:36:26',	0),
(77,	'Čteme Data Matrix bez čtečky',	'cteme-data-matrix-bez-ctecky',	'[* 1fc11f25-abc2-453e-abb4-adb31d0ccf17/datamatrix.png <]\n\nDnešním článkem navazuji na dřívější článek \"Čteme QR kódy bez čtečky\":http://www.zeminem.cz/cteme-qr-kody-bez-ctecky, ve kterém jsem řešil čtení QR kódu bez použití jakéhokoliv čtecího zařízení. A dnes budu řešit téměř to samé, ale s jiným kódem. Data Matrix není tolik známý, ale myslím si, že patří, hned po QR kódech, mezi nejpoužívanější kódy vůbec. Po tomto článku si jich zajisté začnete všímat více. Naposledy jsem jej viděl na balíčku od jahod... (-: Opět platí, že hlavním cílem je kód přečíst, nikoliv mu úplně porozumět, takže nebudu rozebírat velké detaily.\n\nLevý obrázek je kód o kterém bude celou dobu řeč.\n\nTrocha nezbytné teorie\n======================\n[* 0dd271b6-21ea-4c3c-a447-723b76257b50/datamatrix-key.png <]\n\nTento kód je oproti QR kódu velmi jednoduchý, takže i teorie bude stručná. Veškerá data a korekce chyb je ukryta uvnitř rámu, který je z části plný. To umožňuje čtečkám poznat kde všude je ještě kód a jak je natočen. Z pohledu \"ručního\" čtení je tato část nezajímavá. Modře jsou zvýrazněny 4 bity, které k ničemu neslouží a zaplňují jen prázdné místo. Ne vždy je tento úkaz vidět. Bohužel tentokrát nemám k dispozici originální specifikaci, takže nevím jakým přesným pravidlům to podléhá.\n\nNejpodstatnější jsou však červeně zarámované oblasti. Všechny mají takovýto tvar a vždy mají přesně dané umístění. Toto umístění je vlastně dáno první oblastí s číslem 2. Nicméně z hlediska umístění dat je nejdůležitější pátý bit v prvním sloupci od kterého vše startuje. Pokud obrazec přesahuje to timing zón, tedy do nažloutlého rámu, tak pokračuje na druhé straně, tedy dole, nebo na pravé straně.\n\nData se v kódu čtou podle čísel, tedy podél takové diagonální vlnovky a to až do obrazce s číslem 5. Tento obrazec určuje konec zprávy. V našem případě se tedy jedná o zprávu, která má 4 znaky. A jak už to tak bývá, tak jsou všechny znaky přenášeny v binárním formátu. Zbytek kódu, který není nijak zvýrazněn je klasicky Reed–Solomon korekce chyb. Možná bych o tomto mechanismu také mohl někdy napsat článek. Nicméně napovažuji to za úplně jednoduchá záležitost, takže si to zatím nechám v zásobě.\n\nHrajeme si na čtečku\n====================\n\nPřečíst zprávu v takto teoreticky rozebraném kódu už je otázka chvilky. Najdříve si vytáhneme všechny potřebné části. V tomto případě je zbytečné řešit pátý člen, jelikož se jedná o poslední ukončovací. Jeho hodnota je 129 v desítkové soustavě. Získané útvary jsou vidět na obrázku níže.\n\n[* 76028c59-4e5f-42f4-a411-3452844a30d2/last.png *]\n\nČísla určují pozici bitů v binárním čísle. Po přepsání do binární podoby mají znaky následující hodnoty:\n\n/--code\n01100010 01101001 01110000 01101011\n\\--\n\nV desítkové podobě jsou to tedy čísla:\n\n/--code\n98 105 112 107\n\\--\n\nNásledně je zapotřebí od těchto čísel odečíst jednotku. Abych řekl pravdu, tak jsem po dlouhém uvažování nedokázal přijít s rozumným vysvětlením proč se to tak dělá. Původně mě napadadlo, že je to kvůli lepšímu rozložení bitů ve výsledném obrazci. Stejně tak jako se u QR kódů bity ještě maskují. To ale nedává smysl. Je to jen posunutí o jedna. Nic víc... Nicméně je zřejmé, že spousta věcí je v takovýchto kódech minimálně na zamyšlení. Ale zpět k poslednímu kroku. Z předchozího článku již všichni vědí, že číslo 97 je v ASCII tabulce hodnota znaku **a**, takže po odečtení jednotky a přepsání do čitelné podoby získáváme řešení:\n\n/--code\n97 104 111 106\na  h   o   j\n\\--\n\nTento kód je pro čtení bez čtečky daleko snadnější, komplikuje to jen nezvyklé uspořádání bitů. Jaký další kód bych měl dostat pod drobnohled? Snad to půjde. Mám zde totiž rozpracovaný ještě jiný a nemohu k němu sehnat normu pro nahlédnutí, takže jsem se zatím zasekl... (-:',	'2014-06-15 16:34:13',	0),
(78,	'Novinky na blogu a extension RFC',	'novinky-na-blogu-a-extension-rfc',	'Kdo pravidelně sleduje \"můj twitter\":https://twitter.com/mrtnzlml, tak už to ví. A je to skvělé! Včera jsem totiž \"mergnul\":https://github.com/mrtnzlml/www.zeminem.cz/commit/b21775df522271e81302d2987ff44d5285b245eb důležitou část tohoto blogu a tím vydal verzi 1.1 snad stable... (-: Jedná se o celkem významný krok, ale stále je to nic oproti tomu co mám v plánu. V dnešním článku bych se rád podělil o většinu zajímavých novinek a v druhé části bych rád požádat o pomoc s rozvinutím jednoho zajímavého nápadu.\n\nNovinky v release 1.1\n=====================\nA hned první novinka je ta nejzajímavější. Zastávám názor, že by si měl programátor za svým kódem stát a to v každé situaci. Proto jsem se rozhodl, že pustím kohokoliv do své administrace. Ostatně proč ne. Je to výzva. Rád bych však napřed požádal kohokoliv kdo najde nějakou chybu, aby mi to dal vědět na základě nepsané programátorské etikety a nesnažil se celý blog hned zničit. Zálohu mám... :-) Administraci najdete na adrese www.zeminem.cz/admin a přístupové údaje jsou `demo / demo`. Enjoy.\n\nAčkoliv je první představená novinka asi nejzajímavější pro kohokoliv jiného, pro mě osobně je nejzajímavější nový systém vkládání obrázků. To je něco co mi na blogu dlouho chybělo. Představoval jsem si to tak, že bych obrázky jednoduše a rychle nahrál a stejně jednoduše bych je vložil do aktuálně psaného článku. A přesně to teď můžu udělat. Použil jsem \"fineuploader\":http://fineuploader.com/, protože je to skvělý program. Můžu AJAXově nahrávat souběžně několik obrázků s velikostí klidně až za PHP limitem `upload_max_filesize` a nebo navázat na přerušené nahrávání. To vše vlastně díky chunk uploadu. Umí toto váš blog? Zkuste si na sdíleném hostingu nahrát soubor o velikosti třeba 50MB...\n\nToto jsou dvě nejdůležitější změny, na kterých jsem v desetinkové verzi pracoval. Správa uživatelů a cool image uploader. Dále jsem udělal opět několik designových změn a fixů, ale už se nejedná o nic tak důležitého aby to stálo za řeč.\n\nDalší kroky a žádost o pomoc\n============================\nSvůj blog mám rád. A mám ho rád až tak, že bych byl rád, aby ho časem používal i někdo jiný. To ještě nějakou chvíli potrvá, ale už nějaký čas mi leží v hlavě nápad, jak se k tomuto požadavku přiblížit. Rád bych totiž blog přepsal do Nette extensions. Včera jsem popré \"nakousl\":https://github.com/mrtnzlml/www.zeminem.cz/commit/1ffc33bc5dddbadfc1b6ce7d30dccb09938800cb svojí myšlenku. Princip je jednoduchý. Přepíšu například funkcionalitu obrázků (nebo čehokoliv jiného) do extension a když bude někdo budovat nový blog, tak si jen v konfigu zvolí jaké moduly chce (to se dá snadno generovat):\n\n/--code neon\nextensions:\n	- ImageExtension\n    - SearchExtension\n    - ...\n\\--\n\nSamotné extension má potom za úkol se samo spustit (`afterCompile`) a přidat nějaké funkcionality do stacku (v metodě `initialize`). V prvním nakousnutí například přidávám položku do menu a skutečně to funguje tak jak píšu. Jakmile nějakou funkci nechci, prostě ji z konfigu zruším. Výhodné na tom je to, že můžu prošpikovat blog místy, kam lze nové feature zaregistrovat a dají se velmi jednoduše provázat přes composer. **Ale.** Má to háček.\n\nKdyž jsem si s touto myšlenkou hrál jen v hlavě, tak to bylo super, protože vše fungovalo perfektně. Bohužel jsem narazil na to, že nevím jak pěkně vyřešit šablony a routování na ně. Šablony jsou totiž jedna z dalších věcí které bych zde chtěl vyřešit. Bylo by fajn, kdyby mohl mít každý možnost si třeba šablony podědit a změnit si kompletně celý design. To zase takový problém není. Ale jak vyřešit to, když chci v extension např. přidat novou stránku? Kam umístit šablonu a jak ji naroutovat? Nějak jsem to dneska v noci už nedokázal vymyslet. Máte někdo prosím nějaký zajímavý nápad? Díky...\n\nNo a naposledy už snad jenom: \"Give me a star, please\":https://github.com/mrtnzlml/www.zeminem.cz...',	'2014-07-13 14:00:51',	0),
(79,	'SračkoAPI',	'srackoapi',	'Následující řádky budou čistý hate na několik tvůrců API, který má posloužit budoucím tvůrcům API. Sám totiž musím obsluhovat několik služeb a získávat z nich data. A ačkoliv se nebráním složitostem, některé věci jsou tak absurdní, že až rozum zůstává stát...\n\nNo to si ze mě děláte...\n------------------------\nPrvní místo na žebříčku debility získává API pro obsluhu a registraci domén od Web4U. Jedná se o klasické SOAP API, které mě však místy přivádí k šílenství. Začnu pěkně od začátku. Aby bylo vůbec možné API volat, musíte nejdříve získat identifikátor služby. Kde jej sehnat? Napadá vás někde v aministraci? Kde jinde také, že? Omyl! Identifikátor služby se získává tak, že zavoláte jakoukoliv funkci z jejich API špatně a identifikátor najdete ve vrácené exception. A to si nedělám prdel. To fakt mají napsané v dokumentaci. A aby toho nebylo málo, tak vrácené ID je ve formátu `IDxxxxxxx, ...`. Koho by však napadlo, že ID je tich prvních 9 znaků, tak je na omylu. ID je totiž to ID bez úvodního ID, tedy `xxxxxxx`. Takto je to možná jasné, ale když k tomu poprvé sednete, tak nad tím sedíte půl dne. Následně lze funkci opět volat s vráceným ID. A právě volání je další sranda.\n\nV dokumentaci je totiž jasně napsáno co jsou povinné vstupní hodnoty, volitelné hodnoty a občas i co to vrací. Takže je to jasné, prostě tam pošlu pole hodnot key-value a je to. Hahaha. Ne. Do tohoto API se totiž posílá pole polí s tím, že je zapotřebí dodržovat přesně stanovený formát a to takovýto:\n\n/--code php\narray(\n	array(\'name\' => \'key\', \'data\' => \'value\'),\n	//...\n)\n\\--\n\nJe to jedna z věcí, která je prostě hloupá. Pokaždé se musím sám sebe ptát, proč to tak je? Nerozumím tomu, nemá to žádnou přidanou hodnotu. Jdeme dál. Řekněme, že potřebujete pomocí API zjistit nějakou informaci o doméně, například kdy skutečně expiruje. Na to se stačí jednou týdně zeptat a aktualizovat si informace v databázi. To pro případ, že byla doména prodloužena u třetí strany. No, nebudeme to rozebírat dále. Přes API nelze tuto funkci zavolat. Proč? Vyžaduje totiž captchu. Jo, ta funkce v API se fakt volá přes obrázkovou captchu. Jako jediná. Chápu jak to použít, ale prakticky všechny své projekty dělám plně automatizované, takže jediné řešení je zde najmout \"armádu Indů\":http://www.root.cz/clanky/potrebujete-obejit-captcha-zaplatte-si-armadu-indu/ a captchy louskat ručně.\n\nA takových perel je tam nespočet. Potřebujete vědět, jestli proběhla funkce v pořádku? Nope. Výstupem z funkce je totiž číslo požadavku. Chybu si totiž musíte poměrně nepěkně vydlabat z exception. Další věc je čistě logická. České domény lze registrovat pouze s NSSETem. Jinak to nejde. U jiných domén se zadávají jednotlivé NS servery. U CZ domény se musí nejdříve vytvořit identifikátor držitele kontaktu. U jiných domén se vytváří při registraci domény. To se všechno může zdát jako maličkosti, ale takové věci vše zbytečně komplikují a použití takového API je spíš otrava. Přitom si myslím, že největší příliv např. domén musí být právě strojově přes API.\n\n...ale už fakt prdel!\n---------------------\nRychlá otázka k zamyšlení. Jak uděláte API, aby bylo možné jej snadno testovat? Změníte například přístupové údaje na testovací, nebo budete posílat nějaký testovací token? OK. Myšlenka je jasná. Kdykoliv se to dá snadno přehodit např. změnou jednoho hesla do ostrého režimu. Jenom v debilním API se metody pro testování jmenují jinak, než metody pro ostré použití. Kurva! To je další věc, která to celé nepříjemně zkomplikuje.\n\n[* d10561e0-aeec-4dae-a21e-17eb7c4ca36d/gif.gif <]\nDobře, poslední příklad. Nedávno jsem zase něco nevyčetl z dokumentace. Napsal jsem tedy na technickou podporu ať mi poradí, že to tam nemají napsané. Konkrétně se jednalo o povolené vstupní hodnoty do jedné funkce. Na odpověď jsem čekal dva dny, což by ani tak nevadilo, ale hodně jsem se nasmál u odpovědi, která přišla v tomto formátu (původně zapsáno pod sebou):\n\n/--code\n\'cs\', \'sk\', \'bg\', \'hr\', \'da\', \'nl\', \'en\', \'et\', \'fi\', \'fr\', \'de\', \'el\', \'hu\', \'ga\', \'it\', \'lv\', \'lt\', \'mt\', \'pl\', \'pt\', \'ro\', \'sl\', \'es\', \'sv\'\n\\--\n\nWhat? Takže podpora také nevěděla a tak mi poslala kus vykopírovaného zdrojového PHP kódu z aplikace? V tuto chvíli už mi začíná být všechno jedno... \n\nJde to i jinak?\n---------------\nVím, že ano, ale stále častěji mě někdo přesvědčuje o opaku. Druhé ukázkové API jsem zvolil pro porovnání také typu SOAP. V tomto API je již většina věcí na které jsem do této chvíle nadával vyřešena. Dokonce jsem potěšen z toho, že se jedná o API poměrně inteligentní a tak se mohu dotazovat hodně podobně jako v Doctrine 2. Paráda.\n\nJenže pak přijde, jak říká kolega, další jobovka. API je totiž totálně bez dokumentace, takže téměř jediné místo, kde lze získat informace o vstupních a výstupních hodnotách je prohlédnout si celý dump dané funkce. Dobře, to není problém. Vidím datum ve známém formátu jako string. Posílám tedy také datum ve stejném formátu jako string. Nic. Dobře, poslím ho jako DateTime. Nic. Až po hodně dlouhé době a nahlášeném bugu jsem dostat fuck off odpověď, že to datum zadávám špatně a musí to být v následujícím formátu:\n\n/--code php\n//...\narray(\n	\'year\' => ...->format(\'Y\'),\n	\'month\' => ...->format(\'m\'),\n	\'day\' => ...->format(\'d\'),\n	\'hour\' => ...->format(\'H\'),\n	\'minute\' => ...->format(\'i\'),\n)\n//...\n\\--\n\nA dost vole, seru na to. Na to nemám nervy. Zase ta samá otázka. Proč? Vždyť... Ale nic. Už raději nic.\n\nProsím všechny programátory, **snažte se víc**. Cílem by mělo být **usnadnit používání**, nikoliv však sobě, ale **uživatelům**. Prosím...\n\nHowgh.',	'2014-07-17 21:58:50',	0),
(80,	'Za hranicí ORM',	'za-hranici-orm',	'Již mnohokrát jsem slyšel, že je ORM \"antipattern\":http://www.zdrojak.cz/clanky/orm-je-antipattern/. Já si to nemyslím. Je to hloupý a uspěchaný názor. V dnešním článku však nechci rozebírat co je a co není antipattern. To je jen zbytečnou ztrátou času. Rád bych ukázal použití jednoho ORM systému, který mě naprosto uchvátil.\n\nKdyž jsou potřeba firemní procesy\n=================================\nZejména začínající firmy mají na svém startu náročný úkol. Je zapotřebí vytvořit vnitrofiremní procesy, které striktně řídí běh různých akcí jako je například výroba, reklamace, nebo třeba koloběh dokumentů. Ve firmě \"taková řešení nabízíme\":http://www.orgis.cz/sluzby/in-house a je o ně velký zájem. Má to svůj smysl. Není žádným tajemstvím, že používáme ERP systém \"Odoo\":https://www.odoo.com/, protože je to velmi silný nástroj. I přes neuvěřitelnou modifikovatelnost této aplikace je občas zapotřebí sáhnout k daleko více sofistikovanému řešení. Proč? Občas jsou totiž vnitropodnikové procesy velmi složité a navíc jich je velké množství. V takovém případě, je téměř jedinou možností napsat si pro tento ERP systém rozšíření, které tento těžký úkol zvládne.\n\n[* 393212dc-381f-4b3a-a06c-fb5d33d6dc29/workflow.png *] *** *Ukázka struktury klasického firemního workflow*\n\nNechci však psát návod na to, jak si takový modul naprogramovat. O tom třeba někdy příště. Pojďme se raději podívat na to, jak téměř celé Odoo funguje, protože je to skutečně pozoruhodné. Bez kódů to však nepůjde.\n\nZáplava tabulek\n===============\nAbych byl upřímný, tak jsem se ještě nikdy nesetkal s tím, aby byl **každý** objekt v projektu skutečně realizován tabulkou v databázi. Nebo o tom alespoň nevím. Je to v podstatě jako když máte entity a ty jsou pak skutečně v databázi. Rozdíl je však v tom, že zde je v \"entitě\" i celá potřebná logika (které většinou moc není) a hlavně žádné jiné objekty nejsou potřeba.\n\nV nejprostším tvaru může tedy třída modulu vypadat skutečně pouze jako entita:\n\n/--code python\nclass project_wkf_activity(osv.osv):\n    _name = \'project.wkf.activity\'\n    _columns = {\n        \'sequence\': fields.integer(\'Sequence\'),\n        \'name\': fields.char(\'Workflow Activity Name\', required=True, size=64, translate=True),\n        \'type\': fields.many2one(\'project.wkf.type\', \'Workflow Type\'),\n        \'fold\': fields.boolean(\'Folded in Kanban View\'),\n    }\n    # ...\n    def jumptoseq(self, cr, uid, ids, sequence, context=None):\n    	#...\n\\--\n\nPři programování modulů toto vede k extrémní explozi tabulek v databázi. 500 tabulek uděláte v databázi jako nic. Stačí nainstalovat pár modulů. A to už mi přijde dost netradiční. Kromě modulových tabulek je v základní instalaci asi 100 tabulek, které v sobě drží vše možné, mimo jiné také informace o workflow. A právě definice workflow je to nejzajímavější. Veškerá sranda se totiž odehrává v XML souborech. Ve výsledku stačí pro napsání složitého workflow včetně veškeré logiky pouze XML...\n\nXML programování (-:\n====================\nKdyž jsem toto poprvé viděl, párkrát jsem se zastavil a přemýšlel jsem, jak to vlastně může fungovat. Je to však velmi jednoduché. V inicializačním souboru modulu si stačí nadefinovat jaké XML soubory se mají načítat. Následuje definice workflow. Žádné psaní okolo. Prostě to hned funguje. Začátek takového workflow může vypadat například takto:\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<record id=\"wkf1\" model=\"workflow\">\n            <field name=\"name\">project.wkf1</field>\n            <field name=\"osv\">project.project</field>\n            <field name=\"on_create\">True</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nTím je workflow založeno a při spuštění převedeno do databáze. Jádro má pak za úkol se těchto tabulek chytit a pracovat s nimi. Jsou jasně daná pravidla, takže s tím není žádný problém. Následuje definice akcí (to jsou ty bubliny na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        \n        <record id=\"a_1_0\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_start\">True</field>\n            <field name=\"name\">start-wkf1</field>\n            <field name=\"kind\">dummy</field>\n        </record>\n\n        <record id=\"a_1_10\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"name\">nazev-activity</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">jumptoseq(10)</field>\n        </record>\n        \n        <record id=\"a_1_500\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_stop\">True</field>\n            <field name=\"name\">end</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">orgis_close()</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nA následuje definice transitions (spojení na obrázku):\n\n/--code html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    	<!-- viz definice workflow -->\n        <!-- viz definice aktivit -->\n        \n        <record id=\"t_1_9\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_40\"/>\n            <field name=\"act_to\" ref=\"a_1_50\"/>\n            <field name=\"signal\">a_1_40toa_1_50</field>\n        </record>\n        <record id=\"c_1_7\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_36\"/>\n            <field name=\"act_to\" ref=\"a_1_500\"/>\n            <field name=\"signal\">close_wkf</field>\n        </record>\n	</data>\n</openerp>\n\\--\n\nUkázky jsou nekompletní, protože by se to sem všechno ani náhodou nevešlo. Výsledný XML soubor vlastně stačí k tomu, aby celé workflow fungovalo. Stačí nadefinovat funkce v příslušných třídách viz například volání `jumptoseq`.\n\nDost často je také zapotřebí definovat tlačítka pro view, což se dělá také pomocí XML kde je opět originálně vyřešeno přepisování defaultní šablony. Tlačítka mají vždy nějakou akci, která zajistí, že se posuneme ve workflow dále. Na takové workflow lze pověsit úplně všechno. Poslání emailů, vygenerování faktur, založení akce v kalendáři atd. Pokud se jedná o vyloženě automatické kroky, akce se na tlačítku nemusí definovat a pak systém celé workflow proskáče a spustí všechny akce popořadě sám. Zajímavé je však to, že se po spuštění všechno nahrne do databáze a jádro Odoo se strará pouze o to, aby tento interně složitý systém fungoval správně. Všem lidem, kteří nadávají na ORM bych tedy položil následující otázku. Jak uděláte takto sofistikovaný systém bez ORM? Nebo že toto snad není ORM? A uvědomte si, jak jsem se strašně rychle dokázal dostat z ORM až na celý komplexní systém workflow. Je to proto, že jsem vůbec neuvažoval něco jako je ActiveRow... (-: I když z velké části je to spíše plnění tabulek.\n\nV tomto reálně fungujícím řešení je velmi hluboká myšlenka. A udivuje mě, že v jiných systémech toto funguje úplně obráceně. Všichni se snaží programovat spíše to jádro. Ukazuje se však, že využít kvalitní jádro, které se stará o všechno je daleko přínosnější. Vzpomeňte si na tento článek, až budete ťukat do klávesnice entity, mappery, repository, DAO objekty a další a to pouze kvůli tomu, aby bylo možné udělat nějaké takové workflow, jako jsem zde teď popsal. Už zase...\n\nPoužíváte také nějakou netradiční implementaci ORM?',	'2014-08-01 22:55:45',	0);

INSERT INTO `posts_tags` (`id`, `tag_id`, `post_id`) VALUES
(98,	42,	10),
(99,	42,	9),
(101,	41,	11),
(102,	42,	11),
(105,	41,	45),
(106,	42,	45),
(107,	44,	45),
(108,	42,	46),
(109,	41,	46),
(114,	45,	49),
(115,	43,	4),
(119,	41,	50),
(120,	42,	50),
(121,	45,	50),
(123,	41,	51),
(130,	42,	52),
(131,	46,	52),
(132,	41,	53),
(136,	41,	54),
(137,	47,	54),
(138,	48,	54),
(139,	49,	55),
(141,	50,	56),
(142,	41,	57),
(143,	51,	3),
(144,	41,	58),
(145,	41,	59),
(146,	52,	60),
(147,	52,	2),
(148,	41,	47),
(149,	42,	47),
(154,	41,	62),
(155,	42,	62),
(156,	54,	62),
(157,	46,	63),
(158,	55,	63),
(159,	41,	64),
(160,	56,	64),
(161,	57,	64),
(162,	58,	65),
(163,	53,	61),
(164,	59,	67),
(170,	52,	68),
(171,	60,	69),
(172,	61,	69),
(173,	48,	70),
(174,	47,	70),
(175,	41,	70),
(176,	41,	71),
(177,	62,	71),
(178,	53,	72),
(179,	63,	73),
(180,	41,	74),
(181,	62,	74),
(182,	47,	76),
(183,	64,	76),
(184,	61,	77),
(185,	58,	78),
(186,	41,	78),
(187,	49,	79),
(188,	65,	79),
(189,	66,	80),
(190,	67,	80),
(191,	68,	80);

INSERT INTO `tags` (`id`, `name`, `color`) VALUES
(41,	'nette',	'106dcf'),
(42,	'php',	'aa16b1'),
(43,	'html',	'1c7640'),
(44,	'tester',	'9f1857'),
(45,	'sql',	'7608de'),
(46,	'pcre',	'a69d02'),
(47,	'javascript',	'a4423a'),
(48,	'ajax',	'706753'),
(49,	'úvaha',	'0a8b93'),
(50,	'latex',	'c51cdd'),
(51,	'math',	'256781'),
(52,	'crypto',	'de3446'),
(53,	'bezpečnost',	'33b1d7'),
(54,	'git',	'07269c'),
(55,	'vlna',	'd51082'),
(56,	'texy',	'28009d'),
(57,	'fshl',	'558fed'),
(58,	'RFC',	'780672'),
(59,	'stats',	'd45a45'),
(60,	'QR',	'f4512c'),
(61,	'matrix',	'730dd0'),
(62,	'doctrine',	'3ba8ca'),
(63,	'barcamp',	'7c3448'),
(64,	'disqus',	'97871f'),
(65,	'API',	'a1520c'),
(66,	'odoo',	'a24689'),
(67,	'python',	'cb5a16'),
(68,	'xml',	'66bb15');

INSERT INTO `users` (`id`, `username`, `password`, `role`) VALUES
(1,	'martin',	'$2y$10$39OQqbxEVjby7x1kpRnH8eXjxyM3ARSFhyRrTShmTE8osiCdnbytq',	'admin'),
(2,	'demo',	'$2y$10$2SdneWBxW3y4f2qGKE6fi.dvJzBT4JKdo3Rmrv/2hd66WePZ8EOW2',	'demo');

-- 2014-08-24 15:14:00
