[{"attributes":{"id":"2151f134-7f0e-43c0-8382-eab9d336b7ee","timestamp":1500731161000,"title":"How do we do serverless?","slug":"how-do-we-do-serverless"},"body":"In past few months, I moved completely from PHP backend to the JavaScript semi-frontend (not really backend but definitely not frontend - somewhere between). And I am glad I did it because finally, I can try every cool technology I always wanted but haven't had the opportunity. And one of these technologies is a serverless approach. It basically means that you still have servers but you are not taking care of the bare metal but you'll rather get computational power with all the fancy stuff like auto-scaling, high availability, related services orchestration and so on.\n\nHere at Kiwi.com (Prague), we are working on a lot of projects but one of them is more often pronounced - [the chatbot](http://www.czechcrunch.cz/2017/05/brnenske-kiwi-com-otevira-v-praze-novou-pobocku-se-zamerenim-na-umelou-inteligenci/). This chatbot should help our customer support to manage tasks more easily. But the interesting part is that this application is **completely serverless**. This is how it works.\n\n# It's just a function\n\nThe whole chatbot is just a function. Quite long and complicated one though. It's written in Node.js (ECMAScript 2017 - ES8 with a shit-ton of transpilers) and it runs on AWS Lambda. One of the best parts of the serverless is its deployment. We are using [Serverless Framework](https://serverless.com/) and that means that deployment to the serverless infrastructure is as easy as writing `serverless deploy`:\n\n```\n$ serverless deploy --stage staging\nServerless: Packaging service...\nServerless: Uploading CloudFormation file to S3...\nServerless: Uploading artifacts...\nServerless: Uploading service .zip file to S3...\nServerless: Validating template...\nServerless: Updating Stack...\nServerless: Checking Stack update progress...\n..........\nServerless: Stack update finished...\nService Information\nservice: chatbot\nstage: staging\nregion: eu-west-1\napi keys:\n  None\nendpoints:\n  POST - https://secret.eu-west-1.amazonaws.com/staging/\nfunctions:\n  chatbot: chatbot-staging-chatbot\nServerless: Removing old service versions...\n```\n\nWhat does this framework do? Firstly it creates a ZIP file with the already transpiled and tested code. It also creates [AWS CloudFormation](https://aws.amazon.com/cloudformation/) template and uploads it to the AWS S3 storage. Now the magic happens. The new environment is created/updated thanks to the CloudFormation template. In our case, it means that it creates API Gateways, Lambda functions, and DynamoDB tables. This way you can invoke Lambda function just by calling URL address.\n\nThe interesting part is that you can extend CloudFormation template however you want. In your case, we are just creating DynamoDB tables but I think you can do whatever you want (means whatever CloudFormation is able to do).\n\n# Dazzle me\n\nI'll show you just a simplified serverless definition (without the DynamoDB because it's too long), but the overall picture should be clear. The whole serverless infrastructure is defined in `serverless.yml`:\n\n```neon\nservice: chatbot\n\nprovider:\n  name: aws\n  runtime: nodejs6.10\n  region: eu-west-1 # Ireland\n\nfunctions:\n  chatbot:\n    handler: dist/basicLambda.handler\n    events:\n      - http:\n          path: /\n          method: POST\n          cors: true\n          integration: lambda-proxy\n```\n\nIt's quite self-explanatory. It's like a scenario: just create AWS Lambda function from `dist/basicLambda.js` file and on `POST` invoke a function in that file called `handler` (and yeah, also support CORS please). Since we are executing only transpiled and tested code it's a good idea to upload just that file:\n\n```neon\npackage:\n  exclude:\n    - ./**\n  include:\n    - dist/*\n```\n\nDynamoDB and other services can be defined in the `resources` section. You just have to make sure that you'll setup IAM role permissions as well.\n\nAnd that's it. This is your \"ready for production\" environment. The last thing you have to do is just write the Lambda function for the chatbot. Easy...\n\n# Chatbot AWS Lambda function\n\nSince we are using so called `lambda-proxy` integration you have to take care of the inputs and outputs in your code on your own. But it's recommended and you should definitely do that.\n\n```javascript\nexport async function handler(\n  event: Object,\n  context: ?Object,\n  callback: (error: null, success: Object) => void,\n) {\n  // error handling and so on...\n\n  callback(null, {\n    statusCode: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*', // manual CORS (because of lambda-proxy)\n    },\n    body: JSON.stringify({\n      response: \"Sorry, I didn't understand your question. Say that again?\",\n    }),\n  });\n}\n```\n\nNow, for me, this was always so confusing. It's because you hear - just run the function on AWS Lambda. But what does it mean? You have your shiny program full of classes and files and not only one function to run. Well, this is why you have Webpack right? You just inline everything into one file with all the mangling and uglifying and you are almost ready. The last thing is to expose your program via one handler and for AWS Lambda it should be in form of CommonJS (Webpack fragment):\n\n```javascript\noutput: {\n  path: path.resolve(appDirectory, 'dist'),\n  filename: '[name].js',\n  libraryTarget: \"commonjs2\",\n},\n```\n\nAnd that's it. This is how we do serverless (not only for chatbot). You should definitely try it if you are courageous enough.","frontmatter":"id: 2151f134-7f0e-43c0-8382-eab9d336b7ee\ntimestamp: 1500731161000\ntitle: How do we do serverless?\nslug: how-do-we-do-serverless"},{"attributes":{"id":"ce9721e7-697b-4834-bb4c-89977f1b8399","timestamp":1497708814000,"title":"Get rid of GraphQLNonNull","slug":"get-rid-of-graphqlnonnull"},"body":"I mean not all of the occurrences but at least in GraphQL fields. This is exactly what we did in [Kiwi.com](https://www.kiwi.com/us/) while working on GraphQL API.\n\nThis idea didn't come out of nowhere. Actually, I've been thinking about it for a while but after [GraphQL-Europe](https://graphql-europe.org/) I have been convinced (unfortunately I haven't been there personally). But you may ask why? Why would I do that?\n\nThere are several reasons for it. Firstly it's prepared for the future (in terms of backward compatibility). This means that if you want to make field non-nullable you can do it anytime you want. But you cannot do the same thing vice versa because it's huge BC break for consumers of your API.\n\nBut more importantly, it has a more practical reason. As you probably know the graph in GraphQL consists of a lot of complicated paths and leaves. And every leaf can have different resolver function. In extreme situation, each resolver may be some kind of microservice and this microservice may fail unexpectedly. It's very wrong to let the whole node of the graph fail. And that's exactly what happens if you don't satisfy the non-null rule.\n\nFor example, let's run this query:\n\n```graphql\n{\n  allLocations(term: \"PRG\") {\n    edges {\n      node {\n        locationId\n        name\n      }\n      cursor\n    }\n  }\n}\n```\n\nThis query returns an array of all locations related to the search term sorted starting with the best result:\n\n```javascript\n{\n  \"data\": {\n    \"allLocations\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"type\": \"airport\",\n            \"name\": \"Václav Havel Airport Prague\"\n          },\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjA=\"\n        },\n        {\n          \"node\": {\n            \"type\": \"city\",\n            \"name\": \"Prague\"\n          },\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjE=\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\nNow let's say that the field `name` is required (means non-nullable). Therefore server MUST return this field. But what happens if resolver for this field for some reason fails?\n\n```javascript\n{\n  \"data\": {\n    \"allLocations\": {\n      \"edges\": [\n        {\n          \"node\": null,\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjA=\"\n        },\n        {\n          \"node\": null,\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjE=\"\n        }\n      ]\n    }\n  },\n  \"errors\": [\n    {\n      \"message\": \"Cannot return null for non-nullable field Location.name.\",\n      \"locations\": ...,\n      \"path\": ...\n    },\n    ...\n  ]\n}\n```\n\nThis is not very nice. Especially if we know that the `type` field did not fail. This is why we prefer to write all fields as nullable. The result is much better in this case:\n\n\n```javascript\n{\n  \"data\": {\n    \"allLocations\": {\n      \"edges\": [\n        {\n          \"node\": {\n            \"type\": \"airport\",\n            \"name\": null\n          },\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjA=\"\n        },\n        {\n          \"node\": {\n            \"type\": \"city\",\n            \"name\": null\n          },\n          \"cursor\": \"YXJyYXljb25uZWN0aW9uOjE=\"\n        }\n      ]\n    }\n  }\n}\n```\n\nEven though it failed we still got as much as possible in the response. And that's way better. It's a responsibility of the customer (means implementer) to take into account that every field is nullable while implementing GraphQL API.\n\nIt worth to mention that there are very good use cases of `GraphQLNonNull`. For example, you want to make fields required (non-nullable) for input arguments and for `GraphQLInputObjectType`. So from this point of view, the title of this article should be \"Get rid of GraphQLNonNull in output types\"... :)\n\nIf you want to know more about this topic, I recommend you to read this thread on GitHub: https://github.com/facebook/graphql/issues/63. There is a lot of good arguments directly from creators of GraphQL and Facebook engineers.\n\nAfter converting your mind to this new approach it should be quite easy to write eslint rule for this (or whatever lint are you using). So far it really worth it.","frontmatter":"id: ce9721e7-697b-4834-bb4c-89977f1b8399\ntimestamp: 1497708814000\ntitle: Get rid of GraphQLNonNull\nslug: get-rid-of-graphqlnonnull"},{"attributes":{"id":"6952eca3-3942-4bfa-b68e-432772912eca","timestamp":1490538013000,"title":"React + Redux - Apollo =  FapFap","slug":"react-redux-apollo-fapfap"},"body":"Na konci minulého roku jsem začal něco jako virtuální seriál o React vs. PHP aplikaci. Včera jsem na Poslední sobotě byl upozorněn na to, že už asi nepokračuju. To není pravda - pouze jsem je přestal číslovat... :) Po [GraphQL](2-graphql), vyřešení [N+1 problému](reseni-n-1-problemu-v-graphql), [architektuře serverové části](hexagonalni-architektura) a [omezení CSS kontextu](jak-na-lokalni-css-pro-react) v React komponentách je čas podívat se podrobněji na komunikaci se serverem.\n\nVe výsledku jsem hodně rád, že jsem to tak oddaloval, protože jsem to asi tak třikrát celé předělával a konečně mám radost z toho jak to vypadá. Veškeré kódy týkající se [frontendu](https://github.com/adeira/connector-frontend) i [backendu](https://github.com/adeira/connector) jsou jako vždy k dispozici online pod MIT.\n\n# Klientské komponenty\n\nAž do nedávné chvíle jsem na straně webového prohlížeče používal pro komunikaci se serverem knihovnu Apollo. Interně Apollo využívá Redux store a já začal hodně vážně zvažovat, že začnu Redux store využívat mnohem více. V tu chvíli už nedávalo moc velký smysl používat Apollo a přišlo mi zajímavější starat se o Redux store sám.\n\nDříve jsem Apollo používal tak, že existovala vždy nějaká nadřazená komponenta, která se dotazovala serveru a předávala data jiné komponentě. Takže jsem měl komponenty, kterým se říká kontejnery (pouze tahají data) a předávají data pro vykreslení tzv. prezentačním komponentám (pouze vykreslují, ale netahají data).\n\nMyšlenka kontejnerů a prezentačních komponent pořád zůstává. Rozdíl je teď v tom, že místo toho, aby kontejner získával data prostřednictvím Apolla, tak je připojen k Redux úložišti a v okamžiku připojení komponenty do DOMu se spustí Redux akce pro načtení dat:\n\n```javascript\nexport const AllCamerasContainer = class extends React.Component {\n\n  componentWillMount() {\n    this.props.dispatch(loadAllCameras());\n  }\n\n  render = () => { /* ... */ }\n\n};\n\nexport default connect()(AllCamerasContainer);\n```\n\nFunkce `this.props.dispatch` je k dispozici díky nadřazené komponentě, která se vytváří pripojením k Redux úložišti pomocí `connect()`.\n\nRedux funguje tak, že se pomocí funkce `dispatch` vyvolá nějaká akce/příkaz (zde načtení všech kamer), ta prolítne reducerama což jsou úplně obyčejné funkce, které umí měnit podobu stavu Redux úložiště a následně se tento nový stav uloží a komponenta se automaticky překreslí. Důležité je, že Redux si vlastně drží stav všech komponent u sebe v jednom velkém globálním úložišti a akce resp. reducery slouží pro alespoň trošku rozumné ovládání jeho obsahu. Zároveň Redux úložiště nemá z hlediska kódu **nic společného s Reactem**. Redux je ke komponentě nějak napojen, ale může fungovat úplně bez Reactu.\n\nFunkce `loadAllCameras` slouží pro vytvoření objektu reprezentující nějakou akci. Ta se potom spouští pomocí `dispatch`. Akce je obyčejný JS objekt, který si nese informaci o typu akce + nějaká další dodatečná data. Pokud však chci data teprve načíst, je nutné vytvářet místo objektu funkci, která tak učiní:\n\n```javascript\n// relies on Redux Thunk middleware\nexport const loadAllCameras = () => {\n  return dispatch => {\n\n    dispatch({ // spuštění akce (což je jen obyčejný objekt) uvnitř jiné akce\n      type: ALL_CAMERAS_LOADING,\n    });\n\n    fetch(allCamerasQuery).then(({data}) => { // funkce pro získání dat (kvůli tomu je nutný Thunk)\n\n      dispatch({ // opět jen obyčejná akce spuštěná uvnitř jiné akce\n        type: ALL_CAMERAS_LOAD_SUCCESS,\n        cameras: data.allCameras,\n      });\n\n    });\n  }\n};\n```\n\nZde začíná být vidět důvod, proč jsem opustil Apollo. Díky tomu, že mám teď v ruce veškeré akce a reducery, tak mohu pohodlně spouštět a řetězit akce jak se mi zachce. Až Redux spustí tuto akci (resp. [Redux Thunk](https://github.com/gaearon/redux-thunk)), tak si jen najde ten správný reducer (podle typu `ALL_CAMERAS_LOADING` resp. `ALL_CAMERAS_LOAD_SUCCESS`), ten upraví obsah Redux úložiště a protože máme deklarativní React, tak se data automaticky překreslí.\n\n# Server Fetcher\n\nV předchozí akci bylo vidět, že se volá funkce `fetch`. To je úplně jednoduchá funkce, která pošle na server GraphQL dotaz a vrátí odpověď (resp. Promise). Vlastně dělá jen to, že pomocí [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch) položí dotaz ve správném formátu:\n\n```javascript\nreturn fetch(config.apiAddress, {\n  method: 'POST',\n  body: JSON.stringify({\n    query: graphQuery, // přichází jako argument fetcheru\n    variables: variables, // dtto\n    operationName: operationName // dtto\n  }),\n  headers\n}).then(response => response.json())\n  .then(json => {\n    return json; // zde budou příchozí data z API\n  });\n```\n\nPoskládat potřebné hlavičky je otázkou několika málo sekund:\n\n```javascript\nlet headers = {\n  Accept: '*/*',\n  'Content-Type': 'application/json'\n};\nlet token = Authenticator.getToken(); // localStorage\nif (token !== null) {\n  headers.authorization = token;\n}\n```\n\nAsi by bylo možné vracet rovnou pole `data`, které GraphQL API vrací, aby nebylo nutné dělat destructing v akcích, ale to už jsou jen kosmetické detaily.\n\nTeď by tedy mělo být zřejmé následující:\n- v Reactu existují kontejnery, což jsou komponenty, které **tahají data**\n- existují také prezentační komponenty, které **jen vykreslují data** podle `props`\n- kontejnery získávají data z Redux úložiště spuštěním akce při připojování kontejneru do DOMu (`componentWillMount`)\n- součástí spuštění akce může být načtení těchto dat do úložiště (pokud tam již nejsou)\n- na server se požadavky posílají jako jednoduchý POST s tělem obsahujícím GraphQL dotaz\n- souběžně s tělem POST požadavku je nutné odeslat také autorizační hlavičky (pokud to aplikace vyžaduje)\nOK? Možná to bylo rychlé, ale [mrkněte na kód](https://github.com/adeira/connector-frontend) a popř. si to vyzkoušejte. Nic složitého... :)\n\n# Přijetí požadavku na PHP serveru\n\nDostáváme se do oblasti, ve které [se vypastí](https://forum.nette.org/cs/28370-data-z-post-request-body-reactjs-appka-se-po-ceste-do-php-ztrati) překvapivě hodně lidí. Na straně serveru je třeba přistupovat k POST datům [trošku jinak](https://github.com/adeira/connector/blob/c501227a4429dba493624ca9fa85745fb5f1839c/instances/Connector/Infrastructure/Delivery/Http/GraphqlEndpoint.php#L62), než by mohlo být zřejmé. K této trošce teorie bude potřeba následující PHP kód:\n\n```php\n<?php\n\nvar_dump(\n  $_POST,\n  file_get_contents('php://input')\n);\n```\n\nCo se stane, pokud odešleme POST požadavek obsahující JSON třeba pomocí konzole v prohlížeči?\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"test.php\", true);\nxhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\nxhr.send(\"{a:'b'}\");\n```\n\nVrátí se tato odpoveď:\n\n```\narray(1) {\n  [\"{a:'b'}\"]=>\n  string(0) \"\"\n}\nstring(7) \"{a:'b'}\"\n```\n\nObsah `$_POST` pole může být zvláštní, ale s tím by se dalo žít. Vzhledem k tomu, že se požadavek posílá jako formulář, tak se očekává trošku jiný formát dat:\n\n```javascript\nxhr.send(\"a=1&b=2\");\n```\n\nV tomto případě pole pěkně expanduje:\n\n```\narray(2) {\n  [\"a\"]=>\n  string(1) \"1\"\n  [\"b\"]=>\n  string(1) \"2\"\n}\nstring(7) \"a=1&b=2\"\n```\n\nCo se však stane, pokud změníme hlavičku požadavku `Content-Type`?\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"test.php\", true);\nxhr.setRequestHeader(\"Content-Type\", \"application/json; charset=UTF-8\");\nxhr.send(\"a=1&b=2\");\n```\n\nPOST pole bude zcela prázdné! (nikoliv však `php://input`)\n\n```\narray(0) {\n}\nstring(7) \"a=1&b=2\"\n```\n\nJak je totiž psáno v dokumentaci, tak `$_POST` neobsahuje všechna data, která jsou na server odeslána jako POST, nýbrž:\n\n> An associative array of variables passed to the current script via the HTTP POST method **when using application/x-www-form-urlencoded or multipart/form-data as the HTTP Content-Type** in the request.\n\nDruhá polovina věty je extrémně důležitá. Také je z předchozích ukázek vidět, že jediné místo, kde jsou data k dispozici je právě input stream `php://input`. Z toho důvodu je na serveru k JSON datům nutné přistupovat rovnou přímo pomocí `file_get_contents('php://input')` (tak to dělá vnitřně `Nette/Http/RequestFactory`) nebo pomocí `$httpRequest->getRawBody()`, což je úplně to samé, jen více schované a více objektové.\n\nNyní již stačí pouze ověřit uživatele, jestli se může API vůbec ptát, získat JSON, rozparsovat dotaz a poslat jej nějaké GraphQL knihovně ať se postará o všechny strasti tohoto API. Vše je vidět v tomto jednoduchém [GraphQL endpointu](https://github.com/adeira/connector/blob/c501227a4429dba493624ca9fa85745fb5f1839c/instances/Connector/Infrastructure/Delivery/Http/GraphqlEndpoint.php).\n\nKdyby někdo prahnul po pořádné náloži uceleného textu, tak je možné sledovat [tento soubor](https://github.com/mrtnzlml/dp-latex/blob/master/main.pdf) (stále rozdělaný), který jednou začas trošku povyroste. Nějaké základní znalosti problematicky jsou nutné, ale použitý jazyk by měl být srozumitelný většině lidí. Připomínky jsou vítány, než bude pozdě... :)","frontmatter":"id: 6952eca3-3942-4bfa-b68e-432772912eca\ntimestamp: 1490538013000\ntitle: React + Redux - Apollo =  FapFap\nslug: react-redux-apollo-fapfap"},{"attributes":{"id":"112c84ae-680a-4d72-8aa3-96e8efeb8f1d","timestamp":1488119652000,"title":"Jak na lokální CSS pro React","slug":"jak-na-lokalni-css-pro-react"},"body":"Když jsem opouštěl koncept [webových komponent](1-od-komponent-zpet-ke-komponentam) a přecházel jsem k Reactu, tak mě nejvíce mrzelo, že přijdu o všechny zajímavé vlastnosti shadow DOMu. Ve webových komponentách se to má tak, že jak JS tak CSS jsou součástí jedné šablony a neovlivňují globální prostor. To je u Reactu bez problému z pohledu JS. Z pohledu CSS je to však jiná pohádka. Jakýkoliv styl definovaný v rámci komponenty se definuje pro celou aplikaci. Příklad jednoduché hlavičky:\n\n```js\nimport React from 'react';\nimport './Header.css';\n\nexport default () =>\n  <div className=\"header\">\n\t  {/* další JSX hlavičky */}\n  </div>\n```\n\nKdy CSS soubor obsahuje styly pro header:\n\n```css\n.header {\n  /* nějaké ty styly */\n}\n```\n\nDíky Webpacku je možné takto načítat CSS styly v komponentě, ale `.header` je k dispozici v celé aplikaci (pokud je tam komponenta použita). Pak ale komponenty trošku postrádají smysl a mohl bych to klidně zase patlat v jednom hlavním CSS souboru. Vlastně jsem vůbec nic nezískal a musím si dávat velký pozor na to, co dělám.\n\nNaštěstí existuje jednoduché řešení a tím jsou [CSS moduly](https://github.com/css-modules/css-modules). Stačí pouze trošku změnit Webpack nastavení a chování CSS se kompletně změní. Zatímco původní nastavení bylo takové:\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        loader: 'style-loader!css-loader?importLoaders=1!postcss-loader'\n      }\n    ]\n  }\n}\n```\n\nTak nové bude vypadat takto:\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          {\n            loader: 'style-loader'\n          },\n          {\n            loader: 'css-loader',\n            options: {\n              importLoaders: 1,\n              modules: true, // Enable/Disable CSS Modules\n              localIdentName: '[name]__[local]--[hash:base64:5]',\n            }\n          },\n          {\n            loader: 'postcss-loader'\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nJe to vlastně ta samá konfigurace, jen jsem zapnul CSS moduly. Od této chvíle se veškeré CSS chovají lokálně pouze pro danou komponentu. Je třeba jen upravit použití těchto nových stylů v komponentě:\n\n```js\nimport React from 'react';\nimport styles from './Header.css';\n\nexport default () =>\n  <div className={styles.header}>\n\t  {/* další JSX hlavičky */}\n  </div>\n```\n\nCo se stane s výstupem? Místo CSS třídy se budou generovat (+-) unikátní idenfikátory (s nějakou nápovědou pro development):\n\n```html\n<div class=\"Header__header--3dxwh\">\n  <!-- další HTML hlavičky -->\n</div>\n```\n\nResp. na produkci kde není nastaveno `localIdentName` takto:\n\n```html\n<div class=\"_3dxwhqIVz2ZHHrfQ6crpKp\">\n  <!-- další HTML hlavičky -->\n</div>\n```\n\nTím se zajistí, že CSS bude fungovat jen v rámci jedné komponenty. Jenže to není úplně ultimátní řešení. Některé styly je dobré mít dostupné v celé aplikaci. No tak třeba styly základních HTML elementů jsou stále definovány jako globální. Pokud však potřebujeme nějakou CSS třídu, tak je to možné pomocí `:global` prefixu:\n\n```css\n:global .clearfix:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n:global .wrapper--fluid {\n  margin-left: 5rem;\n  margin-right: 5rem;\n}\n```\n\nAčkoliv je z tohoto útržku vidět pozůstatek BEM zápisu, tak už to prakticky není potřeba.\n\nPodívejte se, jak vypadá [taková změna](https://github.com/adeira/connector-frontend/commit/e3106bd84952da4350af0d9a9329a3f747724571) v jednom commitu. To řekne více než 1000 slov... :)","frontmatter":"id: 112c84ae-680a-4d72-8aa3-96e8efeb8f1d\ntimestamp: 1488119652000\ntitle: Jak na lokální CSS pro React\nslug: jak-na-lokalni-css-pro-react"},{"attributes":{"id":"ad9d4e96-b786-4f75-a6ca-96c85746cef7","timestamp":1488109164000,"title":"4 způsoby práce s formulářem v šabloně","slug":"4-zpusoby-prace-s-formularem"},"body":"Velká část článků na tomto blogu jsou reakcí na nějaký reálný problém. Nehledě na to, kde jsem (třeba na včerejším [React workshopu](http://blog.id-sign.com/react-workshop/)), tak odpovídám na dotazy ohledně Nette. Je to v pořádku, rád pomůžu. Jsou však dotazy, které se neustále opakují. Toto je jeden z nich:\n\n> Formuláře v Nette jsou strašný voser. Jak to dělat lépe?\n\nVětšinou takto vágně to vždy začíná. Následuje stejné kolečko - vysvětlím proč se to tak dělá, popíšu jiný přístup k formulářům, tazatel je spokojen, podívám se do dokumentace, že to tam opravdu je a čekám na další stejný dotaz. Proto si teď dovolím vyzdvihnout nad rámec dokumentace několik základních způsobů, jak s formuláři v Nette pracovat.\n\n# První způsob - líný Ota\n\nTento způsob zná asi úplně každý. Pro superrychlé vytvoření formuláře jej stačí nadefinovat v presenteru nějak takto:\n\n```php\nprotected function createComponentComplicatedForm(): \\Nette\\Application\\UI\\Form\n{\n  $form = new \\Nette\\Application\\UI\\Form;\n  $form->addSelect('selectNo1', NULL, ['Item 1', 'Item 2']);\n  $form->addSubmit('send', 'Odeslat');\n  $form->onSuccess[] = function (\\Nette\\Application\\UI\\Form $form, \\stdClass $values) {\n    bdump($values);\n    throw new \\Nette\\NotImplementedException;\n  };\n  return $form;\n}\n```\n\nA použít v příslušné šabloně pomocí `control` makra:\n\n```\n{control complicatedForm}\n```\n\nJe to velmi jednoduché řešení a prakticky se zase až tolik nepoužívá. Většina lidí přijde poměrně rychle na to, že potřebují daleko větší flexibilitu, kterou nabízí další způsob v pořadí. Podívejme se však co se děje když se takový formulář odešle. Plyne z toho totiž jedna důležitá vlastnost, na kterou bude potřeba myslet později.\n\nFormulář se odesílá jako takový zvláštní signál s těmito POST daty:\n\n```\nselectNo1=0&send=Odeslat&_do=complicatedForm-submit\n```\n\nV průběhu životního cyklu presenteru (před `beforeRender`) dojde ke zpracování tohoto signálu. Konkrétně se nad formulářem zavolá metoda `signalReceived` resp. v případě formuláře `fireEvents`. Poměrně záhy se zavolají základní validace všech formulářových prvků. Schválně jsem v příkladu zvolil select, protože je na něm hezky vidět, že kontroluje co uživatel odeslal v selectu za hodnoty. Pokud je odeslaná hodnota k dispozici v předem nadefinovaném formuláři, tak se vybere. Co se stane pokud uživatel (záškodník) odešle něco jiného?\n\n```\nselectNo1=666&send=Odeslat&_do=complicatedForm-submit\n```\n\nV tomto případě metoda `getValue` vrátí hodnotu `NULL` a validace takového formuláře nebude úspěšná. To vyústí v chybovou hlášku `Please select a valid option.` - automaticky. Asi známá vlastnost a do chvíle než řeknu jinak bude platit.\n\n# Druhý způsob - nešťastný Karel\n\nZde se většina lidí zasekne a nádává. Protože vykreslování formuláře je v předchozím případě moc kostrbatá a vlastní PHP rendery nejsou moc nápomocné, přistoupíme k ručnímu vykreslování (místo `control` makra):\n\n```\n{form complicatedForm}\n  {input send}\n{/form}\n```\n\nUž tady si většina lidí alespoň jednou vyláme zuby (já to dělám pravidelně). Předchozí kód totiž **nebude fungovat**. Formulář se ke vší smůle sice odešle, ale neudělá vůbec nic. Pro správné fungování je nutné vykreslit všechny formulářové prvky:\n\n```\n{form complicatedForm}\n  {input selectNo1}\n  {input send}\n{/form}\n```\n\nProč? Co se děje? Tato definice formuláře totiž není správná. Nette ví, že má být ve formuláři select a má mít nějaké hodnoty, ale ty hodnoty nesedí s tím, co bylo odesláno (pamatujete?). Interně se skutečně vyhodí chyba `Please select a valid option.`, ale tu nikde nevykreslujeme, takže se zdá, že to prostě nefunguje. No fakt, vyzkoušejte si to:\n\n```html\n{form complicatedForm}\n  <ul class=\"errors\" n:if=\"$form->hasErrors()\">\n    <li n:foreach=\"$form->errors as $error\">{$error}</li>\n  </ul>\n  {*{input selectNo1}*}\n  {input send}\n{/form}\n```\n\nNa to je třeba dávat velký bacha. Tento způsob je dostatečný snad pro všechno co je potřeba. Prakticky je však nevhodný...\n\n# Třetí způsob - kodérka Silvie\n\nJe velká škoda, že o tomto způsobu neví spousta lidí co potkávám. Kodér většinou vymyslí nádhernou šablonu s formulářem (s mnohem komplikovanějším než je tento):\n\n```html\n<form action=\"\" method=\"post\" id=\"myAwesomeFormId\">\n  <select name=\"selectNo1\" id=\"myAwesomeSelectId\">\n    <option value=\"0\" selected=\"true\">Item 1</option>\n    <option value=\"1\">Item 2</option>\n  </select>\n  <input type=\"submit\" name=\"send\" value=\"Odeslat\">\n</form>\n```\n\nTeď se ale dostávám do problému, protože mám krásný formulář a měl bych jej zachovat. Mám však také jeho PHP definici a teď bych to potřeboval nějak naroubovat. Zde se stávají ty osudové chyby, kvůli kterým každý nadává - začne přepisování do druhého způsobu a hackování všeho co si kodér vymyslel. Když to dobře dopadne, tak bude formulář vypadat snad stejně jako vypadal původně. Snad...\n\nTo je ale zbytečné. Existuje lepší způsob pomocí `n:name` makra v Latte. Skutečně formulář pouze naroubujeme na ten v PHP a smažeme nepotřebné věci:\n\n```html\n<form n:name=\"complicatedForm\" id=\"myAwesomeFormId\">\n  <select n:name=\"selectNo1\" id=\"myAwesomeSelectId\"/>\n  <input n:name=\"send\"/>\n</form>\n```\n\nFormulář funguje pořád stejně, ale dokonce se i zjednodušil! No nicméně asi je z toho cítit, že pořád je na straně PHP dost práce (vlastně vešká potřebná zodpovědnost) a svoboda v šabloně je jen částečná. Zde přichází ke slovu poslední způsob.\n\n# Čtvrtý způsob - bláznivý Joe\n\nVšechno dříve zmíněné se mi nemusí líbit. Kašlu na nějaké definice v PHP, kašlu na automatické kontroly. Chci prostě vzít formulář od kodéra, odeslat ho a sám si ho zpracovat. Je to tak těžké pochopit?! Není milý Joe. Co to udělat takto - začněme s naroubouváním formuláře (ale jen fomuláře!):\n\n```html\n<form n:name=complicatedForm id=\"myAwesomeFormId\">\n  <select name=\"selectNo1\" id=\"myAwesomeSelectId\">\n    <option value=\"0\" selected=\"true\">Item 1</option>\n    <option value=\"1\">Item 2</option>\n  </select>\n  <input type=\"submit\" name=\"send\" value=\"Odeslat\">\n</form>\n```\n\nTím se zajistí, že se fomulář odešle na tu správnou adresu tou správnou metodou. Jinak jinak jsem do formuláře nezasáhl a je tedy úplně stejný, jako jej poslal kodér. Do puntíku. Veškerá data z formuláře jsou potom k dispozici zde:\n\n```php\nprotected function createComponentComplicatedForm(): \\Nette\\Application\\UI\\Form\n{\n  $form = new \\Nette\\Application\\UI\\Form;\n  $form->onSuccess[] = function (\\Nette\\Application\\UI\\Form $form) {\n    dump($form->getHttpData()); //ZDE\n  };\n  return $form;\n}\n```\n\nCo se stane, když záškodník odešle něco co by nemělo v selectu být (viz první příklad)? Přesně tak, prostě se to odešle a na serveru to přistane. Veškerá kontrola je tedy na programátorovi. K samotné hodnotě selectu je možno přistouput takto:\n\n```php\n$form->getHttpData($form::DATA_LINE, 'selectNo1')\n```\n\nTo `DATA_LINE` je vhodné pro jednořádkové vstupy, protože se na pozadí provede následující ošetření:\n\n```php\n\\Nette\\Utils\\Strings::trim(strtr($value, \"\\r\n\", '  '))\n```\n\nPořád ale platí, že může přijít ze selectu nečekaná hodnota a nelze ničemu věřit. Jedná se však o naprosto svobodný způsob, který je možné kombinovat s předchozím. Pokud tedy máte _\"neskutečně složitý formulář\"_, který je _\"už nakódovaný\"_ a jeho definice _\"má asi 500 řádek\"_ a je to _\"tak komplikované, že se v tom nikdo nevyzná\"_ a bylo by _\"lepší, kdybych si to mohl udělat sám\"_, tak vězte, že to jde.\n\n# Časté dotazy\n\n- Použil jsi to někdy ve skutečnosti? Ano.\n- Je tam nějaký problém o kterém bych měl vědět? Krom již zmiňovaného nevím o žádném. Je to prostě růčo fůčo...\n- Proč to není v dokumentaci? [Je to tam.](https://doc.nette.org/en/2.4/forms#toc-manual-rendering)\n- Proč není ten poslední způsob v dokumentaci? [Je to tam.](https://doc.nette.org/en/2.4/forms#toc-low-level-forms)\n- Tak to tedy není v české verzi! I tam [to](https://doc.nette.org/cs/2.4/forms#toc-low-level-formulare) obojí [je](https://doc.nette.org/cs/2.4/forms#toc-manualni-vykreslovani)\n- Tak to tam dřív nebylo. Je to tam [od verze 2.1](https://doc.nette.org/cs/2.1/forms), kdy se tato možnost objevila.\n- I ve staré EN verzi? [Ano](https://doc.nette.org/en/2.1/forms)\n- Šlo by to udělat i bez `getHttpData`? Ano, ale už v tom nevidím moc velký smysl.\n- Proč? To už bych mohl rovnou pracovat s `$_POST`, ale tato metoda mě pěkně odstíní a [ošetří celou řadu potřebných věcí](https://api.nette.org/2.4/source-Forms.Form.php.html#385-403).\n- Ale ve _{$frameworkName}_ se to dělá jinak a lépe! Použij tedy _{$frameworkName}_ nebo jeho podčást.\n\n:)","frontmatter":"id: ad9d4e96-b786-4f75-a6ca-96c85746cef7\ntimestamp: 1488109164000\ntitle: 4 způsoby práce s formulářem v šabloně\nslug: 4-zpusoby-prace-s-formularem"},{"attributes":{"id":"97b1917b-d6ed-4305-a543-3bdde9b298c9","timestamp":1487322556000,"title":"Hexagonální architektura","slug":"hexagonalni-architektura"},"body":"Struktura webových aplikací je něco, co se neustále mění a stejně s programátorem i zdokonaluje. Před více než rokem jsem se o jedné z možných struktur PHP aplikace [trošku rozepsal](jeste-lepsi-struktura-nette-aplikace). A teď si ukážeme další alternativu, která je [k proklikání zde](https://github.com/adeira/connector/tree/2169296c8da4a50bf4f928e94e756f3b23afea24). Nejedná se o nic převratného. Tento přístup mě však v poslední době hodně baví a dá se na něm naučit zase něco nového. Jedná se vlastně o tento adresářový strom (zjednodušeně):\n\n```\n.\n├── bin/            ...  pomocné SH skripty\n├── config/         ...  globální konfigurace aplikace\n├── migrations/     ...  dopředné DB migrace\n├── src/\n├── tests/          ...  veškeré testy\n├── var/            ...  logy a temp\n├── vendor/         ...  balíčky třetích stran\n├── www/            ...  veřejná složka\n├── bootstrap.php   ...  vytváření DI kontejneru\n├── composer.json   ...  definice závislostí třetích stran\n├── composer.lock\n├── LICENSE.txt\n└── README.md\n```\n\nNa první pohled je asi vše jasné. Struktura je téměř identická s tím, co je běžné u začínajících Nette projektů (Nette zde však není vůbec důležité). Za povšimnutí stojí pouze to, že `bootstrap.php` a globální konfigurace jsou na úrovni kořenového adresáře, takže neexistuje žádná složka `app`. Zůstává tedy otázka - kde jsou veškeré kódy a jak je aplikace členěna?\n\n# Kontexty\n\nVeškerá zábava je právě ve složce `src` (jak se asi dalo čekat):\n\n```\nsrc/\n├── Authentication/\n├── Common/\n├── Devices/\n├── Endpoints/\n└── Routing/\n```\n\nOsobně mám pořád problém s pojmenováváním věcí, takže mám pořád takový pocit, že jednotlivé kontexty nejsou dobře zaškatulkované. To ale není zase až tak důležité. Důležitá je následující myšlenka: každá tato podsložka (kontext) se stará o úplně všechno. Od konfigurací, přes presentery až po business logiku. Uvnitř kontextu nejsou pouze balíčky třetích stran a testy (ty jsou v `tests`, ale mají úplně stejnou adresářovou strukturu - ne nutně soubory).\n\nJe třeba trošku se pozastavit nad konfigurací. Každý balíček si s stebou nese vlastní konfigurační soubory, které potřebuje k životu. Ty většinou velmi úzce souvisejí např. s konfigurací DI kontejneru. Ale pouze pro potřeby daného kontextu! Pokud je třeba tento balíček konfigurovat na globální úrovni celé aplikace, pak je tento balíček zaregistrován jako DI rozšíření. Tato úprava myšlení nad konfigurací je možná díky balíčku [adeira/compiler-extension](https://github.com/adeira/compiler-extension). Doporučuji alespoň přečíst a doufat, že to bude fungovat i v Nette 3 ([Proč by nemohlo?](https://github.com/nette/di/issues/143)).\n\nSamostatná interní konfigurace kontextu je asi to nejdůležitější pro pokračování (může být také pěkně [dlouhá a komplikovaná](https://github.com/adeira/connector/blob/2169296c8da4a50bf4f928e94e756f3b23afea24/src/Devices/Infrastructure/DI/Nette/config.neon)). Co obsahuje takový kontext (balíček)?\n\n```\nsrc/Devices/\n├── Application/\n│   ├── Exceptions/\n│   └── Service/\n├── DomainModel/\n│   └── WeatherStation/\n└── Infrastructure/\n    ├── Delivery/\n    ├── DI/\n    ├── DomainModel/\n    └── Persistence/\n```\n\nTo už je o něco zajímavější a také řádově komplikovanější na pochopení. Dále se totiž dělí aplikace na tři důležité části, kde každá má jiný význam a každá si tedy zaslouží krátký komentář. Začněme pěkně uprostřed.\n\n# Doménová vrstva\n\nV doménové vrstvě je pouze obyčejné PHP. Myšlenka je taková, že se zde budu soustředit pouze na návrh modelu v čistém PHP a nebudu to nijak komplikovat zanášením jakýchkoliv frameworků či jiných externích knihoven:\n\n```\nsrc/Devices/DomainModel/\n├── WeatherStation\n│   ├── IAllWeatherStationRecords.php\n│   ├── IFileLoader.php\n│   ├── WeatherStationId.php\n│   ├── WeatherStation.php\n├── Humidity.php\n├── PhysicalQuantities.php\n├── Pressure.php\n├── Temperature.php\n└── Wind.php\n```\n\nNikde zde nenajdete v kódu slovo Nette, Symfony nebo třeba Doctrine (_ve skutečnosti to tam je, ale to je chyba_). Jsou to prostě úplně obyčejné objekty, které mají za úkol řešit nějaký konkrétní problém onoho konkrétního kontextu a nic víc. Díky tomu je psaní testů na tuto část aplikace naprosto triviální. Když někde existuje nějaká závislost, tak je zprostředkována pomocí rozhraní, takže vyměnit implementaci v testech je díky tomuto striktnímu rozdělení opravdu hračka.\n\nTakto by však aplikace sama o sobě nefungovala. Je potřeba mít zde vazbu na konkrétní implementaci, na konkrétní framework či knihovnu. Od toho slouží další vrstva.\n\n# Infrastrukturní vrstva\n\nZde není nic jiného, než implementace (implementační detaily). Většinou se jedná o třídy, které nemají žádnou zvláštní nebo složitou logiku. Slouží pouze jako napojení na framework a jako implementace rozhraní z domménové vrstvy. To se silně projeví ve struktuře:\n\n```\nsrc/Devices/Infrastructure/\n├── Delivery/\n│   ├── API/\n│   │   └── GraphQL/\n│   ├── Console/\n│   │   └── Symfony/\n│   └── Http/\n│       └── Nette/\n├── DI/\n│   └── Nette/\n│       ├── config.neon\n│       └── Extension.php\n├── DomainModel/\n│   └── WeatherStation/\n│       ├── Doctrine/\n│       └── Series/\n└── Persistence/\n    ├── Doctrine/\n    │   ├── Mapping/\n    │   └── DoctrineAllWeatherStations.php\n    └── InMemory/\n        └── InMemoryAllWeatherStations.php\n```\n\nTrošku se to komplike, že? Po chvilce studování to však dává celé smysl. Tak třeba `Delivery` - je potřeba doručit nějakou šablonu prostřednictvím presenteru, poslat JSON nebo komunikovat s CLI. Proto je zde vždy vazba na konkrétní technologii (o tom ostatně celá tato vrstva je). Podobně napojení na DI. Může se zdát, že to vždy bude Nette, ale pokud bych podobným stylem vydával i Composer knihovny, tak je jednoduché dodělat podporu i pro další frameworky - kód je na to připraven.\n\nAsi nejzajímavější je potom složka `Persistence`, která řeší ukládání dat _někam_. V mém případě je to primárně Doctrine, takže se zde musím hodně zasnažit, abych dokázal dříve vytvořené objekty uložit do databáze a přitom o tom žádný z těchto objektů netušil (občas dřina, ale všechno jde). Ale implementací může být více - třeba v obyčejné paměti PHP. Což je super strategie pro testování. V testech (pokud to není smyslem toho testu) nepotřebuji pracovat přímo s pomalou databází, takže nahradit její implementaci za ukládání do paměti bude super rychlé.\n\nZbývá poslední vrstva.\n\n# Aplikační vrstva\n\nMít takto myšlenkově oddělené závislosti jednotlivých částí aplikace má spoustu výhod. Důležité je zeptat se: jak budeme tento model ovládat? Odpovědí je právě aplikační vrstva. Ta má za úkol pouze jednu věc. Zpřístupnit doménovou vrstvu širokému okolí. Pokud tedy presenter chce komunikovat s doménovou vrstvou, musí prostřednictvím aplikační vrstvy. Proč musí? Nestačilo by rovnou používat nějaký interface pro repozitář? Stačilo, ale to není dobrý nápad!\n\nRovnou pracovat s repozitáři není rozumné, protože ty maximálně tahají data z úložiště. To je jejich zodpovědnost, ale co třeba oprávnění a transakce? O to se právě stará aplikační vrstva. Jako příklad budeme chtít vytvořit záznam pro novou meteostanici. Zde konkrétně využívám přístup CQS (Command-Query Separation). Zde existují dva způsoby jak komunikovat. Pomocí dotazů, kdy každý dotaz vrací požadovanou informaci, ale **nemodifikuje data** a pomocí příkazů, které data modifikují, ale **nevrací žádná data zpět**.\n\nTakový příklaz by se mohl jmenovat `CreateWeatherStation` a jedná se pouze o obyčejný DTO objekt, který nemá žádnou logiku a měl by být tak jednoduchý, že jej není třeba testovat (pokud nechcete). Je to fakt jenom přepravka na data. Tento příkaz má svého parťáka, který jej umí zpracovat. Příkaz odesílám pomocí sběrnice třeba z API:\n\n```php\n$this->commandBus->dispatch(new CreateWeatherStation(\n    WeatherStationId::create(), // ID nové stanice\n    $args['name'], // název stanice\n    $context->userId() // ID uživatele, který vytváří stanici\n));\n```\n\nTato sběrnice jednak doručí příkaz na to správné místo pro zpracování, ale také obstará databázové transakce, prokud je to nutné. Tento příkaz se zpracuje v `handleru`, který implementuje metodu `__invoke` (nebo cokoliv jiného co je `callable`):\n\n```php\npublic function __invoke(CreateWeatherStation $aCommand)\n{\n    $owner = $this->ownerService->existingOwner($aCommand->userId());\n\n    $this->weatherStationRepository->add(new WeatherStation(\n        $aCommand->stationId(),\n        $owner,\n        $aCommand->name(),\n        new \\DateTimeImmutable('now')\n    ));\n}\n```\n\nKouzlo je v tom, že je zde ukryta i kontrola ověření, protože na prvním řádku se snažím získat z uživatele vlastníka (jinak exception) a samotná meteostanice také chce v konstruktoru vlastníka (nikoliv jen uživatele). Kontrolu tedy nejde zapomenout. `weatherStationRepository` je zde opět jen interface. Jak je vidět, tak je zde hodně věcí na které se nesmí zapomenout a proto je rozumné přistupovat k doménovému modelu pouze přes tuto aplikační vrstvu.\n\nNa závěr nutno jednu drobnou poznámku. Tento přístup (hledejte pod názvem hexagonální architektura) mě moc baví a pořád je co se zde učit nového. Pokud však patříte do kategorie \"líný programátor\", pak pro vás tento přístup určitě není vhodný. Je to totiž spousta práce, která se může zdát jako zbytečná. Klidně se to vše nechá dělat jednoduše v jedné vrstvě. Hexagonální architektura však nabízí elegantní řešení problémů, které občas ve vývoji nastanou a myslím si, že hledí hodně vpřed. Doporučuji tedy alespoň jednou vyzkoušet a pokud nic jiného, tak si z toho alespoň odnést některé myšlenky, které člověka posunou zase o kousek dál... :)","frontmatter":"id: 97b1917b-d6ed-4305-a543-3bdde9b298c9\ntimestamp: 1487322556000\ntitle: Hexagonální architektura\nslug: hexagonalni-architektura"},{"attributes":{"id":"ad86363a-dc6d-4c7d-b334-a82424354134","timestamp":1485965763000,"title":"Řešení N+1 problému v GraphQL","slug":"reseni-n-1-problemu-v-graphql"},"body":"Na 85. Poslední sobotě v Praze jsem měl workshop a přednášku o GraphQL. Na konci přednášky padl velmi dobrý dotaz ohledně toho, jestli náhodou netrpí GraphQL v určitých situacích N+1 problémem. Načež jsem odvětil, že to není problém GraphQL, ale že ano. Teď je tedy ten správný čas podívat se na tuto situaci konkrétně a pokusit se ji vyřešit. Skvělé je, že [knihovna, kterou používám](http://webonyx.github.io/graphql-php/) na sebe částečně převzala řešení tohoto nešvaru. Ale o tom až za chvíli...\n\n# N+1 problém\n\nS [N+1 problémem](https://secure.phabricator.com/book/phabcontrib/article/n_plus_one/) se setkal každý, kdo naprogramoval alespoň blog s komentáři. Problém nastává pokud se z databáze netahají všechna potřebná data s předstihem. Například pokud u blogu vytáhneme pouze články a až později budeme iterovat články a tahat k nim komentáře, pak máme N+1 problém. Stane se totiž, že položíme na databázi stejný počet dotazů, jako máme článků.\n\nŘešit se to dá dvojím způsobem. Můžeme použít databázový `JOIN` a v jednom dotázu si vytáhnout vše potřebné (články a kometáře) s tím, že již víme co potřebujeme. A nebo použijeme `IN` klauzuli a druhým dotazem se doptáme na vše potřebné (zbývající komentáře). Tento přístup se pro GraphQL hodí více.\n\nHezký příklad tohoto problému je vidět na tomto GraphQL dotazu:\n\n```\n{\n  query_1: allWeatherStations {\n    edges {\n      node {\n        ...RecordsFragment\n      }\n    }\n  }\n  query_2: allWeatherStations {\n    weatherStations {\n      ...RecordsFragment\n    }\n  }\n}\n\nfragment RecordsFragment on WeatherStation {\n  records {\n    id\n  }\n}\n```\n\nToto by se dalo nazvat M*N+M problémem... :) Kdybych totiž posílal jen první dotaz (dej mi meteostanice a ke každé stanici všechny záznamy), vznikl by dříve popisovaný problém. Jen jsou zde místo článků meteostanice a místo komentářů jednotlivé záznamy stanic. Jenže v GraphQL lze skutečně složit graf a tak se můžu ptát velmi složitě a zamotaně. Dokonce se můžu ptát pořád dokolečka:\n\n```\n{\n  articles { # get all articles\n    authors { # get all authors of the articles\n      theirArticles { # get all articles they wrote\n        authors { # get authors of those articles\n          theirArticles {\n            ...\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nNeříkám, že to dává smysl, ale pokud je API dostatečně kompikované, tak se zde můžou objevit cyklické cesty.\n\n# Řešení\n\nPodívejme se, jak se tahají jednotlivé záznamy pro konkrétní meteostanici:\n\n```php\n$field->setResolveFunction(function (WeatherStation $ws, $args, UserId $userId) {\n    return $this->allWsRecords->execute($userId, $ws->id());\n});\n```\n\nSlovy řečeno: v callbacku přijde meteostanice a my se zeptáme nějaké modelové třídy na všechny záznamy podle ID meteostanice. To je přesně to místo, kde vzniká N+1 problém. V knihovně [webonyx/graphql-php](https://github.com/webonyx/graphql-php) je od verze `v0.9.0` k dispozici objekt `GraphQL\\Deferred`, který perfektně poslouží k optimalizaci:\n\n```php\n$field->setResolveFunction(function (WeatherStation $ws, $args, UserId $userId) {\n    $this->allWsRecords->buffer($ws->id());\n\n    return new \\GraphQL\\Deferred(function() use ($userId, $ws) {\n        return $this->allWsRecords->execute($userId, $ws->id());\n    });\n});\n```\n\nVtip je v tom, že při řešení dotazu prochází knihovna `webonyx/graphql-php` celý graf a zjišťuje potřebné hodnoty. Ve chvíli kdy dojde k našemu uzlu/listu, tak si jen poznamenáme (buffer) jaké ID bylo práve vyžadováno a vrátíme onen `Deferred` objekt. Až celý proces dojde na samotný konec, tak se knihovna zeptá ještě na ty odložené objekty. V tu chvíli ale již víme jaké všechny ID jsou potřeba a můžeme je získat jedním dotazem a postupně vracet:\n\n```php\nif(empty($this->weatherStationIdsBuffer)) {\n\treturn $this->wsrr->ofWeatherStationId($weatherStationId);\n} else {\n\tstatic $result = NULL; //memoization\n\tif ($result === NULL) {\n\t\t$result = $this->wsrr->ofAllWeatherStationIds($this->weatherStationIdsBuffer);\n\t}\n\treturn $result[$weatherStationId->id()];\n}\n```\n\nTedy pokud není nic v bufferu, prostě se na to jedno ID zeptáme do databáze. Zde není co optimalizovat. V opačném případě však pošleme dotaz s `IN` a zeptáme se na všechny ID, které jsou v bufferu. Ty budeme chvíli držet v lokální cache a postupně ven servírovat jednotlivé záznamy (bez dalších dotazů do databáze).\n\nVýsledek je následující (předtím):\n\n```sql\nSELECT t0.* FROM user_accounts t0 WHERE t0.id = ?\n\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\n\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\n```\n\nA potom:\n\n```sql\nSELECT t0.* FROM user_accounts t0 WHERE t0.id = ?\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id IN (\n    'df40acdd-5222-4f89-a693-999f2d3f3eb6',\n    '6f5fb680-f5e3-4d8c-b7e1-27205b848657',\n    '14837156-c662-4e8c-b527-2227506c2bf7',\n    '2965494d-d13f-4415-8535-b910ac29326a',\n    '662c0434-9eca-4241-9462-ce85d279fd6b',\n    '36eed5a8-08fd-48db-8153-67355d092201'\n)\n```\n\nTo je obrovské zlepšení. Zejména když si uvědomíte, že k optimalizaci N+1 dotazu nedochází pouze naivně v rámci jedné cesty v grafu, ale v rámci úplně celého grafu. Pokud chcete vidět konkrétní změnu v rámci projektu z workshopu, tak je vidět v commitu [ed8b43](https://github.com/adeira/connector/commit/ed8b43257b778b6b2d4adb1b92baae18daf36905).\n\nToliko má odpoveď... :)","frontmatter":"id: ad86363a-dc6d-4c7d-b334-a82424354134\ntimestamp: 1485965763000\ntitle: Řešení N+1 problému v GraphQL\nslug: reseni-n-1-problemu-v-graphql"},{"attributes":{"id":"5330469a-da65-4195-8c9a-2afccbd6078d","timestamp":1484849186000,"title":"Vy ještě nemáte svůj superprojekt?!","slug":"vy-jeste-nemate-svuj-superprojekt"},"body":"Nenechte se ošálit. Superprojekt je skutečně [oficiální název](https://git-scm.com/docs/git-submodule#git-submodule-add) pro Git projekty, které virtuálně obsahují další podprojekty (tzv. submoduly). Jedná se o skvělý způsob jak vytvořit jeden velký repozitář a spravovat v něm mnoho knihoven. Následující text proto bude zajímavý pro programátory, kteří vydávají knihovny podobně jako to dělám já s [projektem Adeira](https://github.com/adeira).\n\nZačněme však krátkou motivací. Tomuto způsobu vývoje resp. tomu jednomu konkrétnímu repozitáři se velmi často říká \"monolith repository\". Vývoj v jednom repozitáři by měl minimalizovat režii, která je nutná pro obskakování mnoha repozitářů. Důležité však je uvědomit si hned na začátku, že jeden monolitický repozitář rozhodně neznamená jeden monolitický kód. Pořád se bavíme o vydávání mnoha Composer balíčků (například), ale jejich údržba a vývoj probíhá v jednom okně jednoho IDE. Pouze finální produkt je množství dílčích repozitářů!\n\nVýhody jsou následující:\n- změny v API napříč celou knihovnou je možné dělat rovnou (nikoliv postupně balíček co balíček)\n- veškeré změny Git repozitáře lze vyřešit jedním šmahem (commit, push) a není tedy potřeba dělat to ručně postupně\n- tím, že se vše dělá na jednom místě, tak by vývoj měl být pružnější a jistější\n- perfektně se vyřeší vlastní závislosti - říkám dej mi `moje-knihovna`, nikoliv `moje-knihovna:v2.5.3`\n- celkově se celá monorepo obluda chová podobně jako jeden balíček, ale lze jej vydávat jako mnoho Composer balíčků\n- lze otestovat veškerý namespace (třeba `nette/*`) najednou\n\nChvíli jsem to zkoumal a existují dvě cesty jak takový repozitář vytvořit. Jedna horší a jedna lepší. Začnu tou (z mého pohledu) horší...\n\n# Split repozitáře\n\nToto bylo to první po čem jsem šel. Teorie zní následovně. Veškerý kód mám v jednom repozitáři (třeba `adeira/monorepo`) a normálně pracuji na kódu jak jsem zvyklý. Následně spustím nějaký program, který mi repozitář rozdělí pomocí Gitu na jednotlivé dílčí repozitáře. To lze udělat pomocí [subtree](https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt) nebo třeba pomocí [splitsh](https://github.com/splitsh/lite) (to používá Symfony).\n\nVýhody jsou zřejmé - dělám na jednom kódu a mám jeden repozitář. To je ostatně to jak jsem monolitický repozitář vydefinoval. Nevýhody už možná tak zřejmé nejsou - mám jen jeden repozitář. Pokud jste alespoň trošičku políbeni Gitem, tak si umíte asi představit, co to znamená pro vydávání nových verzí jednotlivých balíčků. V Gitu totiž nelze mít dva stejné tagy. A to znamená dvě věci: budu vydávat verze nějak strašně složitě, nebo budou mít všechny balíčky stejnou verzi.\n\nDruhým zmíněným způsobem to dělá Symfony a s veškerou otevřeností si myslím, že to není dobře. To totiž znamená, že budu vydávat verze ve kterých se **vůbec nic nezměnilo**. Nevěříte? Symfony to dělá běžně ([2.8.11...2.8.14](https://github.com/symfony/security-http/compare/v2.8.11...v2.8.14), [v2.8.5...v2.8.15](https://github.com/symfony/ldap/compare/v2.8.5...v2.8.15)). Když se nic nezměnilo, tak nemá smysl vydávat verzi (nebo?). Takto SemVer verzování nefunguje... Ale uvědomuji si, že jsou lidé, kteří toto budou obhajovat do morku kosti a že se jedná o můj subjektivní názor. Mnohem více mě trápí to, jak si subtree hraje s historií. Ačkoliv dokumentace tvrdí, že subtree vždy vrátí pro stejnou historii stejné výsledné SHA, tak z pokusů můžu potvrdit, že to není pravda (nezkoumal jsem dál proč). A to je hodně špatně - na všech repozitářích mám naštěstí zabezpečenou master větev, abych nemohl udělat force push. Lépe k tomu přistupuje Splitsh, který je navíc násobně rychlejší. Ten však zase neumí pracovat s historií, která byla pomocí subtree přidána. Možná znáte subsplit - to je ale jen obálka nad subtree (takže stejně pomalé).\n\nPokud tedy chcete vydávat balíčky kdy se bude často stávat, že má jeden commit několik tagů verzí a nemáte problém s tím, že je nutné pokaždé dopočítat diff z historie pro dílčí projekty, pak je pro vás split zřejmě ta správná volba. V opačném případě je tu varianta se superprojektem.\n\n# Superprojekt\n\nSuperprojekt na to jde úplně jinak. Využívá tzv. [submoduly](https://git-scm.com/docs/git-submodule) což není nic jiného než ukazatel na jiný **plnohodnotný** Git repozitář. Při této konfiguraci se superprojekt chová jako přepravka na tyto repozitáře. Přesně ví kde jsou a jak s nimi pracovat, ale nehraje si s jejich historií. Vzhledem k tomu, že je v submodulu plnohodnotný Git repozitář, tak mohu pracovat s tagy samostatně a vydávat tak verze samostatně. Není tedy třeba dělat žádné ústupky.\n\nSuperprojekt si drží informaci o submodulech v souboru `.gitmodules` jehož obsah vypadá takto (příklad z projektu [adeira/superproject](https://github.com/adeira/superproject)):\n\n```js\n[submodule \"Component/compiler-extension\"]\n\tpath = Component/compiler-extension\n\turl = git@github.com:adeira/compiler-extension.git\n[submodule \"Component/monolog\"]\n\tpath = Component/monolog\n\turl = git@github.com:adeira/monolog.git\n[submodule \"Component/code-quality\"]\n\tpath = Component/code-quality\n\turl = git@github.com:adeira/code-quality.git\n[submodule \"Component/workflow\"]\n\tpath = Component/workflow\n\turl = git@github.com:adeira/workflow.git\n[submodule \"Component/presenter-factory\"]\n\tpath = Component/presenter-factory\n\turl = git@github.com:adeira/presenter-factory.git\n```\n\nSkvelé je, že má Git vestavěnou podporu pro submoduly, takže to není nic přes ruku. Jen je třeba zapomenout na první část tohoto článku a začít o submodulech přemýšlet úplně jinak. Každý submodul má vlastní složku `.git` a je tedy nutné dělat commity v rámci každého submodulu zvlášť. Naštěstí PhpStorm umí udělat commit hromadně, takže pokud se provádí změna ve všech balíčcích, tak lze vše commitnout najednout. V superprojektu se commitují pouze složky, které obsahují submodul. Ty žijí v rámci Gitu ve speciálním módu `160000` který říká, že se jedná o složku, která ukazuje na konkrétní commit v konkrétním submodulu (jiném repozitáři). GitHub pak vytvoří takto hezké [symlinky do jiného repozitáře](https://github.com/adeira/superproject/tree/master/Component).\n\n> Pamatujte, že zdrojem pravdy je v superprojektu vždy submodul a ten existuje v konkrétním repozitáři! Nemáte tedy k dispozici monolitický repozitář, ale způsob jak ovládat mnoho repozitářů z jednoho místa. Pracovat s těmito repozitáři lze naprosto nezávisle na superprojektu a **nikdy se nedostanete do nekonzistentního stavu**.\n\nZdrojem pravdy jsou tedy cílové repozitáře, což je super, protože o to jde. Software vydávám jako samostatný balíček odkud si jej mohou uživatelé nebo Composer stáhnout. Zde jsou vlastní testy, readme i verze. Nemělo by se stát, že vydám rozbitou verzi, protože ji vydávám vždy nad konkrétním repoitářem, nikoliv nad monorepozitářem. Superprojekt se nemůže dostat do nekonzistence se submoduly, protože na ně jen ukazuje. To znamená, že neexistuje jeden kód na dvou místech (to třeba v Symfony není pravda).\n\nGit Push ze superprojektu je ideální spouštět s tímto přepínačem:\n\n```\ngit push --recurse-submodules=on-demand\n```\n\nV tomto případě se nejdříve odešlou na vzdálený server submoduly (jen pokud je to potřeba) a až následně se aktualizují ukazatele v superprojektu. O tom jak pracovat se submoduly existuje [dlouhatánský článek](https://git-scm.com/book/en/v2/Git-Tools-Submodules) - pokud chcete Git ovládat ještě více, tak doporučuji pročíst.\n\nOsobně jsem superprojekt dotlačil ještě o kousek dál. Teď už je jedno jestli se bavíme o \"split\" typu nebo \"super\" typu - bude to stejné. Všechny balíčky existují v nějaké složce a každý má vlastní Composer závislosti a vlastní testy. Zkombinoval jsem více přístupů jak obstarávat všechny závislosti a nejvíce se mi líbil zbůsob jakým to řeší [beberlei/composer-monorepo-plugin](https://github.com/beberlei/composer-monorepo-plugin). Dělám to tak, že jsem si vytvořil Composer příkaz:\n\n```\ncomposer adeira:collect\n```\n\nTento příkaz projde všechny submoduly a přečte si co mají napsáno v souboru `composer.json`. Následně vygeneruje v hlavním balíčku soubor `composer.json`, který obsahuje všechny požadavky (`require` i `require-dev`) ze submodulů. Podobně to udělá i s autoloadery. Navíc vygeneruje speciální sekci `replace` takto:\n\n```js\n\"replace\": {\n\t\"adeira/code-quality\": \"self.version\",\n\t\"adeira/compiler-extension\": \"self.version\",\n\t\"adeira/monolog\": \"self.version\",\n\t\"adeira/presenter-factory\": \"self.version\",\n\t\"adeira/workflow\": \"self.version\"\n}\n```\n\nComposer se k tomu potom chová tak, že místo toho aby hledal submodul někde pomocí závislostí, tak sáhne rovnou po submodulu (tak to dělá i Symfony a moc se mi o líbí). K tomu všemu ještě balíčkům přegeneruje soubory `vendor/autoload.php` s tímto obsahem:\n\n```php\n<?php return require dirname(dirname(dirname(__DIR__))) . '/vendor/autoload.php';\n```\n\nKaždý submodul teď tedy funguje (v mém případě) ze superprojektu a lze např. spustit testy napříč celým jmenným prostorem Adeira. Super je, že díky tomu všechny balíčky používají jednotné verze knihoven a nezastarávají. Nedokážu úplně domyslet jaké jsou důsledky mého počínání, ale je to _1)_ nejlepší rozhodnutí co jsem zde udělal nebo _2)_ největší hovadina a budu to muset zrušit. Uklidňuje mě, že tento způsob používají daleko větší projekty a mlaskají si blahem.\n\nPodobně mám udělaný ještě příkaz `adeira:eject`, který aktualizuje verze závislostí v jednotlivých submodulech podle hlavního repozitáře a příkaz `adeira:create`, který vytvoří nový submodul podle připravených šablon.\n\nVěřím, že pokud vydáváte mnoho knihoven, tak vám tento způsob ušetří hodně práce a začnete jej zavádět. Ve výsledku je jedno jakou z cest se vydáte - důležité je, že se vydáte... :)","frontmatter":"id: 5330469a-da65-4195-8c9a-2afccbd6078d\ntimestamp: 1484849186000\ntitle: Vy ještě nemáte svůj superprojekt?!\nslug: vy-jeste-nemate-svuj-superprojekt"},{"attributes":{"id":"95683b6a-7c7b-4ecf-b2a0-5730b2f85216","timestamp":1483183709000,"title":"GraphQL","slug":"2-graphql"},"body":"Z [minulého dílu](1-od-komponent-zpet-ke-komponentam) by mělo být všem jasné, jak jsem se dostal až sem. Od PHP komponent k webovým komponentám, které vlastně nejsou skutečné webové komponenty, ale jen kus JS kódu, který implementuje vlastní způsob webových komponent - React. Jsem přesvědčen o tom, že pro další pokračování je nutné vysvětlit, jak taková aplikace funguje. Takže...\n\n# Jak taková aplikace funguje?\n\nJestli mě něco na JS světě už dlouhou dobu děsí, tak je to skutečnost, že vlastně nikdo neví, jak by taková aplikace měla vypadat. Ačkoliv je mnoho lidí přesvědčeno o své pravdě, neuvědomují si subjektivitu jejich tvrzení. Z toho důvodu je teď milion implementací a návrhů a každý to dělá trošku jinak. Pokud to však vezmu co nejvíce objektivně, tak by se taková aplikace dala popsat následovně:\n\n- v prohlížeči běží JS kód, který se stará o vykreslování stránky s využitím veškeré síly JavaScriptu\n- _volitelně_: JS kód posílá do prohlížeče třeba NodeJS server, který dokáže vyrenderovat JS a poslat rovnou hotovou stránku do prohlížeče (včetně připravených dat)\n- na serveru běží kód (v mém případě Nette), který čeká na co se ho JS kód zeptá prostřednictvím (GraphQL) API a podle toho odpoví\n\nProč mi na serveru běží PHP, když hodně lidí preferuje mít JS i na serveru? Protože jsem skálopevně přesvědčen, že dokážu v PHP napsat lepší aplikaci s využitím veškerých myšlenek DDD co zvládnu pochopit (narozdíl od JS). End of story...\n\nNo a jak už titulek tohoto článku napovídá, tak mnou navrhovaný způsob je právě **GraphQL** ([link](http://graphql.org/)).\n\n# GraphQL queries\n\nGraphQL je nesmírně chytrý způsob jak se ptát API a přitom je to tak jednoduché, až mi přijde hloupé o tom psát. Pomocí GraphQL se lze serveru zeptat přímo na konkrétní věci. Tedy jako když se ptáte REST API, ale s tím rozdílem, že součástí požadavku je i informace o tom, co má API vrátit. Je dokonce možné zeptat se i více \"endpointů\" najednou. Zkuste si toto v REST API... :) Naopak GraphQL vyžaduje explicitní vyjmenování toho co chcete, takže jednoduše (pokud vím) nelze napsat dotaz, který by vrátil vše co daný endpoint umí.\n\nPojďme si to trošku vyzkoušet. Jako dobré hřiště pro dotazy poslouží [tato online aplikace](http://graphql-swapi.parseapp.com/). Dotazy se vždy posílají na jednu adresu (vetšinou `/graphql`) s tím, že se mění pouze obsah zprávy, který putuje v POST. To je velký rozdíl oproti REST API. Zde je jen jedna adresa, ale memí se obsah dotazu. Právě to přidává na dynamice dotazování - nejsme limitování na URL adresy. Takže když chceme vytáhnout z API např. všechny filmy, pošleme tento dotaz:\n\n```\n{\n  allFilms {\n    totalCount\n    films {\n      id\n      title\n      director\n    }\n  }\n}\n```\n\nTento zvláštní zápis říká, že se ptám na všechny filmy (`allFilms`) a zajímá mě kolik jich je. Zároveň chci u jednotlivých filmů vrátit jejich ID, název a režiséra. API mi pak vrátí dlouhý JSON:\n\n```js\n{\n  \"data\": {\n    \"allFilms\": {\n      \"totalCount\": 6,\n      \"films\": [\n        {\n          \"id\": \"ZmlsbXM6MQ==\",\n          \"title\": \"A New Hope\",\n          \"director\": \"George Lucas\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\n[Vyzkoušejte si to](http://graphql-swapi.parseapp.com/?query=%7B%0A%20%20allFilms%20%7B%0A%20%20%20%20totalCount%0A%20%20%20%20films%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20title%0A%20%20%20%20%20%20director%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&operationName=null). Chtěl bych ještě vědět jaké planety jsou ve filmu? Stačí rozšířit dotaz:\n\n```\n{\n  allFilms {\n    totalCount\n    films {\n      id\n      title\n      director\n      planetConnection {\n        planets {\n          name\n        }\n      }\n    }\n  }\n}\n```\n\nAPI vrátí ještě delší JSON. Vyzkoušejme jiný příklad. Co když mám k dispozici ID filmu, jak se zeptám pouze na ten konkrétní film? Pošleme ID filmu jako paramter dotazu:\n\n```js\n{\n  film(id: \"ZmlsbXM6MQ==\") {\n    title\n  }\n}\n```\n\nA teď ta nejvíce úžasná část. Chci si jedním šmahem vytáhnout film, člověka a všechny planety? Easy:\n\n```js\n{\n  film(id: \"ZmlsbXM6MQ==\") {\n    title\n  }\n  person(id: \"cGVvcGxlOjE=\") {\n    name\n  }\n  allPlanets {\n    planets {\n      name\n    }\n  }\n}\n```\n\nA výsledek? Ultra dlouhý JSON:\n\n```js\n{\n  \"data\": {\n    \"film\": {\n      \"title\": \"A New Hope\"\n    },\n    \"person\": {\n      \"name\": \"Luke Skywalker\"\n    },\n    \"allPlanets\": {\n      \"planets\": [\n        {\n          \"name\": \"Tatooine\"\n        },\n        {\n          \"name\": \"Alderaan\"\n        },\n        ...\n      ]\n    }\n  }\n}\n```\n\nAsi nemá smysl zanořovat se hlouběji. Princip by měl být jasný a samotné API je do jisté míry ovlivněno jeho návrhem (zde stránkováním). Jednoduše mohu jedním POST dotazem (což je ten zvláštní řetězec vypadající jako zjednodušený JSON) získat z API informace, které přesně moje React komponenta potřebuje. Toho některé knihovny silně využívají a vrácený výsledek posílají v properties přímo komponentě, který se stará **pouze** o vykreslování. Uvedu zde pouze krátký příklad toho co tím myslím (podrobněji to můžeme řešit později).\n\n`DataSourcesContainer` je komponenta, která využívá [Apollo](http://dev.apollodata.com/react/) a cíl této komponenty je pouze vytáhnout data a vykresení delegovat někam dál (`Row`).\n\n```js\nconst DataSourcesContainer = (props) => {\n\tlet {data: {loading, devices}} = props;\n\treturn loading ? null :\n\t\t<div>\n\t\t\t<h2>Data Sources</h2>\n\t\t\t{devices.map(dataSource =>\n\t\t\t\t<Row key={dataSource.id} dataSource={dataSource}/>\n\t\t\t)}\n\t\t</div>;\n};\n\nexport default graphql(gql`\n  query {\n    devices {\n      id,\n      name,\n      records\n    }\n  }\n`)(DataSourcesContainer);\n```\n\nAž teprve `Row` se stará o vykreslení, ale už nikdy nikdy nepošle dotaz na API:\n\n```js\nconst Row = (props) => {\n\tlet ds = props.dataSource;\n\treturn <div>{ds.name} <Link to={`/data-sources/${ds.id}`}>{ds.id}</Link> ({ds.records.length} records available)\n\t</div>;\n};\n\nRow.propTypes = {\n\tdataSource: React.PropTypes.shape({\n\t\tid: React.PropTypes.string,\n\t\tname: React.PropTypes.string,\n\t\trecords: React.PropTypes.arrayOf(React.PropTypes.string)\n\t}).isRequired,\n};\n\nexport default Row;\n```\n\nNechápu proč si někdo říká React programátor... :))\n\n# GraphQL mutations\n\nDobré API však potřebuje ještě minimálně jedu věc - možnost modifikace dat. K tomu slouží mutace. Zde opět musí aplikace (Nette) nadefinovat jaké jsou \"endpointy\" a jaké mají parametry. Taková mutace potom může vrátit nějaký datový typ a zde se to chová úplně stejně jako _queries_.\n\nTak kupříkladu přihlášení. Z mého pohledu je to mutace, protože měním stav aplikace a proto má moje aplikace připravenou tuto mutaci (toto je skutečný příklad z projektu [adeira/connector](https://github.com/adeira/connector) pokud se chcete šťourat v kódu):\n\n```\ntype Mutation {\n  login(username: String!, password: String!): User\n}\n```\n\nTzn. že pokud pošlu dotaz na to správné místo, tak mi API vratí uživatele, nebo mě odmítne. Využijeme CURL:\n\n```\ncurl -XPOST -H \"Content-Type:application/graphql\" -d '{\"query\": \"mutation {login(username:\\\"test\\\",password:\\\"test\\\"){id,token}}\"}' http://connector.adeira.localhost/graphql | jq .\n```\n\nA protože jsem zadal správné přihlašovacé údaje, tak mi API vrátí ID a [JWT token](https://jwt.io/), protože o to jsem si v dotazu řekl:\n\n```js\n{\n  \"data\": {\n    \"login\": {\n      \"id\": \"4ff2f293-9d21-4407-a6af-08f766e06cb3\",\n      \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE0ODMxODE3OTksImV4cCI6MTQ4MzE4NTM5OSwidXVpZCI6IjRmZjJmMjkzLTlkMjEtNDQwNy1hNmFmLTA4Zjc2NmUwNmNiMyJ9.o2aHdbjgtg80e_yXdFJSy4gCTb-4exEbNQbaOK9xa7nyiLpfvYe0FBPizz0XUVrE1JDzkW9m3QnupiVtTDyZ2g\"\n    }\n  }\n}\n```\n\nZde je nutné zdůraznit, že je naprosto zásadní, aby aplikace používala HTTPS. Co když zadám špatné heslo? API samozřejmě náležitě odpoví (včetně správného HTTP kódu):\n\n```js\n{\n  \"data\": {\n    \"login\": null\n  },\n  \"errors\": [\n    {\n      \"message\": \"The password is incorrect.\",\n      \"locations\": [\n        {\n          \"line\": 1,\n          \"column\": 11\n        }\n      ]\n    }\n  ]\n}\n```\n\nZ API si tak můžu vytáhnout vše co potřebuju pro změnu stavu aplikace. V tomto případě je to jen [JWT token](https://jwt.io/), který si uložím třeba do local storage a jsem na frontendu přihlášen...\n\nTento článek se již natáhl více než bych si přál a proto jsem vypustil informaci o implementaci na straně PHP. To totiž vydá na samostatnou kapitolku, takže si to nechám na někdy jindy (možná hned příště, aby to šlo pěkně popořadě).\n\nPodělte se prosím o postřehy.\n\nKaždý pozorný čtenář si také jistě všiml změny designu (nemluvě o přechodu na AWS) - líbí? :)","frontmatter":"id: 95683b6a-7c7b-4ecf-b2a0-5730b2f85216\ntimestamp: 1483183709000\ntitle: GraphQL\nslug: 2-graphql"},{"attributes":{"id":"8119640e-e954-435c-9a95-ff14bf73634b","timestamp":1482501056000,"title":"Muskulaturní rozšíření DIC","slug":"muskulaturni-rozsireni-dic"},"body":"K čemu je DI rozšíření v Nette a jak se takové rozšíření píše [už víme](http://zlml.cz/rozsireni-pro-dic). Teď se podíváme na způsob, jak pracovat s takovým rozšířením na úplně nové úrovni. Tento článek velké spoustě lidí změní způsob práce a aplikace budou najednou o level výš. Jak řekl jeden z účastníků školení: tak to je geniální... :)\n\n# Jak strukturovat aplikaci?\n\nO tom už jsem se párkrát rozepsal a ještě se také minimálně jednou rozepíšu. Proteď jen rychlý úvod. Za tu dobu co dělám s frameworky jsem došel k tomu, že nemám žádnou složku s názvem `app`. Například struktura [tohoto projektu](https://github.com/adeira/connector) vypadá (zjednodušeně) takto:\n\n```\n.\n├── bin\n│   └── console\n├── config\n│   ├── config.local.neon\n│   ├── config.local.neon.travis\n│   ├── config.neon\n│   ├── extensions.neon\n│   └── services.neon\n├── log\n├── src\n│   ├── Authentication\n│   ├── Common\n│   ├── Devices\n│   ├── Endpoints\n│   └── Routing\n├── temp\n├── tests (obsahuje 'src' se stejnou strukturou)\n├── vendor\n└── www\n```\n\nNa tom není vůbec nic převratného. Důležitý je však způsob jakým se pracuje se službami (services). Pokud se totiž podíváme na obsah souboru `services.neon`, tak zjistíme, že je téměř prázdný:\n\n```neon\nservices:\n\tmigrations.codeStyle: Adeira\\Connector\\Migrations\\CodeStyle\n\trouter: Adeira\\Connector\\Routing\\RouterFactory::createRouter\n\n\tdoctrineSession: Adeira\\Connector\\Common\\Infrastructure\\Application\\Service\\DoctrineSession\n\tdummySession:\n\t\tclass: Adeira\\Connector\\Common\\Infrastructure\\Application\\Service\\DummySession\n\t\tautowired: no\n```\n\nPřitom celý projekt má v tuto dobu zhruba 80 služeb, které je potřeba zaregistrovat. Kde je tedy ta magie? Asi je zřejmé kam mířím. O vše se starají rozšíření dependency injection kontejneru. Ty jsou zaregistrovány v `extensions.neon`:\n\n```neon\nextensions:\n\t- Arachne\\ContainerAdapter\\DI\\ContainerAdapterExtension # because of migrations\n\t- Arachne\\EventDispatcher\\DI\\EventDispatcherExtension # because of migrations\n\tauthentication: Adeira\\Connector\\Authentication\\Infrastructure\\DI\\Nette\\Extension\n\tdevices: Adeira\\Connector\\Devices\\Infrastructure\\DI\\Nette\\Extension\n\tdoctrine.orm: Adeira\\Connector\\Doctrine\\ORM\\DI\\Extension(%debugMode%)\n\tfakeSession: Kdyby\\FakeSession\\DI\\FakeSessionExtension\n\tgraphql: Adeira\\Connector\\GraphQL\\Bridge\\Nette\\DI\\Extension\n\tmigrations: Zenify\\DoctrineMigrations\\DI\\MigrationsExtension\n\tsymfony.console: Adeira\\Connector\\Symfony\\Console\\DI\\Extension\n```\n\nJak je vidět, tak každý balíček ve složce `src` má vlastní rozšíření (můž mít klidně víc rozšíření, ale není to potřeba). Na následujících řádcích ukážu jak takové rozšíření napsat super jednoduše.\n\n# Rozšíření bez znalosti Nette\\DI\n\nPsaní rozšíření pro DIC v Nette může být (a je) poměrně složité. Trošku to chce vědět, jak Nette funguje uvnitř. To samozřejmě dává do rukou obrovský nástroj, ale současně to také klade obrovskou překážku. Přesně z tohoto důvodu vznikl balíček [adeira/compiler-extension](https://github.com/adeira/compiler-extension), který jsem napsal pro lidi ve firmách, kteří se Nette teprve učí, chtějí psát aplikace tak jako já a na prozkoumávání Nette\\DI není čas. Záběr tohoto balíčku není jen zde. Sám jsem si ho moc oblíbil a dnes tak píšu rozšíření také (ne vždy, ale dost často).\n\nMyšlenka je taková, že NEON formát umí každý. Pokud ne, tak si stačí prohlédnout [tuto stránku](https://ne-on.org/) a je to všem jasné (používám velmi úspěšně na školeních a přednáškách). Zároveň je snadné naučit o čem je DI, proč se musí v Nette registrovat služby v konfiguračním souboru a jak funguje autowiring. To v zásadě stačí k tomu, aby člověk začal psát aplikace mnohem lépe než dříve. Jenže pokud chce někdo strukturovat aplikaci tak jak to dělám já, tak musí registrovat všechny služby do souboru `services.neon` a těch je desítky až stovky (ne-li tisíce). Navíc je to nesmysl - proč by si takový balíček nemohl nést všechno s sebou (včetně konfigurací)?\n\nAle on může! Podívejte se, jak vypadá takové rozšíření `Authentication` balíčku:\n\n```php\n<?php declare(strict_types = 1);\n\nnamespace Adeira\\Connector\\Authentication\\Infrastructure\\DI\\Nette;\n\nuse Adeira\\Connector\\Doctrine\\ORM;\n\nclass Extension extends \\Adeira\\CompilerExtension implements ORM\\DI\\IMappingFilesPathsProvider\n{\n\n\tpublic function provideConfig(): string\n\t{\n\t\treturn __DIR__ . '/config.neon';\n\t}\n\n\tpublic function getMappingFilesPaths(): array\n\t{\n\t\treturn [__DIR__ . '/../../Persistence/Doctrine/Mapping'];\n\t}\n\n}\n```\n\nDůležitá je metoda `provideConfig`, která slouží pouze k tomu, aby rozšíření prozradilo, kde je jeho konfigurační soubor. A tato konfigurace může být [pěkně bohatá](https://raw.githubusercontent.com/adeira/connector/03be1b949a0eb0c2f75c90ba3da5fca2ef8b2979/src/Authentication/Infrastructure/DI/Nette/config.neon). Takovou nutnou prerekvizitou k tomu aby vše fungovalo je nahrazení výchozího `ExtensionsExtension` za novou implementaci, který toto chování umoňuje:\n\n```php\n$configurator = new Nette\\Configurator;\n$configurator->defaultExtensions['extensions'] = \\Adeira\\ConfigurableExtensionsExtension::class;\n```\n\nTuto jednu řádku je nutné umístit třeba do souboru `bootstrap.php` kde se vytváří DI kontejner. Od teď bude toto chování fungovat \"by default\" a vlastní DI rozšíření dokonce může dědit od `Nette\\DI\\CompilerExtension`. **Není tedy potřeba dělat žádné úpravy ve stávajících rozšířeních.** A to je vždy super! Pokud bude rozšíření dědit od `Adeira\\CompilerExtension`, budete mít k dispozici ještě pomocnou metodu `setMapping`, která se hodí pro mapování presenterů. Není to však nutná podmínka.\n\nTo ale není všechno!\n\n# Jak se chovají konfigurace balíčků\n\nAsi nejzajímavější na návrhu dependency injection je to, že je možné jednoduše vyměňovat implementace bez zásahu do kódu. Jak se tímto pracuje balíček [adeira/compiler-extension](https://github.com/adeira/compiler-extension)? Představte si, že máte hlavní konfigurační soubor s tímto obsahem:\n\n```neon\nparameters:\n    key1: value1\n    key2: value2\n\nservices:\n    - DefaultService\n    named: Tests\\Service\n\nextensions:\n    ext2: CustomExtension2\n\next2:\n    ext_key1: ext_value1\n    ext_key2: ext_value2\n\napplication:\n    mapping:\n        *: *\n```\n\nA teď přidáte nový balíček, který si nese vlastní konfigurační soubor a pomocí metody `provideConfig` jej dává k dispozici. Jeho obsah je takovýto:\n\n```neon\nparameters:\n    key2: overridden\n    key3: value3\n\nservices:\n    - Tests\\TestService\n    named: Service2\n\next2:\n    ext_key2: overridden\n    ext_key3: ext_value3\n\nlatte:\n    macros:\n        - App\\Grid\\Latte\\Macros\n```\n\nJaký je výsledek? V aplikaci budou k dispozici najednou tři parametry (obdobně pro `ext2` parametry):\n\n```neon\nparameters:\n    key1: value1\n    key2: overridden\n    key3: value3\n```\n\nPodobně se to chová i u služeb:\n\n```neon\nservices:\n    - DefaultService\n    named: Service2 # přepsat lze pouze pojmenovanou službu\n    - Tests\\TestService\n```\n\nNavíc se zaregistruje Latte makro. Ačkoliv toto chování funguje dobře, doporučuji jej spíše nevyužívat k přepisování globální konfigurace. Mnohem vhodnější je využívat tyto konfigurace k **přidávání** funkčností z balíčků. Tedy registrace nových služeb, přidávání commandů do konzole, registrace nových typů v Doctrine a podobně. V takovém případě se bude rozšíření chovat naprosto očekávaně. Vyhnete se tak tomu, že dva balíčky nastavují jeden parametr a záleží tam na pořadí. Je to nástroj - užijte jej s rozumem.\n\nTo ale pořád není všechno!\n\n# Malé pozlátko na závěr\n\nTento balíček přidává ještě jednu funkci, kterou považuji také za velmi užitečnou. Jak jistě víte, tak rozšíření se dá zaregistrovat pomocí sekce `extensions` a pokud rozšíření zaregistrujete pod nějakým jménem, je možné jej konfigurovat. To ostatně bylo vidět před malou chvílí:\n\n```neon\nextensions:\n    ext2: CustomExtension2\n\next2:\n    ext_key1: ext_value1\n    ext_key2: ext_value2\n```\n\nV tomto případě budou klíče `ext_key1` a `ext_key2` k dispozici v samotném rozšíření. To se potom používá k různým úpravám chování samotného balíčku. Co když však nepíšete vlastní PHP kód, ale chcete jen předat tyto parametry do nějaké služby, kterou ono rozšíření registruje? K tomu slouží zvláštní zápis pomocí `%%`. V tomto konkrétním případě řekněme, že `CustomExtension2` má vlastní konfigurační soubor s tímto obsahem:\n\n```\nservices:\n    - Tests\\TestService(%%ext_key2%%)\n```\n\nJak je vidět, tak si může vzít hodnotu `ext_key2` rovnou z konfigurace. Důležité je si uvědomit, že zatímco `%aaa%` bere parametr `aaa` ze sekce `parameters`, tak `%%aaa%%` bere konfiguraci **pouze** ze sekce, pod kterou je rozšíření zaregistrované. Chová se to tedy úplně stejně jako `$this->getConfig()` uvnitř rozšíření... :)\n\nDejte [tomuto rozšíření](https://github.com/adeira/compiler-extension) šanci (nebo hvězdičku). Z praxe mohu říci, že se s ním pracuje skutečně dobře a pokud narazíte na to, že potřebujete udělat něco složitého - není problém pokračovat v psaní DI rozšíření v PHP zároveň s tímto. Uvítám také nápady na zlepšení a různé postřehy. Přecijen chvíli mi trvalo, než jsem přišel na ten správný způsob jak to uchopit.\n\n```\ncomposer require adeira/compiler-extension\n```\n\nInstalace je jednoduchá... :)","frontmatter":"id: 8119640e-e954-435c-9a95-ff14bf73634b\ntimestamp: 1482501056000\ntitle: Muskulaturní rozšíření DIC\nslug: muskulaturni-rozsireni-dic"},{"attributes":{"id":"462e4010-090c-4622-bbd9-295948c71609","timestamp":1481912287000,"title":"Od komponent zpět ke komponentám","slug":"1-od-komponent-zpet-ke-komponentam"},"body":"On: *A budeš o tom psát nějaké články?*<br>\nJá: *No tak jako mohl bych... :)*\n\n...a tak tedy začínám krátký seriál a uvidím kam se za těch pár dílů dostanu.\n\nJednou z bezesporu nejzajímavějších vlastností Nette Frameworku jsou komponenty (myslím potomky `Nette\\Application\\UI\\Control`). Komponenta je logický prvek na stránce, který umožňuje uschovat způsob vykreslování nějakého elementu stránky. Prakticky jsem začal komponenty využívat téměř ke všemu a čím více komponent, tím jsem spokojenější. Na stránce je potom místo mnoha složitých šablon mnohdy velmi rozvětvený strom komponent, kdy každá komponenta řeší jak vykreslit třeba část hlavičky (klidně i ve více variantách).\n\nSystém komponent má však v Nette celou řadu úskalí a temných zákoutí. Jedním z největších problémů považuji to, že si komponenta nenese vše s sebou. Zejména pak styly a javascript. Ačkoliv jsem tento problém řešil pokaždé a vždy nějakým jiným originálním způsobem, vždy jsem došel ke stavu aplikace, který se mi z nějakého důvodu moc nelíbil.\n\nZačal jsem tedy hledat jiné řešení. A než ukážu výsledek, je nutné pochopit kudy jsem šel a kde jsem se cestou popálil...\n\n# WebComponents\n\n[Webové komponenty](http://webcomponents.org/) jsou přesně to co jsem hledal. Webová komponenta slouží k rozšíření DOMu o vlastní HTML prvky (stejně tak jako funguje např. `<video>` tag). Pokud chcete vidět obsah takového tagu, doporučuji v Chrome zapnout \"Show user agent shadow DOM\". Přirozeně jsem šel hned za Polymerem, protože jej již nějaký čas znám. Nikdy jsem si ho však nevyzkoušel na reálném projektu. Minimální definice Polymer elementu vypadá takto:\n\n```html\n<dom-module id=\"element-name\">\n  <template>\n    <style>/* ... */</style>\n  </template>\n  <script>\n    Polymer({\n      is: 'element-name',\n    });\n  </script>\n</dom-module>\n```\n\nK dispozici tedy budu mít v HTML element `<element-name/>` (pozor: název musí obsahovat pomlčku). Následně bude mít komponenta definovaný způsob vykreslování, vlastní styly i vlastní JS chování. Super. Pokud chcete něco takového implementovat pomocí Nette komponent - vzdejte to rovnou. Neříkám, že by to nešlo, ale jednak je to složité a jednak bude supersložité řešit věci jako je [vulkanizace a použití Crisperu](https://www.polymer-project.org/1.0/docs/tools/optimize-for-production). Rychle jsem tedy opustil cestu vytváření komponent na straně serveru a vše jsem předal javascriptu.\n\nBylo to super a pak jsem **po několika měsících práce s Polymerem celou aplikaci rozerval na kousky a přepsal ji do něčeho jiného**. Nikdy jsem nezažil nic tak vyčerpávajícího jako práci s Polymerem. HTML se totiž bohužel chová tak, že pokud nějaký element nezná, tak jej ignoruje. A prakticky jakákoliv chyba typu \"proč to nejde\" byla způsobena práce tímto. Každý element je třeba importovat a ačkoliv IDE dokáže hodně pomoci, tak existují případy, kdy to prostě nefunguje a jen kvůli tomu, že jsem si prvek nenaimportoval...\n\n```html\n<input is=\"my-input\">\n```\n\nToto je přesně případ se kterým si třeba WebStorm nedokáže poradit. Takže fakticky je to moje chyba, že jsem nepozorný, ale o to více potřebuji, aby když něco udělám blbě, tak mi to pořádně nafackovalo a já hned věděl. Proto jsem Polymer opustil (ano to je jediný důvod) a ačkoliv si myslím, že je to skvělý nápad a webovým komponentám hodně fandím, vydal jsem se o kousek dál.\n\n# React\n\nStejně tak jako všichni, tak i já jsem skončil u Reactu. A stydím se za to. Nechci jej používat jen proto, že je to cool. Ale dal jsem mu poprvé velkou šanci i tak (už jej znám dlouho, ale nikdy jsem nepotřeboval). Z mého pohledu: zatímco Polymer umí by default úplně [neuvěřitelně vymakané frontend prostředí](https://beta.webcomponents.org/collection/Polymer/elements), React neumí nic než pracovat s daty. Ale jeden ze zásadních rozdílů je v tom, že je striktní. Takže moje problémy s neexistujícími emlementy řeší JSX by design (kdo zná XHP, tak ví). Vzdal jsem se tedy úžasného nástroje a přešel jsem na něco, co umí v základu jen chytře aktualizovat DOM a vykreslit `div` (takto vypadá nejmenší komponenta, kterou lze v Reactu napsat - ES6):\n\n```js\nimport React from 'react';\n\nexport default () => <div>Alenka</div>\n```\n\nV Reactu jsou dva druhy komponent - tzv. kontejnery a samotné prezentační komponenty. Toto rozdělení mi také vyhovuje, protože se hezky separují závislosti (kontejner pouze tahá data a prezentační komponenta pouze vykresluje vytažená data). Navíc si taková komponenta nese i vlastní styly (což se ne všem líbí, ale já tleskám):\n\n```js\nimport './AuthorizedBase.css';\n```\n\nPodobně je možné importovat i obrázky a další zdroje díky Webpacku (neuvěřitelně WTF WOW nástroj). Webpack je právě nástroj, který řeší většinu bolístek, které jsem řešil složitě u Nette komponent.\n\nAčkoliv zrovna v mém případě React docela dává smysl, protože se bude hodně pracovat s daty, použil bych je i na místě, kde to totálně nedává smysl (tedy třeba na blog). Je to totiž způsob jak pracovat s frontendem takovým způsobem, jaký jsem dlouho hledal (navíc je React jednoduchý). Má to však jedno velké ALE.\n\nPokud bych vzal React a začal jej používat rovnou tak jak je, tak bych vytvořil pěknou hovadinu. Je potřeba milion dalších podpůrných služeb a vychytávek jako je třeba server-rendering a code-splitting. Bez těchto věcí, které je potřeba vyřešit, to nemá ani smysl zkoušet. Na to upozorňuji rovnou. Souhlasím s tím, že dělat to bez toho by byla prostě [ultrapíčovina](https://medium.com/@vojta/airbanko-v%C3%ADte-pro%C4%8D-m%C3%A1te-posran%C3%BD-web-629d96946576#.tshx84cqg). Z toho by mělo být patrné, že nechci profitovat ani tak třeba z chytrých aktualizací DOMu, ale ze způsobu jak se pracuje v Reactu s komponentami. Ve výsledku bude naprosto v pořádku, když nepůjde poznat, že je stránka napsána v Reactu (čehož asi stejně nedosáhnu). Důležité je dodržovat rozdělení komponent podle jejich účelu (tahání dat vs. vykreslování).\n\nToto byl jen krátký úvod. V dalších dílech se podívám na to, jak tahat data ze serveru pomocí GraphQL a jakou použít knihovnu. Zároveň je potřeba vyřešit napojení na Nette backend (protože PHP mě pořád moc baví... :)). Podíváme se také na routování, autorizaci modelové vrstvy, strukturu aplikace, renderování na serveru, testování, Webpack, code-splitting a další a další... Stay tuned. :)","frontmatter":"id: 462e4010-090c-4622-bbd9-295948c71609\ntimestamp: 1481912287000\ntitle: Od komponent zpět ke komponentám\nslug: 1-od-komponent-zpet-ke-komponentam"},{"attributes":{"id":"04fd5b1a-eb64-4a48-b0db-47e4509d4ab8","timestamp":1480773916000,"title":"Testování korelací v MATLABu","slug":"testovani-korelaci-v-matlabu"},"body":"Čím více mi proteklo kódu pod prsty, tím více mě testování baví. Nebaví mě psát super skvělé testy, ale baví mě brát testy jako součást vývoje. Mnohdy je to dokonce nejpohodlnější způsob. Na následujících řádcích ukážu jak se dá napsat algoritmus pro [korelaci velkého množství dat](https://en.wikipedia.org/wiki/Correlation_and_dependence) a hlavně **jak jej otestovat**. Konkrétně půjde o Pearsonův korelační koeficient.\n\nPearsonův korelační koeficient lze popsat velmi jednoduchým vzorcem (podíl kovariance a směrodatných odchylek souborů dat - viz wiki). Implementace tohoto vzorce v MATLABu může vypadat třeba takto:\n\n```\nfunction rho = pearson(obj, X, Y)\n    X = X(:);\n    Y = Y(:);\n    covariance = cov(X, Y);\n    rho = covariance(1, 2) / (std(X) * std(Y));\n    if isnan(rho)\n        error('pearson:undefined', 'Correlation coefficient is undefined because the variance of Y is zero.')\n    end\nend\n```\n\nTento vzorec vrací číslo v intervalu od -1 do +1, které charakterizuje míru závislosti Y na X. Jak toto chování otestovat? V MATLABu existuje připravený [TestCase](https://www.mathworks.com/help/matlab/ref/matlab.unittest.testcase-class.html) (od verze R2013a), takže pokud znáte TestCase třeba z Nette\\Testeru, tak je to velmi jednoduché (čti skoro stejné). Připravíme si samotnou testovací třídu:\n\n```\nclassdef CorrelationTest < matlab.unittest.TestCase\n    methods (Test)\n        % TODO - test methods\n    end\nend\n```\n\nA zbývá pouze doplnit pár základních testů. Zde bude vidět, že se vyplatí mít korelace implementované v rámci nějaké třídy. První test by mohl kontrolovat perfektní lineární závislost:\n\n```\nfunction testPearsonCorrelated(testCase)\n    % actual, expected, ...\n    X1 = [1 2 3 4]; Y1 = [1 2 3 4];\n    X2 = [1 2 3 4]; Y2 = [1 3 5 7];\n    X3 = [1 3 5 7]; Y3 = [1 2 3 4];\n    testCase.verifyEqual(pearson(Correlation, X1, Y1), 1.0, 'AbsTol', 1e-15);\n    testCase.verifyEqual(pearson(Correlation, X2, Y2), 1.0, 'AbsTol', 1e-15);\n    testCase.verifyEqual(pearson(Correlation, X3, Y3), 1.0, 'AbsTol', 1e-15);\nend\n```\n\nTesto test otestuje tři různě strmé lineární závislosti. Pearson by neměl na strmost reagovat - vždy by tento test měl vyjít +1. Pokud by se někomu nelíbilo opakování verify metod, lze přepsat tento test trošku chytřeji:\n\n```\nfunction testPearsonCorrelated(testCase)\n    assert = @(x, y) testCase.verifyEqual(pearson(Correlation, x, y), 1.0, 'AbsTol', 1e-15);\n    assert([1 2 3 4], [1 2 3 4]);\n    assert([1 2 3 4], [1 3 5 7]);\n    assert([1 3 5 7], [1 2 3 4]);\nend\n```\n\nVýsledek je stejný jen s pomocí [anonymní funkce](https://www.mathworks.com/help/matlab/matlab_prog/anonymous-functions.html). Důležitá je v tomto testu pouze metoda `verifyEqual`, která dělá přesně to co říká s tím, že se v tomto testu ignoruje zaokrouhlovací chybu (velmi malá absolutní tolerance).\n\nTímto způsobem lze jednoduše Pearson metodu pořádně otestovat. Celá implementace i s testy je [k dispozici online](https://gist.github.com/mrtnzlml/d12a93d0ce5bced2900dfbaee003c796) (včetně Spearmanova algoritmu). Poslední test který ukážu je [Anscombe's quartet](https://en.wikipedia.org/wiki/Anscombe%27s_quartet) test. Zde je k dispozici sada hodnot, která vždy vytvoří jinou grafickou reprezentaci dat, ale Pearsonův korelační koeficient je pořád stejný. Opět mohu s výhodou využít anonymní funkci:\n\n```\nfunction testAnscombesQuartet(testCase)\n    c = Correlation(false);\n    test = @(x, y) testCase.verifyEqual(pearson(c, x, y), 0.816, 'RelTol', 0.001);\n    X1 = [10 8 13 9 11 14 6 4 12 7 5];\n    Y1 = [8.04 6.95 7.58 8.81 8.33 9.96 7.24 4.26 10.84 4.82 5.68];\n    test(X1, Y1);\n    X2 = [10 8 13 9 11 14 6 4 12 7 5];\n    Y2 = [9.14 8.14 8.74 8.77 9.26 8.10 6.13 3.10 9.13 7.26 4.74];\n    test(X2, Y2);\n    X3 = [10 8 13 9 11 14 6 4 12 7 5];\n    Y3 = [7.46 6.77 12.74 7.11 7.81 8.84 6.08 5.39 8.15 6.42 5.73];\n    test(X3, Y3);\n    X4 = [8 8 8 8 8 8 8 19 8 8 8];\n    Y4 = [6.58 5.76 7.71 8.84 8.47 7.04 5.25 12.50 5.56 7.91 6.89];\n    test(X4, Y4);\nend\n```\n\nKaždá sada bodů vyjde vždy 0.816 s relativní tolerancí 0.001. A konečně spuštění této sady testů:\n\n```\n>> run(CorrelationTest)\nRunning CorrelationTest\n.........\nDone CorrelationTest\n__________\n\n\nans = \n\n  1×9 TestResult array with properties:\n\n    Name\n    Passed\n    Failed\n    Incomplete\n    Duration\n    Details\n\nTotals:\n   9 Passed, 0 Failed, 0 Incomplete.\n   0.14742 seconds testing time.\n\n>>\n```\n\nKdyž se teď člověk podívá zpět, tak je vidět, že psát a následně upravovat a rozšířovat takovou věc je bez testů šílenost. Přesto psaní testů v MATLABu není žádnou zvyklostí. A jak jinak při vývoji ověřovat, že vše stále funguje? Však už si dávno nepamatujete kolik má vyjít Pearsonův korelační koeficient u Anscombe's quartetu... :-)","frontmatter":"id: 04fd5b1a-eb64-4a48-b0db-47e4509d4ab8\ntimestamp: 1480773916000\ntitle: Testování korelací v MATLABu\nslug: testovani-korelaci-v-matlabu"},{"attributes":{"id":"45b197e5-9e04-43d5-b48e-58f9a7f90887","timestamp":1478454487000,"title":"Tester: vlastní Output Handler","slug":"tester-vlastni-output-handler"},"body":"Output Handler umožňuje změnit finální podobu výstupu z Nette Testeru. Výstup může [vypadat například takto](https://travis-ci.org/adeira/connector/jobs/173698139). Osobně se mi tento výstup líbí víc, protože místo teček rovnou vidím co se skutečně spouští. Může se to hodit a sám jsem se přistil, že občas spouštím testy takto:\n\n```\nvendor/bin/run-tests -o tap\n```\n\nA to jen proto, abych viděl co se zrovna testuje (TAP). Napsat si vlastní výstupní handler je jednoduché. Jen je třeba dávat pozor na to, co je [napsáno v dokumentaci](https://tester.nette.org/#toc-setup-path), protože to [nemusí být dobře](https://github.com/nette/web-content/pull/473)... :)\n\nStačí Tester spouštět s přepínačem `--setup`:\n\n```\nvendor/bin/tester --setup tests/runner-setup.php\n\n# or Testbench edition:\nvendor/bin/run-tests --setup tests/runner-setup.php\n```\n\nSkript `runner-setup.php` potom obsahuje samotný handler který může vypadat třeba takto (PHP 7):\n\n```php\n<?php declare(strict_types = 1);\n\nuse Tester\\Dumper;\nuse Tester\\Runner\\Runner;\n\n/** @var \\Tester\\Runner\\Runner $runner */\n$runner->outputHandlers = []; // delete native output handlers\n$runner->outputHandlers[] = new class ($runner) extends \\Tester\\Runner\\Output\\ConsolePrinter\n{\n\n\tpublic function begin()\n\t{\n\t\tob_start();\n\t\tparent::begin();\n\t\techo rtrim(ob_get_clean()) . ' | ' . getenv('BOOTSTRAP') . \"\n\n\";\n\t}\n\n\tpublic function result($testName, $result, $message)\n\t{\n\t\t$outputs = [\n\t\t\tRunner::PASSED => Dumper::color('green', '✔ ' . $testName),\n\t\t\tRunner::SKIPPED => Dumper::color('olive', 's ' . $testName) . \"($message)\",\n\t\t\tRunner::FAILED => Dumper::color('red', '✖ ' . $testName) . \"\n\" . $this->indent($message, 3) . \"\n\",\n\t\t];\n\t\techo $this->indent($outputs[$result], 2) . PHP_EOL;\n\t}\n\n\tpublic function end()\n\t{\n\t\tob_start();\n\t\tparent::end();\n\t\techo \"\n\" . trim(ob_get_clean()) . \"\n\";\n\t}\n\n\tprivate function indent($message, $spaces)\n\t{\n\t\tif ($message) {\n\t\t\t$result = '';\n\t\t\tforeach (explode(PHP_EOL, $message) as $line) {\n\t\t\t\t$result .= str_repeat(' ', $spaces) . $line . PHP_EOL;\n\t\t\t}\n\t\t\treturn rtrim($result, PHP_EOL);\n\t\t}\n\t\treturn $message;\n\t}\n\n};\n```\n\nJe to vlastně jen o třech metodách. Začátek `begin` a konec `end` slouží jen k ořezání mezer popř. k doplnění dodatečných informací. Nejzajímavější je metoda `result`, která velmi mění způsob vykreslení jednotlivých řádek. Bohužel Tester sám od sebe ořezává výstupní texty a podle toho jak jsem to rychle prohlížel, tak s tím nejde nic moc udělat. Představoval bych si, že výstupní texty budou trošku lepší, ale to bez PR do `Nette\\Testr`u asi nepůjde...\n\nTo by bylo. Pozornější čtenáři kódu mohou mít teď otázku co je to `getenv('BOOTSTRAP')`? Dlouze jsem řešil jak psát testy s ohledem na to, že se mi nechce pořád dělat require `bootstrap.php`, protože mám testy hodně zanořené a cesty k tomutou souboru bývají hodně dlouhé. Navíc je to nesmírně limitující, protože nelze jednoduše bez úpravy testů měnit adresářovou strukturu. Řešením je trošku to obejít:\n\n```php\nrequire getenv('BOOTSTRAP');\n```\n\nExistuje [více řešení](https://github.com/nette/tester/issues/275), ale toto mi sedělo nejlépe. Užitečné je pak napsat si vlastní skript `tests/run` a všechno to spojit:\n\n```bash\n#!/usr/bin/env bash\n\nBOOTSTRAP=$(pwd)/tests/bootstrap.php vendor/bin/run-tests --setup tests/runner-setup.php\n```\n\nSpuštění je tak jednoduché, jako je jednoduché napsat `tests/run`. Pokud by si to chtěl někdo prohlédnout více detailně a popř. si s tím pohrát, tak je vše zde popisované implementováno v projektu [Adeira\\Connector na GitHubu](https://github.com/adeira/connector).\n\n:)","frontmatter":"id: 45b197e5-9e04-43d5-b48e-58f9a7f90887\ntimestamp: 1478454487000\ntitle: \"Tester: vlastní Output Handler\"\nslug: tester-vlastni-output-handler"},{"attributes":{"id":"103fd545-2922-4c42-b50c-6387a1f05d48","timestamp":1475925989000,"title":"Automatický render prvků při manuálním vykreslování formuláře","slug":"automaticky-render-prvku-pri-manualnim-vykreslovani-formulare"},"body":"Je čas na nějakou tu Nette divočinu. Podívejme se pod drobnohledem na to, jak funguje vykreslování prvků formuláře. Nejprve si vytvoříme úplně jednoduchý formulář, který bude obsahovat jeden prvek:\n\n```php\nprotected function createComponentContactForm()\n{\n\t$form = new UI\\Form();\n\t$form->addSubmit('send', 'Odeslat');\n\t$form->onSuccess[] = function (UI\\Form $form, $values) {\n\t\tthrow new \\Nette\\NotImplementedException;\n\t};\n\treturn $form;\n}\n```\n\nJak bude vypadat takový formulář když jej vykreslíme pomocí `{control contactForm}`? Ve výchozím projektu asi nějak takto:\n\n```html\n<form action=\"/web-project/www/\" method=\"post\" id=\"frm-contactForm\">\n<table><tbody><tr>\n\t<th></th>\n\t<td><input type=\"submit\" name=\"send\" value=\"Odeslat\" class=\"button\"></td>\n</tr></tbody></table>\n<input type=\"hidden\" name=\"_do\" value=\"contactForm-submit\">\n</form>\n```\n\nAniž se budeme nořit do detailů, tak je zřejmé, že se kromě našeho odesílacího inputu vyrenderoval i nějaký hidden input automaticky. Než se posuneme dále z tohoto úvodu, zjistíme ještě, co se stane při manuálním vykreslování:\n\n```latte\n{form contactForm}\n\t{input send}\n{/form}\n```\n\nAčkoliv to není nikde dané, i v tomto případě se vykreslil další input prvek automaticky:\n\n```html\n<form action=\"/web-project/www/\" method=\"post\" id=\"frm-contactForm\">\n\t<input type=\"submit\" name=\"send\" value=\"Odeslat\">\n\t<input type=\"hidden\" name=\"_do\" value=\"contactForm-submit\">\n</form>\n```\n\n# Chytrý antispam prvek\n\nPo krátkém úvodu (který je zcela jistě každému jasný) se přesuneme k něčemu zdánlivě jinému. Vytvoříme si chytrý antispam prvek a zjistíme, jak se bude při renderování chovat a jestli se vždy chová předvídatelně. A asi nebude překvapením, že se v určité situaci zachová moc moc špatně. Jedná se o delší kód, takže jej [najdete na Gistu](https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a). Prakticky nejde o nic jiného, než že si vytvoříme vlastní antispam prvek. Tento prvek funguje tak, že vytvoří input ve kterém je nějaký text a pokud je k dispozici javascript, tak jej schová a smaže obsah. V tom případě je kontrola v pořádku, protože tiše předpokládá, že útočníkův robot nebude umět JS. Ačkoliv se to v dnešní době může zdát jako absurdní, tak to pořád funguje velmi dobře. Navíc přidává ještě pár honeypotů a doufá, že někde robot uvízne. Důležité je, že nijak neobtěžuje běžného návštěvníka - prostě to není vůbec vidět.\n\nNapíšeme si jednoduché rozšíření pro DI kontejner, aby bylo možné tento nový prvek používat:\n\n```php\n<?php\n\nnamespace App;\n\nuse Nette\\Forms\\Form;\n\nclass HoneypotExtension extends \\Nette\\DI\\CompilerExtension\n{\n\n\tpublic function afterCompile(\\Nette\\PhpGenerator\\ClassType $class)\n\t{\n\t\t$init = $class->methods['initialize'];\n\t\t$init->addBody(self::class . '::registerControlExtensionMethods();');\n\t}\n\n\tpublic static function registerControlExtensionMethods()\n\t{\n\t\tForm::extensionMethod('addAntispam', function (Form $form, $name = 'honeypot', $label = 'Vymažte toto pole') {\n\t\t\t$form[$name . '_1'] = new \\App\\Forms\\AntispamControl($name, $label);\n\t\t\treturn $form;\n\t\t});\n\t}\n\n}\n```\n\nToto rozšíření samozřejmě zaregistrujeme v konfiguračním souboru:\n\n```neon\nextensions:\n\t- App\\HoneypotExtension\n```\n\nA je to - v našem původním formuláři můžeme použít nový prvek:\n\n```php\n$form = new UI\\Form();\n$form->addAntispam();\n//...\n```\n\nJe to trošku magie a IDE si s tím neporadí. Proto nebude našeptávat. V tomto případě doporučuji napsat si nějakou vlastní `FormFactory`, která bude vytváře instance `UI\\Form` a do této třídy doplnit anotaci `@method addAntispam()`. Udělat si vlastní továrničku na `UI\\Form` není vůbec špatný nápad a to nejen pro antispam. Just do it.\n\nTak a teď když máme funkční antispam a honeypoty formuláře, je čas kouknout se co se děje při renderování. Nejdříve automatické - pomocí `{control contactForm}`. Zde není co řešit. Prostě se všechny potřebná políčka vyrenderují a vše je tak, jak by mělo být. A co manuální vykreslování? Zde začíná ta nepříjemná část. Nette nemůže vědět, že by měl automaticky vykreslit i další prvky, takže je prostě nevykreslí. Praktická zkušenost je taková, že při manuálním vykreslování prostě antispam přestane fungovat. Zde se musíme ještě zasnažit.\n\n# Chytřejší antispam prvek\n\nTeď musíme jít fakt na dřeň problému. Jak vlastně funguje to automatické renderování inputu při manuálním vykreslování? Existuje něco jako třída `Nette\\Bridges\\FormsLatte\\Runtime`, která má dvě metody: `renderFormBegin` a `renderFormEnd`. Právě druhá zmíněná přidává nějaký vlastní kód a je jedno, jestli se jedná o manuální, nebo automatické renderování formuláře. To by se nám hodilo. Vytvořme si tedy vlastní `Runtime` třídu. Není potřeba aby tato třída dědila od původní. Stačí, když si vykopírujeme metodu `renderFormEnd` a lehounce pozměníme prostřední foreach:\n\n```php\nforeach ($form->getControls() as $control) {\n\tif ($control->getOption('autorender') || ($control->getOption('type') === 'hidden' && !$control->getOption('rendered'))) {\n\t\t$s .= $control->getControl();\n\t}\n}\n```\n\nPřesně tak. Všechny čáry a kouzla se aktivují, když nastavíme prvkům `autorender` ([viz Gist](https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a)). Jenže kde se tato třída původně používala? Kde ji použijeme nyní?\n\nŘešení najdeme opět v namespace `Nette\\Bridges\\FormsLatte`, tentokrát však ve třídě `FormMacros`, která registruje formulářová makra. Vytvoříme si tedy vlastní implementaci `FormMacros` třídy, která bude dědit od původní:\n\n```php\nclass FormMacros extends \\Nette\\Bridges\\FormsLatte\\FormMacros\n{\n\n\tpublic static function install(\\Latte\\Compiler $compiler)\n\t{\n\t\t$me = new static($compiler);\n\t\t$me->addMacro('form', [$me, 'macroForm'], 'echo \\App\\Forms\\Runtime::renderFormEnd(array_pop($this->global->formsStack));');\n\t\t$me->addMacro('formContainer', [$me, 'macroFormContainer'], 'array_pop($this->global->formsStack); $formContainer = $_form = end($this->global->formsStack)');\n\t\t$me->addMacro('label', [$me, 'macroLabel'], [$me, 'macroLabelEnd'], NULL, self::AUTO_EMPTY);\n\t\t$me->addMacro('input', [$me, 'macroInput']);\n\t\t$me->addMacro('name', [$me, 'macroName'], [$me, 'macroNameEnd'], [$me, 'macroNameAttr']);\n\t\t$me->addMacro('inputError', [$me, 'macroInputError']);\n\t}\n\n}\n```\n\nDůležitá je zde registrace makra `{form}`, protože to pro svojí uzavírací značku používá novou implementaci `Runtime` (tu která podporuje autorender). Zaregistrujeme:\n\n```neon\nlatte:\n\tmacros:\n\t\t- App\\Forms\\FormMacros::install\n```\n\nSmažeme cache a profitujeme. Nyní se autospam vykresluje automaticky i při manuálním renderování... :)\n\nPodobně lze samozřejmě přidat i další kontroly jako je například kontrolní součet dvou čísel, který se javascriptem předvypočte automaticky, ale s vypnutým javascriptem se zobrazí políčka pro uživatele. Řešení tohoto antispamu je také [na mém Gistu](https://gist.github.com/mrtnzlml/961c3e2368e98aaa433e02c6603a5086). Jen je potřeba trošku rozšířit `HoneypotExtension`:\n\n```php\npublic static function registerControlExtensionMethods()\n{\n\tForm::extensionMethod('addAntispam', function (Form $form, $name = 'honeypot', $label = 'Vymažte toto pole') {\n\t\t$form[$name . '_1'] = new \\App\\AntispamControl($name, $label);\n\n\t\t$first = round(rand(0, 900), -2);\n\t\t$second = rand(0, 99);\n\t\t$validationData = self::encodeNumber($first) . ';' . self::encodeNumber($second);\n\t\t$form->addHidden('validationData', $validationData)->setOmitted(TRUE)->setOption('autorender', TRUE);\n\t\t$form[$name . '_3'] = new \\App\\Forms\\SumAntispamControl($first, $second, $validationData);\n\n\t\treturn $form;\n\t});\n}\n\nprivate static function encodeNumber($originalNumber)\n{\n\treturn strtr($originalNumber, '0123456789', '(_.!)@-*+&'); //cannot contain ';' character\n}\n```\n\nPůvodní kód zůstává stejný, jen jsem přidal další kontrolu a zakódoval číslice tak, aby nebylo jednoduché na první pohled poznat princip tohoto antispamu. Ve fantazii se meze nekladou.\n\nA právě v tom je možná trošku problém. Zejména kvůli autorender funkci je potřeba zasahovat do vnitřností Nette a zde je již na pováženou, jestli je to dobře či nikoliv. Velké úskalí vidím v tom, že si programátor vyměňuje stavební kameny Nette za svoje trošku upravené a to nemusí být vždy hned evidentní. Pak je na zamyšlenou, jestli by nestálo za to vytvořit PR. Kdo by ale stál o takovou hovadinu... :)","frontmatter":"id: 103fd545-2922-4c42-b50c-6387a1f05d48\ntimestamp: 1475925989000\ntitle: Automatický render prvků při manuálním vykreslování formuláře\nslug: automaticky-render-prvku-pri-manualnim-vykreslovani-formulare"},{"attributes":{"id":"1b9f9c28-3652-47e8-ba52-9ffcb7455f18","timestamp":1474881018000,"title":"Shhhh - vysílá se speaker","slug":"shhhh-vysila-se-speaker"},"body":"Takové bylo téma celého Webexpa 2016 - shhhh. Nebo alespoň páteční části. Pro ty nejlepší a nejzajímavější řečníky byl totiž připraven velký sál, kam se podle cedulek na dveřích vejde až 2500 lidí. A nápad to byl zcela zajisté skvělý. Ovšem jen do chvíle, než začala první přednáška. V davu lidí totiž existuje efekt, kdy pokud něco říkám a jsem špatně slyšet - začnu mluvit více nahlas. A tak to udělá každý. Takže to byl první den **megašrumec**. A do toho přednášky. Úplně si dovedu představit, že to byla pro přednášející jedna z nejnáročnějších přednášek vůbec. I ze strany posluchače to bylo náročné - dokonce jsem párkrát přestal vnímat přednášku, protože to bylo fakt maso. Nechtělo se mi vracet se do toho sálu zpět na další skvělé přednášky. V sobotu už to bylo relativně ok.\n\nAle řešit hluk, když jsem si mohl poslechnout spoustu skvělých přednášek by bylo malicherné. Věc se má tak. Pokaždé, když jedu na nějakou akci tohoto typu, jsem na vážkách. Na jednu stranu vím, že si poslechnu nějakou úžasnou přednášku a budu z toho úplně paf. Pak jsou zde však takové u kterých si člověk říká - proč to je na Webexpu? A přesně to se stalo.\n\nPrvní den nezačal nejlépe (moje chyba), ale hned to zachránil Jakub Plichta z Adobe Typekit, Mark Boulton z Monotype a Lukáš Linhart - Apiary. Nemá smysl vyjmenovávat úplně všechny - sorry - ale u těchto lidí bych doporučil podívat se na video kdo neviděl. Přednášky se poměrně rychle dostávají na internet rovnou na koukačku (netrvalo to ani 24 hodin od konce akce - **dobrá práce**). Zajímavá byla také přednáška od Roberta Kerra - chvíli jsem nevěděl, chvíli jsem chtěl tleskat, potom zase plakat a nakonec jásat. Robert se nám snažil předat způsob, jak držet v prezentacích tzv. beaty stejně jako ve filmech.\n\n**No a pak se to stalo.** Ačkoliv jsem necítíl žádnou joy emoci, přece jenom tam ta mrška byla. V noci jsem nemohl dospat a v polovině noci jsem se vzbudil a začal tvořit. Takovou silou na mě působí podobné akce. Naposledy jsem toto udělal, když jsem se snažil vyrovnat jet lag. A to všechno jen díky té inspiraci, kterou jsem přes celý den nasál. Už jen proto doporučuji.\n\nRáno šup na pendolíno a hurá do Prahy - spánek nespánek. Mimochodem díky za [aplikaci do telefonu](https://play.google.com/store/apps/details?id=eu.touchart.webexpo). Nedívejte se na hodnocení - nejste na internetu poprvé. Já jsem tohoto pomocníka skutečně uvítal a používal. **Dobrá práce.**\n\nNa druhý den jsem se vyloženě těšil. A to hlavně z toho důvodu, že byl pro mě jako pro vývojáře daleko zajímavější. Největší lákadlo byl Marco Pivetta. Jasně - tu prezentaci už znám skoro pozpátku, ale slyšet to živě je něco úplně jiného. A tak nějak to šlo celý den. Určitě jsem byl v jednu chvíli v limbu a s otevřenou pusou jsem tiše přikyvoval hlavou v domění, že jsem v sále sám a přednášející to povídá jen pro mě... :) Už jsem se zmínil o burritu? Nemám moc rád mexický druh jídel, ale jestli jsem se najedl? Oh boy - to byl ale macek. *(možná to bylo proto, že jsem se pořád něčím ládoval)*\n\nJak den pomalu pokračoval a já se ustavičně dostával z jednoho limbo stavu do dalšího, pomalu (díky Nina Zakharenko a Marko Iskander) se blížila poslední přednáška. Opět jsem nevěděl co čekat a plánoval jsem poté jít ještě na jednu přednášku. Ale to jsem ještě nevěděl, že mě čeká nejlepší přednáška vůbec a že nebudu schopen utrhnout se a neúčastnit se rozhovoru s Michaelem Loppem. Víte, že **jsem volatile**? Já to nevěděl. Vlastně jsem ani nevěděl co to je. Věděl jsem, že je něco špatně - že jsem tak tošku buřič. A tak jsem hledal způsob jak se polepšit. Většina lidí je totiž **stable**, tak bych měl být také. No ne? **Špatně!** Teď už to neberu jako takovou nevýhodu a jsem za to vlastně i rád. Stable mi prostě nesedí (alespoň ne zatím). Jen jsem musel počkat několik let abych pochopil sám sebe.\n\n```html\n<div id=\"presentation-embed-38898202\"></div>\n<script src='http://slideslive.com/embed_presentation.js'></script>\n<script>\n    embed = new SlidesLiveEmbed('presentation-embed-38898202', {\n        presentationId: '38898202',\n        autoPlay: false // change to true to autoplay the embedded presentation\n    });\n</script>\n```\n\n<br>\n**Děkuji Webexpo 2016.** Děkuji za skvělou lekci o mé povaze, děkuji za skvělé řečníky. Každé Webexpo bylo historicky tím největším Webexpem. A já to naprosto chápu a nepochybuji, že trend bude i nadále stejný. Díky také moderátorům. Daniel Čech? Jasně - o tom snad nikdo nepochyboval, ale byl jsem příjemně překvapen ze vstupů Pavlíny Louženské - **skvělé**.\n\nDost superlativů.<br>\nJo a to tričko je taky super!","frontmatter":"id: 1b9f9c28-3652-47e8-ba52-9ffcb7455f18\ntimestamp: 1474881018000\ntitle: Shhhh - vysílá se speaker\nslug: shhhh-vysila-se-speaker"},{"attributes":{"id":"529dbd88-7b85-4e8a-9954-90aef87980cd","timestamp":1471811573000,"title":"10 obsesí na WebExpu 2016","slug":"10-obsesi-na-webexpu-2016"},"body":"**Obsese** ž. *kniž.* chorobně utkvělá představa, myšlenka; *med.* nutkavé jevy, nejčastěji myšlenky, popudy k jednání apod., jež jsou nesmyslné a bezdůvodně ovládají mysl nemocného, ačkoliv se je snaží potlačit\n\n**Obsession** it's kind of like a passion for something that crosses the line into crazy territory ([source](https://www.vocabulary.com/dictionary/obsession))\n\nTrpíte nějakou obsesí? Letošní WebExpo nabízí lék ve formě přednášek, které jsou rozděleny do deseti okruhů - [obsesí](https://webexpo.cz/praha2016/obsessions/) - po vzoru zahraničního magazínu [Quartz](http://qz.com/obsessions). Hlavním cílem je lépe uspořádat jednotlivá témata podle společných problémů, takže si každý snadno najde co jej zajímá. Zároveň každou obsesi zosobňuje celá řada (většinou) světově známých jmen, takže je na co se těšit.\n\n*\"Vyhledejte odbornou pomoc dříve, než vám obsese přerostou přes hlavu!\"* .{font-size:140%; color:gray}\n\nProč se vlastně tak snažím chodit na nějaké takové akce a namotivovat i další lidi? Kdo neviděl, mrkněte se na následující video. Zejména kolem času 15:08 mluví Honza Černý o tom, v čem to celé vězí. *\"Existují dvě skupiny lidí. Lidi kteří se chtějí vzdělávat (a vzdělavají se) a pak ta druhá skupina lidí, kterým to je jedno...\"*\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/1BjVVGmSdCw?list=PLqRXa8pInSUqxMhNhzJsV-1_FZ-YsrSYM\" frameborder=\"0\" allowfullscreen></iframe>\n\nLidi typu *\"je mi to jedno\"* (sem tam) potkávám a je mi z toho občas tak smutno, až jsem si vytvořil vnitřní potřebu vzdělávat se - nezakrnět. A těžko budu hledat lepší akci při boji se zakrněností, než je největší webová konference ve Střední Evropě - WebExpo. Vždyť je tolik důležité zažívat onen známý [The 'Just-got-back-from-a-conference' effect](http://www.commitstrip.com/en/2016/04/26/the-just-got-back-from-a-conference-effect/)... :)\n\nDruhou stránkou věci je potom potkávat lidi. To jsem se asi nejvíc naučil na PoSobotách. A ačkoliv s tím mám trošku introvertní problém, tak si musím přiznat, že právě ostatní lidé (netrpící krněním) nejvíce motivují a posouvají. Zvučných jmen je WebExpo plné. Jmenovitě například:\n\n- Michael Lopp ([Stables and Volatiles – how to get different types of humans to work together](https://webexpo.cz/praha2016/prednaska/stables-and-volatiles-how-to-get-different-types-of-humans-to-work-together/)) - pracovně původně Apple, Pinterest a současně Slack\n- Harry Roberts ([Refactoring CSS Without Losing Your Mind](https://webexpo.cz/praha2016/prednaska/refactoring-css-without-losing-your-mind/)) - klienty například Google, Unilever nebo BBC\n- Peter Morville ([The Architecture of Understanding](https://webexpo.cz/praha2016/prednaska/the-architecture-of-understanding/)) - Semantic Studios\n- Mark Boulton ([Design systems in difficult places](https://webexpo.cz/praha2016/prednaska/design-systems-in-difficult-places/)) - Monotype\n- Rachel Andrew ([The right layout tool for the job](https://webexpo.cz/praha2016/prednaska/the-right-layout-tool-for-the-job/)) - Perch CMS\n- Marco Pivetta ([Extremely defensive PHP](https://webexpo.cz/praha2016/prednaska/extremely-defensive-php/)) - Roave (you know Doctrine right?)\n\nŘečníků je samozřejmě [mnohem více](https://webexpo.cz/praha2016/recnici/) (70). Je asi zřejmé, že se nejvíce těším na technické přednášky, tedy obsese [Creative Technology](https://webexpo.cz/praha2016/obsessions/#creative-technology) <span class=\"label label-success\">TIP</span>. Tím spíše na Marco Pivettu, kterého jistě dobře znáte jako [Ocramiuse](https://twitter.com/Ocramius), protože si jej vážím jako velmi zkušeného programátora a většinu jeho věcí přijímám s němým úžasem. Na výběr jsou však další obsese:\n\n- Thinking & Doing ([link](https://webexpo.cz/prague2016/obsessions/#thinking-doing)) <span class=\"label label-success\">TIP</span> - design\n- Understanding Communication ([link](https://webexpo.cz/prague2016/obsessions/#understanding-communication)) - reklama\n- Visual Inventions ([link](https://webexpo.cz/prague2016/obsessions/#visual-inventions)) - grafika\n- Touch and Move ([link](https://webexpo.cz/prague2016/obsessions/#touch-and-move)) - interakce\n- Data Crunching ([link](https://webexpo.cz/prague2016/obsessions/#data-crunching)) - zpracování dat\n- Machine Brains ([link](https://webexpo.cz/prague2016/obsessions/#machine-brains)) - práce s daty\n- Monetizing Eyeballs ([link](https://webexpo.cz/prague2016/obsessions/#monetizing-eyeballs)) - business\n- Beyond The Screens ([link](https://webexpo.cz/prague2016/obsessions/#beyond-the-screens))\n- A-Team ([link](https://webexpo.cz/prague2016/obsessions/#a-team)) <span class=\"label label-success\">TIP</span> - týmová spolupráce\n\nA osobně chci navštívit nejen technické přednášky, ale podívat se i na přednášky z úplně jiných oborů, protože 1) nikdy to není z úplně jiného oboru a 2) rozšířit si obzory nikdy neuškodí. Přednášky jsou v jednotlivých obsesích rozděleny na tři bloky: development (zelené přednášky), business (oranžové), design (fialové). Skvělé je, že [program](https://webexpo.cz/praha2016/program/) na tyto barvy myslí a tak *téměř* nikdy neběží souběžně dvě stejné kategorie. A teď pozor - vstupenky jsou [za zvýhodněnou cenu](https://webexpo.cz/praha2016/vstupenky/) pouze do konce tohoto měsíce.\n\nAkce proběhne 23. — 24. září 2016 v Praze konkrétně v [Paláci Lucerna](http://www.lucerna.cz/cz/) a očekávaná návštěvnost je 2000 offline lidí. Pro více informací doporučuji sledovat blog [WebExpo píše](https://medium.com/webexpo), kde jsou někteří řečníci představeni podrobně.\n\nTak WebExpojď... ;)\n\nBtw - akce trvá dva dny, což znamená 3 party. Warm Up ve čtvrtek [tady](https://www.laloca.cz/en), páteční [tady](http://www.skautskyinstitut.cz/staromak) a After Party [tady](http://www.prague.eu/en/object/places/63/lucerna-palace-great-hall-palac-lucerna-velky-sal).\n\n[![](http://s2.quickmeme.com/img/e9/e9b82533f50538f4d36656f24bf2afb39642223033cd19d52ef1eea5b03ab1bf.jpg)](https://webexpo.cz/prague2016/)","frontmatter":"id: 529dbd88-7b85-4e8a-9954-90aef87980cd\ntimestamp: 1471811573000\ntitle: 10 obsesí na WebExpu 2016\nslug: 10-obsesi-na-webexpu-2016"},{"attributes":{"id":"f856b454-c4a5-4271-8888-521ef1358f45","timestamp":1470502440000,"title":"More awesome Monolog for","slug":"more-awesome-monolog-for-nettefw"},"body":"Nedávno mi přišel požadavek na vytvoření takového jednoduchého způsobu, jak logovat uživatelské akce - konkrétně zatím jen přihlášení uživatele (do databáze). Mohl jsem to udělat jednoduše a prostě to někam do kódu nahákovat. A nebo jsem to mohl udělat tak, jak jsem to také nakonec udělal - složitě. Samozřejmě je třeba dopředu dostatečně promyslet, jestli to za tu práci stojí, ale měl jsem dostatek argumentů proto, že ano.\n\nJedna z nejdůležitějších myšlenek byla, že časem bude pravděpodobně potřeba logovat do databáze i další akce, než je jen přihlašování. Druhým velmi silným faktorem (který ovlivnil celé řešení) bylo, že používáme [Monolog](https://github.com/Seldaek/monolog). Konkrétně Kdyby\\Monolog rozšíření.\n\n# Kdyby Monolog\n\nZnáte tuto knihovnu ([GitHub](https://github.com/Kdyby/Monolog))? Věřím, že ano. Kolem Kdyby knihoven byl velký hype. Velká síla této knihovny je v tom, že se dokáže velmi jednoduše napojit na Tracy a to takovým způsobem, že můžete používat Monolog bez BC breaku (tedy pomocí `Tracy\\Debugger::log()`). Větším přiblížením k Monologu jako takovému, je pak používání služby `Kdyby\\Monolog\\Logger` resp. `Monolog\\Logger` jako závislosti v konstruktoru.\n\nKdyby logger pak obsahuje tato nastavení (ne všechny jsou v dokumentaci):\n\n```neon\nmonolog:\n\thandlers: []\n    processors: []\n    name: app\n    hookToTracy: yes\n    tracyBaseUrl: NULL\n    usePriorityProcessor: yes\n    registerFallback: yes\n```\n\nPro programátora je asi nejzajímavější možnost nastavit si vlastní [handlery](https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md#handlers) a [procesory](https://github.com/Seldaek/monolog/blob/master/doc/02-handlers-formatters-processors.md#processors). Pozornějšímu oku však neunikne, že toto nastavení funguje globálně pro celou aplikaci. Jenže občas se hodí mít více loggerů a každý mít nastavený jinak. Nevím, jestli jsem náhodou Kdyby\\Monolog nepochopil špatně, ale jedinou šancí jak toho dosáhnout, je nenastavoval logger v configu, vytvořit si vlastní `Logger` objekty a ty si nastavit (`pushHandler`, `pushProcessor` a `setFormatter` u handlerů). A to je naprd.\n\n# Adeira Monolog\n\nMít více vlastních loggerů už se mi párkrát hodilo. A právě i zde by bylo super mít objekt, který mi umožní jednoduše něco zalogovat do databáze. Zároveň je však super propojení s Tracy, které má tak skvělě vyřešené Kdyby\\Monolog. Jak z toho vybruslit? Vlastním Composer balíčkem. Než se dostanu k samotné instalaci a nastavení, ukážu zde, jak jsem využil vlastní logger. Pořád však mějte na paměti, že si kdykoliv musím být schopen sáhnout na původní `Kdyby\\Monolog\\Logger` a vesele logovat podle globálního nastavení!\n\nPrvně jsem si vytvořil vlastní logger:\n\n```php\n<?php\n\nnamespace App\\Audit\\Monolog\\Loggers;\n\nclass UsersAuditLogger extends \\Monolog\\Logger\n{\n\n}\n```\n\nPřesně, víc toho není potřeba. Tento objekt vlastně slouží jen k tomu, abych měl co předávat v konstruktoru jako závislost. A zároveň je to ta nejdivnější část - teď už to bude jen lepší. Teď by bylo fajn mít vlastní handler, který mu později přiřadíme a který se bude starat o to ukládání do databáze. Šlo by udělat to, že by handler skutečně ukládal rovnou do databáze, ale použiju zde malý fígl:\n\n```php\n<?php\n\nnamespace App\\Audit\\Monolog\\Handler;\n\nclass UsersAuditDatabaseHandler extends \\Monolog\\Handler\\AbstractProcessingHandler\n{\n\n\t/** @var \\App\\Audit\\EntitiesQueue */\n    private $entitiesQueue;\n\n\tpublic function __construct(\\App\\Audit\\EntitiesQueue $entitiesQueue)\n\t{\n\t\t$this->entitiesQueue = $entitiesQueue;\n\t\tparent::__construct(\\Monolog\\Logger::DEBUG, TRUE); //TRUE - bubble\n\t}\n\n\tprotected function write(array $record)\n    {\n        $auditRecord = new \\App\\Audit\\AuditRecord($record['level'], $record['message'], $record['datetime']);\n        $this->entitiesQueue->add($auditRecord);\n    }\n\n}\n```\n\nJe to jen zjednodušený příklad. Důležité ale je, že jsem zde zatím nic neuložil, ale pouze to zařadil do jakési fronty na entity. To proto, že logů může být více a chci si je napřed všechny posbírat a následně je v jedné transakci poslat do databáze. Objekt `AuditRecord` je obyčejná Doctrine entita. `EntitiesQueue` je jednoduchý objekt, který tyto entity sbírá a zároveň naslouchá na `Application::onShutdown`:\n\n```php\n<?php\n\nnamespace App\\Audit;\n\nclass EntitiesQueue implements \\Kdyby\\Events\\Subscriber\n{\n\t//závislosti, prázdné pole, metoda 'add' atd. ...\n\n\tpublic function getSubscribedEvents()\n    {\n        return ['Nette\\Application\\Application::onShutdown' => 'onShutdown'];\n    }\n\n    public function onShutdown()\n    {\n        foreach ($this->entities as $entity) {\n            $this->em->persist($entity);\n        }\n        $this->em->flush();\n        $this->entities = [];\n    }\n\n}\n```\n\nVeškeré logy se tedy uloží až v okamžiku, kdy aplikace ukončuje svůj životní běh (podobný princip se používá i při práci s RabbitMQ). Použití je pak triviální. V jiném listeneru naslouchám na událost `Nette\\Security\\User::onLoggedIn` a v tomto okamžiku zaloguji zprávu. Ten vlastní `UsersAuditLogger` je zde jako závislost.\n\n```php\n$this->usersAuditLogger->addInfo(\"User with login '$login' logged into administration.\");\n```\n\n# Instalace a nastavení balíčku\n\nOk, cool - jak to použiju? Úplně jednoduše:\n\n```\ncomposer require adeira/monolog\n```\n\nNásledně zaregistrujeme rozšíření do DIC:\n\n```neon\nextensions:\n    monolog: Adeira\\Monolog\\DI\\MonologExtension\n```\n\nA dále už to znáte. Následuje krátká ukázka toho, co se s tím dá dělat za švíky. Tento balíček sám od sebe registruje spoustu formátovačů, procesorů a jeden handler z Monologu ([viz readme](https://github.com/adeira/monolog/blob/master/readme.md)). Ty je pak možné jednoduše používat pouze podle jejich názvu. Zároveň je zachována téměř veškerá funkcionalita Kdyby\\Monologu (ano, můj balíček toto rozšíření rozšiřuje, protože napojení na Tracy je fakt super). Mohu si pak nastavit loggery třeba takto:\n\n```neon\nmonolog:\n\thookToTracy: yes\n\tregisterFallback: yes\n\tusePriorityProcessor: yes\n\n\tprocessors:\n\t\tweb: Monolog\\Processor\\WebProcessor(NULL, [\n\t\t\t\tip: REMOTE_ADDR,\n\t\t\t\tuserAgent: HTTP_USER_AGENT,\n\t\t\t])\n\n\thandlers:\n\t\tdatabase:\n\t\t\tclass: App\\Audit\\Monolog\\Handler\\UsersAuditDatabaseHandler\n\t\t\tprocessors: [web]\n\t\tslack:\n\t\t\tclass: Adeira\\Monolog\\Handler\\SlackHandler(\n\t\t\t\tproductionMode: %productionMode%,\n\t\t\t\ttoken: '.....',\n\t\t\t\tchannel: exceptions,\n\t\t\t\tusername: 'Monolog',\n\t\t\t\tuseAttachment: no,\n\t\t\t\ticonEmoji: poop,\n\t\t\t\tlevel: Monolog\\Logger::CRITICAL,\n\t\t\t\tbubble: yes,\n\t\t\t\tuseShortAttachment: no,\n\t\t\t\tincludeContextAndExtra: yes,\n\t\t\t)\n\n\tloggers:\n\t\tglobal: #global logger from Kdyby (\\Kdyby\\Monolog\\Logger)\n\t\t\thandlers: [slack]\n\t\t\tprocessors: [git, web]\n\t\t- class: App\\Audit\\Monolog\\Loggers\\UsersAuditLogger\n\t\t  handlers: [database]\n```\n\nA teď slovně. V sekci `processors` měním chování `web` procesoru. Ten je sice již zaregistrovaný, ale nelíbí se mi jeho chování. Vlastní konfigurace má přednost. Dále přidávám dva nové handlery (`database` a `slack`). Databázový handler používá procesor `web` na které jsem se odkázal jen pomocí názvu. O propojení se již postará knihovna sama. V balíčku je připravený handler `SlackHandler`, který navíc oproti původnímu z Monologu chová tak, že zprávičky posílá jen jednou za 15 minut. To může být užitečné... :-)\n\nNo a konečně samotné loggery. Logger z Tracy lze nastavit pomocí speciální sekce `global`. Zde si nastavuji slack handler a 2 procesory. Zároveň přidávám ještě vlastní logger (registruje se stejně jako v sekci `services`) a nastavuji mu databázové handler. A o to vlastně celou dobu šlo.\n\nPretty cool, hm? [PR a hvězdičky prosím sem](https://github.com/adeira/monolog)... :)\n\nDodatečné odkazy na čtení:\n- [Logging with Monolog](http://symfony.com/doc/current/logging.html)\n- [How to Log Messages to different Files](http://symfony.com/doc/current/logging/channels_handlers.html)\n- [Configure multiple loggers and handlers](https://github.com/theorchard/monolog-cascade)\n\n[Follow me on Twitter and stay tuned](https://twitter.com/mrtnzlml)...","frontmatter":"id: f856b454-c4a5-4271-8888-521ef1358f45\ntimestamp: 1470502440000\ntitle: More awesome Monolog for #nettefw\nslug: more-awesome-monolog-for-nettefw"},{"attributes":{"id":"bc0e2a48-6c0d-4dcb-b686-ac5eecc11c88","timestamp":1469950790000,"title":"Dva šablonovací systémy zároveň","slug":"dva-sablonovaci-systemy-zaroven"},"body":"Možná pracujete na nějakém projektu, který používá jiný šablonovací systém než je Latte, ale Latte se vám natolik líbí, že ho chcete používat také. Nebo naopak používáte Latte, ale *<abbr title=\"Smarty? Twig? Wtf? Omg?\">[doplň název šablonovacího systému]</abbr>* se vám natolik líbí, že ho chcete používat také. A nebo prostě nemáte na výběr a musíte používat více šablonovacích systémů. V takovém případě existuje asi jediné přímočaré řešení a tím je vlastní implementace `Nette\\Application\\UI\\ITemplate`.\n\n# TemplateFactory\n\nOno to vlastně zase až tak přímočaré není. Je v tom totiž malý háček. V současné době fungují Latte šablony tak, že existuje továrna `TemplateFactory`, jejíž úkolem je vytvářet `Template` objekty. Originální implementace, kterou používá většina lidí (`Nette\\Bridges\\ApplicationLatte\\Template`) pouze deleguje renderování přímo na Latte. Nabízelo by se tedy nahradit tento objekt svým vlastním a delegovat renderování jednak na Latte a jednak třeba na Smarty. Háček je však v tom, že `Template` není služba zaregistrovaná v DIC, takže není jednoduché ji nahradit.\n\nProto aby bylo možné nahradit objekt `Template` vlastním, je nutné nahradit také `TemplateFactory`. Tento objekt vytváří nové instance třídy `Template` a tyto objekty dále nastavuje (přidává filtry, makra, proměnné, providery, prostě Nette specific věci). Nešvar s nahrazováním celé továrničky se už pár lidí [snažilo vyřešit](https://github.com/nette/application/issues/141), ale nikdy to nikdo nedotáhl do konce (včetně mě). Jak to tedy udělat teď?\n\nV první řadě je třeba vytvořit si vlastní `TemplateFactory`:\n\n```php\n<?php\n\nclass TemplateFactory implements Nette\\Application\\UI\\ITemplateFactory\n{\n\t//...\n}\n```\n\nTo v podstatě znamená copy paste původní továrny. Je to trošku nepříjemné, ale je možné z toho těžit. Můžeme se například zbavit deprecated věcí, nebo si libovolně nakonfigurovat `Template` objekt. Podstatné je, že v `createTemplate` metodě vytváříme vlastní instanci `Template` objektu.\n\nTeď přijde ta důležitá část na kterou nesmíme zapomenout. Novou vlastní `TemplateFactory` zaregistrujeme do konfiguračního souboru jako službu:\n\n```php\nservices:\n\tlatte.templateFactory: Ant\\TemplateFactory\n```\n\nTento zápis zajistí to, že se nejen `TemplateFactory` přidá do DI kontejneru, ale zároveň se nahradí původní implementace (proto to `latte.templateFactory` - důležité).\n\n# Template\n\nSamotný `Template` objekt už je pak prkotina. Stačí pouze změnit implementaci metody `render`. Já osobně jsem to řešil tak, že podle toho jaká přijde koncovka souboru, tak nabídnu ten správný engine pro vykreslení. Třeba nějak takto:\n\n```php\npublic function render($file = NULL, array $params = [])\n{\n\t$file = $file ?: $this->getFile();\n\n\tif (Strings::endsWith($file, '.latte') || $this->getLatte()->getLoader() instanceof \\Latte\\Loaders\\StringLoader) {\n\t\t//tady mám něco hustého co ukážu jindy\n\n\t\t$this->getLatte()->render($file, $params + $this->getParameters());\n   \t} else { //Smarty fallback\n   \t    //peklo které nechce nikdy vidět\n\n\t\t$providers = $this->getLatte()->getProviders();\n        /** @var \\Nette\\Application\\UI\\Presenter $presenter */\n        $presenter = $providers['uiPresenter'];\n        if ($presenter->isAjax()) {\n            $this->page->fetch($file);\n        } else {\n            $this->page->display($file);\n        }\n   \t}\n}\n```\n\nTrošku jsem to zjednodušil aby byla podtržena myšlenka. Doporučím však ještě jednu věc a to podědit si vlastní template od `Nette\\Bridges\\ApplicationLatte\\Template`. Chce to trošku si s tím pohrát, ale hlavní benefit bude vidět za chvíli. Zejména je dobré zaměřit se na `__set`:\n\n```php\npublic function __set($name, $value)\n{\n\t$this->assignToSmarty($name, $value); //DIY\n\tparent::__set($name, $value);\n}\n```\n\nTeď je totiž možné používat klasické `$this->template->variable = 'xyz';` a tato proměnná bude k dispozici bez ohledu na způsob vykreslení.\n\n# Gotchas a benefity\n\nKaždý teď tedy může používat například v komponentách `$this->template->render('***.tpl');` a zároveň mít třeba layout v Latte. Je to fuk. A to je cool. Je však třeba mít neustále na mysli, že nelze jednotlivé vykreslovací způsoby používat úplně nahodile. Styčiný bod je render metoda. Nelze tedy například používat include v Latte a vyžadovat tam šablonu ze Smarty.\n\nAsi největší nachytávka jsou snippety. Na to jak udělat podporu snippetů do Smarty se můžeme podívat jindy - není to nic složitého. Problém byl však u kombinování jednotlivých způsobů vykreslení a předávání `snippetMode` příznaku. `snippetMode` vlastně říká, jestli se má šablona vykreslit jako snippet (tedy jen podčásti) a vrátit v payloadu. Když jsem však použil komponentu ve Smarty (vlastní `{control name=test}`) a v této komponentě normální Latte šablonu obsahující snippety, tak to prostě nemohlo fungovat. Asi nejjednoušší řešení bylo v tomto případě trošku ohnout `Template` a `snippetMode` prostě přes tu aplikaci protlačit:\n\n```php\n$presenter = $this->getLatte()->getProviders()['uiPresenter'];\nif ($presenter->isAjax()) {\n\t//propagate snippet mode into components (Smarty templates):\n\tforeach ($presenter->getComponents(TRUE) as $component) {\n\t\t$component->snippetMode = $presenter->snippetMode;\n\t}\n\t$this->page->fetch($file);\n} else {\n\t$this->page->display($file);\n}\n```\n\nNení to úplně stejné jako se chová Nette k Latte, ale účel to plní dobře a to jde... :)","frontmatter":"id: bc0e2a48-6c0d-4dcb-b686-ac5eecc11c88\ntimestamp: 1469950790000\ntitle: Dva šablonovací systémy zároveň\nslug: dva-sablonovaci-systemy-zaroven"},{"attributes":{"id":"8e78cf63-c20a-4fc9-b19e-46984abcb314","timestamp":1469363764000,"title":"Testbench 2.3 is out (finally)","slug":"testbench-2-3-is-out-finally"},"body":"Yeah, you heard that correctly. Testbench 2.3 has been released and it brings a lot of new features. I don't want to write about small bugfixes but about real improvements in testing environment. There was always one important mission in Testbench - to make testing easier for newcomers. And I am happy to show you biggest feature in this release: **scaffold**.\n\nImagine you have your own application but without tests (this is the best situation for scaffolding). Now you can generate whole testing environment using this single command:\n\n```\nvendor/bin/run-tests --scaffold tests/bootstrap.php\n```\n\nAs you can see, you have to prepare `bootstrap.php` before scaffold. You can find default one in [readme](https://github.com/mrtnzlml/testbench/blob/master/readme.md). Content of this file can be very simple:\n\n```php\n<?php\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nTestbench\\Bootstrap::setup(__DIR__ . '/_temp', function (\\Nette\\Configurator $configurator) {\n    $configurator->createRobotLoader()->addDirectory([\n        __DIR__ . '/../app',\n    ])->register();\n\n    $configurator->addParameters([\n        'appDir' => __DIR__ . '/../app',\n    ]);\n\n    $configurator->addConfig(__DIR__ . '/../app/config/config.neon');\n    //$configurator->addConfig(__DIR__ . '/tests.neon');\n});\n```\n\nJust remember, that it has to be possible to run application using this bootstrap in test environment. Look at this video where you can see how to use it:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/63Vn6Udg3xQ\" frameborder=\"0\" allowfullscreen></iframe>\n\nAnd how does it work exactly? At this very moment there is very simple idea in Testbench. Scaffold is firstly trying to find every possible presenter in Nette appliaction. Then there are two parts of scaffold process: collecting information and generating PHP code. Collecting information is the most challenging part of scaffold, but it's basically looking for *action*, *render*, *handle* and *createComponent\\** methods using reflection. It looks at the signature of the method and then it tries to run these methods to get the response. Now it's possible to generate whole testing class for every presenter in application.\n\nThis approach is great, because it's possible to generate tests according to the response, but there are some drawbacks as well. It may not be accurate. The most problematic part is parameter (even optional) guessing, because application can response on different parameters differently and it's not possible to figure out if it's expected behavior or not. This means that you always have to look at the generated tests and fix them if needed.\n\n# Another improvements and news\n\nI dropped support for PHP 5.4 and 5.5 because [they are dead](http://php.net/supported-versions.php). Currently supported PHP versions are only PHP 5.6 (LTS) and PHP 7.0 until 31 Dec 2018 and 3 Dec 2018 respectively. Deal with it if you are running older PHP. You shouldn't do that anyway.\n\nAnother big change has been introduced to the database behavior during tests. Now every single request to the database is going to the fake clean database even if you are not using TDoctrine or TNetteDatabase trait. At the very begining it was expected behavior to create databases only if you are using those traits, but it wasn't programmer friendly and sometimes it causes weird situations. I am working on another completely different transactional approach in [this branch](https://github.com/mrtnzlml/testbench/tree/transactional-db-tests), but it's going to be in next release (maybe). \n\nThere is another improvement in database testing. Testbench now supports **Doctrine migrations**! If you have migrations configured in your project, you can enable them in Testbench config like this:\n\n```neon\ntestbench\n\tmigrations: yes\n\tsqls:\n\t\t- %testsDir%/_helpers/sqls/mysql_1.sql\n\t\t- %testsDir%/_helpers/sqls/mysql_2.sql\n```\n\nTestbench will load SQLs and then it will run migrations to the latest version.\n\nThe last but not least important note is, that Testbench is at this moment using `dev-master` of Nette\\Tester. Mostly because of new awesome `-C` switch in command line. But this means that if you want to use Testbench 2.3, you have to omit Nette\\Tester version in `composer.json`, or use something line this:\n\n```js\n\"require-dev\": {\n\t\"nette/tester\": \"2.0.x-dev as v1.7\",\n\t\"mrtnzlml/testbench\": \"^2.3\"\n},\n```\n\nPlease [read release notes](https://github.com/mrtnzlml/testbench/releases/tag/v2.3) for further details. I hope you'll enjoy this release and Testbench becomes much more useful and powerful tool for testing thanks to you - Testbench user.","frontmatter":"id: 8e78cf63-c20a-4fc9-b19e-46984abcb314\ntimestamp: 1469363764000\ntitle: Testbench 2.3 is out (finally)\nslug: testbench-2-3-is-out-finally"},{"attributes":{"id":"7f009c6b-998c-4cef-8797-cf1853ac5ea7","timestamp":1466343012000,"title":"Fix compatibility with Nette 2.4","slug":"fix-compatibility-with-nette-2-4"},"body":"Právě v těchto dnech přichází další významná minor verze Nette balíčků do vašich vendorů. Událo se velké množství změn a to zejména pod kapotou. To si však s sebou nese určitou daň a tou je potřeba učinit pár úprav v kódu, které zajistí kompatibilitu. Těchto úprav není mnoho. A když už jsou, tak na ně Nette upozorní třeba prostřednictvím `E_USER_DEPRECATED`. Pokud však pracujete se složitější aplikací, která třeba nebyla původně postavená na Nette, může být taková úprava docela lopota.\n\nZde se tedy nedočtete co je v Nette nového, ale jak co upravit a na co jsem narazil, když jsem tuto kompatibilitu rešil.\n\n# Úpravy v Latte\n\nJelikož pracuji na starším projektu, který je původem non-Nette, tak je zvykem používat PHP konstanty. Všude. Zatímco dříve stačilo používat `{=NAZEV_KONSTANTY}`, teď je nutné konstantu přímo označit `{=constant('NAZEV_KONSTANTY')}`, aby bylo jednoznačně jasné, že se jedná skutečně o konstantu. Jedna z velmi užitečných vlastností Latte bylo to, že nebyl problém napsat PHP kód do klasických PHP tagů `<?php`. Existovalo makro `{?`, ale dnes je doporučované pouze `{php ...}`. Toto je zároveň jediná věc, která mě štve, protože dříve bylo převádění externích šablon do Latte velmi jednoduché. Tímto se vše komplikuje.\n\nVelké změny jsou pod kaptou Latte. Pokud máte vlastní `Template` objekt (a tedy i vlastní `TemplateFactory`, protože to jinak udělat nejde), doporučuji udělat aktualizaci podle masteru. Asi nejzásadnější změna je právě v `TemplateFactory` při naplňování šablony:\n\n```php\n// default parameters\n$template->user = $this->user;\n$template->baseUri = $template->baseUrl = $this->httpRequest ? rtrim($this->httpRequest->getUrl()->getBaseUrl(), '/') : NULL;\n$template->basePath = preg_replace('#https?://[^/]+#A', '', $template->baseUrl);\n$template->flashes = [];\nif ($control) {\n\t$template->control = $control;\n\t$template->presenter = $presenter;\n\t$latte->addProvider('uiControl', $control);\n\t$latte->addProvider('uiPresenter', $presenter);\n\t$latte->addProvider('snippetBridge', new Nette\\Bridges\\ApplicationLatte\\SnippetBridge($control));\n}\n$latte->addProvider('cacheStorage', $this->cacheStorage);\n```\n\nNově se používají tzv. providery, které lze získat takto: `$template->getLatte()->getProviders()`. Pokud tedy máte např. vlastní Latte makra, tak ty je zapotřebí změnit v tomto duchu: z `$_control->link(...` na `$this->global->uiControl->link(...`.\n\n# Úpravy v Nette\n\nRelativně nedávnou změnou je absence metody `Nette\\Utils\\Html::add`. Ta je nahrazena kombinací `addText` resp. `addHtml`. Touto změnou by se mělo zajistit, že programátor nepošle do šablony HTML kód o kterém si myslí, že je escapovaný, ale on ve skutečnosti není.\n\nAsi největší myšlenkový obrat způsobila změna chování rout. Konkrétně `Route::SECURED`. Od samého začátku co dělám s Nette jsem tento příznak chápal blbě a [nejsem sám](https://forum.nette.org/cs/26348-route-secured-nevynucuje-https-100). Nově Nette zachovává takový protokol, s kterým uživatel přišel. Pokud potřebujete aplikaci na HTTPS, tak správné řešení je nastavit toto chování na úrovni serveru, třeba takto:\n\n```\nRewriteCond %{HTTPS} !=on\nRewriteRule ^(.*)$ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n```\n\nPokud i přesto potřebujeme generovat odkazy v aplikaci s HTTPS (k čemuž byl určen `Route::SECURED` příznak), můžeme tak učinit vepsáním protokolu do masky routy. Dva příklady řeknou více než tisíc slov:\n\n```php\n$router[] = new Route('rss/novinky.php', 'Front:Rss:novinky'); //celý web je na HTTP\n$this->link('//:Front:Rss:novinky'); //vygeneruje: http://example.com/rss/novinky.php\n\n$router[] = new Route('https://%host%/rss/novinky.php', 'Front:Rss:novinky'); //celý web je stále na HTTP\n$this->link('//:Front:Rss:novinky'); //vygeneruje: https://example.com/rss/novinky.php\n```\n\nVe stejném smyslu je zapotřebí upravit i [vlastní routery](https://github.com/mrtnzlml/static-router/commit/0b3ab17472cf2d051f7e4b9878354f3446cc55ff). Takže zpátky z šicím strojům opravit si aplikace... :)\n\n# Pár dalších drobností a postřehů\n\nMísto `Nette\\Object` je teď možné používat traitu `Nette\\SmartObject`. Tato traita se od svého předchůdce liší v několika drobnostech. Více informací je rozepsáno v [tomto vláknu na fóru](https://forum.nette.org/cs/26250-pojdte-otestovat-nette-2-4-rc#p173934). S tím se váže to, že občas je potřeba změnit podobné zápisy: z `$this->reflection` na `$this->getReflection()`. Drtivá část věcí se snad odladila, takže není třeba nic řešit. Jsou však místa (jako ta reflexe), kdy si to raději změním ve svém kódu.\n\nJak se na fóru dočtete, tak `Nette\\SmartObject` nepodporuje [extension methods](https://doc.nette.org/cs/2.3/php-language-enhancements#toc-rozsirujici-metody). To se často využívá u vlastních formulářových prvků. Náhrada je opět jednoduchá a logická:\n\n```php\nBaseControl::extensionMethod('addHelp', function (... //původně\nObjectMixin::setExtensionMethod(BaseControl::class, 'addHelp', function (... //nově\n```\n\nS čím jsem měl trošku problémy byla Tracy. Jedna z rad byla vypnout debugger, ale toto by již mělo být vyřešené:\n\n```neon\nsession:\n\tdebugger: no\n```\n\nPokud se vám tedy načítá stránka bez zjevného důvodu dlouho, vyzkoušejte vypnout tento panel. Asi nejvíce problémy budou dělat knihovny třetích stran. Zejména Kdyby mi dělá největší vrásky na čele. Bohužel autor nemá čas tyto věci řešit, takže [celý internet čeká](https://github.com/Kdyby/Events/pull/100)... :) Zároveň se např. v Kdyby/Doctrine (`dev-master` kde je lecos již opravené) oddělilo několik komponent do vlastních repozitářů. To se ukázalo jako překvapivě velký BC break, který nemá jednoduché řešení. Například zatímco dříve měl Testbench Doctrine jako volitelnou závislost, tak dnes musí mít navíc i `kdyby/doctrine-dbal-batchimport`. To je pro uživatele velmi nepříjmené, protože na to musí myslet. Zatím nevím co s tím...\n\nDočasná vhodná kombinace (pro zajištění kompatibility s Nette 2.4) pro Kdyby balíčky, které používám já je tato:\n\n```js\n{\n  \"repositories\": [\n    {\n      \"type\": \"vcs\",\n      \"url\": \"https://github.com/mrtnzlml/Events\"\n    }\n  ],\n  \"require\": {\n    \"kdyby/console\": \"^2.5\",\n    \"kdyby/doctrine\": \"dev-master\",\n    \"kdyby/doctrine-cache\": \"dev-master\",\n    \"kdyby/doctrine-dbal-batchimport\": \"dev-master\",\n    \"kdyby/events\": \"dev-patch-1 as 3.0.x-dev\",\n    \"kdyby/fake-session\": \"^2.0\",\n    \"kdyby/monolog\": \"^1.2\",\n  }\n}\n```\n\nZ toho důvodu bych možná raději doporučoval chvíli počkat, protože je s tím velké (a hlavně zbytečné) trápení. A když už jsem se opřel i o Testbench. I zde se z důvodu kompatibility ukáže BC break. Mock linky se budou generovat [v jiném formátu](https://github.com/mrtnzlml/testbench/blob/master/tests/Mocks/ControlMock.phpt#L22-L25) (kompatibilním s Testerem).\n\nMáte při přechodu ještě nějaký problém?","frontmatter":"id: 7f009c6b-998c-4cef-8797-cf1853ac5ea7\ntimestamp: 1466343012000\ntitle: Fix compatibility with Nette 2.4\nslug: fix-compatibility-with-nette-2-4"},{"attributes":{"id":"847a3113-3989-46a4-9486-41bf0d49fe16","timestamp":1460891805000,"title":"PSR-4 autoloader aplikace","slug":"psr-4-autoloader-aplikace"},"body":"Nikdy jsem moc nelpěl na PSR-FIG pravidlech. Částečně možná proto, že jsem je nikdy moc nechápal, částečně možná proto, že nemám rád, když mi někdo něco nutí. Nekterá pravidla jsou ale docela fajn (i když se vždy něco najde). Jedním z jich je [PSR-4: Improved Autoloading](http://www.php-fig.org/psr/psr-4/). Jenže proč řešit nějaký autoloading, když v Nette funguje skvěle, ani o tom člověk neví? Fakticky jsou v každém sandboxu použity minimálně 2 autoloadery a mohl bych se tedy ohánět rychlostí, protože:\n\n> *If there must be multiple autoload functions, spl_autoload_register() allows for this. It effectively creates a queue of autoload functions, and runs through each of them in the order they are defined. By contrast, __autoload() may only be defined once. ([zdroj](http://php.net/manual/en/function.spl-autoload-register.php)*)\n\nAle to je otázka a praticky jsem nikdy žádný významný posun ve výkonu nezaregistroval (i když teoreticky nemusím iterovat přes celý vendor, abych našel něco v app). Mnohem významnější je pro mě sada pravidel, kterými se programátor musí při použití PSR-4 řídit. Ty budu postupně popisovat v následujícím textu.\n\n# PSR-4 na čistém projektu\n\nNasadit PSR-4 na [čistém projektu](https://github.com/nette/web-project) je jednoduché. Stačí pouze pár jednoduchých kroků. V první řadě odstraníme RobotLoader - nebude vůbec potřeba. To znamená odstranit jej z `composer.json` a smazat z `bootstrap.php`. Teď ale aplikace nefunguje. Vraťme se tedy do `composer.json` a přidáme jednu sekci s definicí PSR-4 autoloaderu:\n\n```js\n\"autoload\": {\n  \"psr-4\": {\n    \"App\\\\\": [\n      \"app/router/\"\n    ],\n    \"App\\\\Presenters\\\\\": [\n      \"app/presenters/\"\n    ]\n  }\n}\n```\n\nMůže se stát, že to nebude hned fungovat, pak stačí spustit příkaz `composer dump-autoload` a Composer si přegeneruje autoloading pravidla. Teď nám však web-project vrátí toto:\n\n> *RobotLoader is required to find presenters, install package `nette/robot-loader` or disable option application.scanDirs: false* .{color:red}\n\nDobře, tak zakážeme prohledávání vendoru za účelem nalezení presenterů ve vendoru. Stejně to teď nepotřebujeme:\n\n```neon\napplication:\n\tscanDirs: no\n```\n\nA aplikace rázem opět funguje. Udělal jsem to schválně tak, aby fungoval web-project bez zásahu do struktury. Je zde však několik drobných problémů, které nejsou možná na první pohled vidět. Zejména je ošklivá definice v `composer.json`. Proč by to nemohlo být prostě jen takto:\n\n```js\n\"autoload\": {\n  \"psr-4\": {\n    \"App\\\\\": [\n      \"app/\"\n    ]\n  }\n}\n```\n\nMohlo, jen musíme zasáhnout do adresářové struktury (nezapomeňte na `composer dump-autoload`). Tímto mappingem totiž určujeme kde má být třída umístěna v adresářové struktuře vzhledem k namespace. Takže když bude namespace začínat na `App`, tak se budou třídy hledat ve složce `app`. Jenže je třeba dodržet minimálně jedno důležité pavidlo. Namespace (a tedy i výsledná adresářová struktura) musí být case-sensitive - což ve web-projectu není. Toto je pro mě asi největší přínos PSR-4. Jasně je totiž dáno jak se má adresářová struktura tvořit. Prostě podle toho jaké chci používat namespace. Vždy jsem totiž zápasil s tím, jestli psát složky s velkým písmenem a jak moc vše zanořovat atd. Teď je to vše jasné.\n\nPřejmenujme tedy `\\App\\RouterFactory` na `\\App\\Router\\RouterFactory`. Nezapomeňte přeregistrovat službu v `config.neon` a změnit název složky v `router` na `Router`. Podobnou úpravu provedeme i s presentery kdy stačí jen zvětšit první písmeno složky `Presenters`. A aplikace stále funguje. :)\n\nPodobné jednoduché úpravy budou fungovat na jakémkoliv projektu, je však zřejmé, že je občas vhodné zasáhnout do adresářové struktury, proto bych doporučoval udělat tyto úpravy co nejdříve (pokud chcete PSR-4).\n\n# Composer autoload\n\nJak to tedy celé vlastně funguje? Vše to vězí v této první řádce `boostrap.php`:\n\n```php\n$classLoader = require __DIR__ . '/../vendor/autoload.php';\n```\n\nV souboru `autoload.php` se skrývá něco takového:\n\n```php\n<?php\n\n// autoload.php @generated by Composer\n\nrequire_once __DIR__ . '/composer' . '/autoload_real.php';\n\nreturn ComposerAutoloaderInit091ed5d24b4127ffc48411e34be2086f::getLoader();\n```\n\nZde se připraví pomocí třídy `\\Composer\\Autoload\\ClassLoader` autoloader ze všech možných zdrojů (pomocí `spl_autoload_register`), které [Composer podporuje](https://getcomposer.org/doc/04-schema.md#autoload).\n\nA to je vlastně celé. Ještě existují dvě vylepšení, které Composer podporuje u příkazu `dump-autoload`:\n \n- `--optimize` (`-o`): Convert PSR-0/4 autoloading to classmap to get a faster autoloader. This is recommended especially for production, but can take a bit of time to run so it is currently not done by default.\n- `--classmap-authoritative` (`-a`): Autoload classes from the classmap only. Implicitly enables `--optimize`.\n\nPokud tedy chcete načítání tříd ještě zrychlit, tak vytvořte optimalizovaný autoloader, který předpřipraví pole s názvem třídy a rovnou kde lze danou třídu najít. To je velmi rychlé, protože se PHP dívá jen do tohoto pole viz implementace:\n\n```php\n// class map lookup\nif (isset($this->classMap[$class])) {\n    return $this->classMap[$class];\n}\n```\n\nNavíc v authoritative módu tímto Composer končí a dál nehledá. Jinak se pokusí ještě najít třídu pomocí dalších způsobů autoloadingu. Pro názornost uvedu jak vypadá Composer autoloader v jednotlivých módech. První je jen tak bez ničeho:\n\n```\nComposer\\Autoload\\ClassLoader #5cfb ▼\n  prefixLengthsPsr4 => array (1) ▼\n    A => array (1) ▼\n      \"App\\\" => 4\n  prefixDirsPsr4 private => array (1) ▼\n    \"App\\\" => array (1) ▼\n      0 => \"/var/www/html/web-project/app\" (29)\n  classMap private => array (345) ►\n  classMapAuthoritative private => FALSE\n```\n\nJe vidět, že je zaregistrovaný pouze jeden jmenný prostor, v classmap autoloaderu je navíc 345 tříd a nepoužíváme authoritative mód. Optimalizovaný autoloader (`composer dump-autoload --optimize`) se liší jen málo:\n\n```\nComposer\\Autoload\\ClassLoader #c492 ▼\n  prefixLengthsPsr4 => array (1) ▼\n    A => array (1) ▼\n      \"App\\\" => 4\n  prefixDirsPsr4 private => array (1) ▼\n    \"App\\\" => array (1) ▼\n      0 => \"/var/www/html/web-project/app\" (29)\n  classMap private => array (349) ►\n  classMapAuthoritative private => FALSE\n```\n\nKonkrétně je v classmap autoloaderu najednou 349 třídy (navíc 3x presenter a RouterFactory).  Authoritative mód (`composer dump-autoload -a`) už je o něco odlišnější:\n\n```\nComposer\\Autoload\\ClassLoader #7553 ▼\n  prefixLengthsPsr4 private => array ()\n  prefixDirsPsr4 private => array ()\n  classMap private => array (349) ►\n  classMapAuthoritative private => TRUE\n```\n\nStále je v classmap 349 tříd, ale interně už neexistuje nic jako PSR-4 autoloader a vše se tedy hledá pouze v classmap autoloaderu. S touto ukázkou to musí být všem už naprosto jasné. :)\n\n# PSR-4 ve starší aplikaci\n\nVe starších (již fungujících) aplikacích je vše samozřejmě stejné. Je však třeba upozornit na další PSR-4 pravidlo, kvůli kterému jsem se dlouho zdráhal přejít. Každá třída totiž musí být ve vlastním souboru. Toto pravidlo je určitě dobré, ale myslím si, že dává smysl připojovat definice generovaných továren do toho samého souboru, jako třeba komponentu kterou vytvářejí. Při přechodu je tedy třeba tyto soubory rozdělit.\n\nDalší nepříjemností může být struktura, která na PSR-4 prostě nesedí a bylo by velmi složité vše předělávat. Je však škoda nepoužít Composer autoloader jen kvůli takovému drobnému zádrhelu. V tomto případě je možné použít třeba dříve zmiňovaný classmap:\n\n```js\n\"autoload\": {\n  \"psr-4\": {\n    \"App\\\\\": [\n      \"app/\"\n    ]\n  },\n  \"classmap\": [\n    \"libs/\",\n    \"include/\"\n  ]\n}\n```\n\nToto jen potvrzuje to, co jsem psal již dříve. Je dobré rozmyslet se včas, protože přechod může být později téměř nemožný. Každopádně striknost z hlediska adresářové struktury je pro mě tak důležitá, že jsem přestal váhat a přešel jsem. Pořád si nejsem jist s tím, jestli oddělené generované továrničky jsou přesně to, co se mi líbí, ale to už je jen drobný problém.","frontmatter":"id: 847a3113-3989-46a4-9486-41bf0d49fe16\ntimestamp: 1460891805000\ntitle: PSR-4 autoloader aplikace\nslug: psr-4-autoloader-aplikace"},{"attributes":{"id":"098b3cf2-dc80-4c7f-b02b-c5918cc1c94c","timestamp":1459632882000,"title":"Magie zvaná mapping presenterů","slug":"magie-zvana-mapping-presenteru"},"body":"Ona to vlastně ani není taková magie jako to není nikde pořádně popsané. Než se pustím to obludných složitostí, bylo by vhodné zmínit se co to vlastně mapping presenterů je. Viděli jste někde toto v konfiguraci?\n\n```neon\napplication:\n\tmapping:\n\t\t*: App\\*Module\\Presenters\\*Presenter\n```\n\nUrčitě ano, je to totiž vykopírované ze sandboxu. Tato konfigurace říká, kde má Nette hledat presentery. Resp. pod jakým **namespace**. To je důležité. Na adresářové struktuře totiž v tomto případě vůbec nezáleží. Kdyby v konfiguračním souboru nebyl mapping vůbec uvedený, presenter by musel být bez namespace, tedy například `\\HomepagePresenter`. Pokud by pak zase někdo měl raději MVC, mohl by si jednoduše změnit mapping:\n\n```neon\napplication:\n\tmapping:\n\t\t*: App\\*Module\\Controllers\\*Controller\n```\n\nA používat tak třídu `\\App\\Controllers\\HomepageController`. Opět na umístění v adresářové struktuře nezávisle. Pojďme se ale ponořit hlouběji a rozeberme si co vlastně jednotlivé části mappingu znamenají.\n\n# Do hlubin regulárů\n\nNejdůležitější metodou je v tomto případě `\\Nette\\Application\\PresenterFactory::setMapping`. V této metodě se ukrývá tento regulární výraz, který kontroluje validitu mappingu (preg_match):\n\n```\n#^\\\\\\\\?([\\w\\\\\\\\]*\\\\\\\\)?(\\w*\\*\\w*?\\\\\\\\)?([\\w\\\\\\\\]*\\*\\w*)\\z#\n```\n\nV této obludnosti se skrývají 3 části. Ale zjednodušeně řečeno rozdělí tento regulární výraz mapping na prefix, část s modulem a část s presenterem. Tedy například takto:\n\n```\n                                           App\\\nApp\\*Module\\Presenters\\*Presenter    =>    *Module\\\n                                           Presenters\\*Presenter\n```\n\nZ toho jak je regulár napsaný by mělo být zřejmé, že lze první i druhou část vynechat. Všechny následující mappingy jsou tedy validní:\n\n```\n*Module\\Presenters\\*Presenter\nApp\\Presenters\\*Presenter\nPresenters\\*Presenter\n*Presenter\nPresenter*\n*\n```\n\nTak moment. Co vlastně znamenají ty hvězdičky? Zjednoušeně hvězdička značí proměnný název presenteru (Homepage v HomepagePresenter) a pokud jsou v mappingu dvě hvězdičky, tak první značí proměnnný název modulu (nebo všech zanořených modulů) aplikace. Nejpochopitelnější bude vyzkoušet si tu nejjedodušší formu mappingu:\n\n```neon\napplication:\n\tmapping:\n\t\t*: *\n```\n\nNa hvězdičku před dvojtečkou zatím nehleďme. Nette teď bude hledat prostě jen třídu `\\Homepage` (resp. podle definice routeru). Pokud budeme mít modulární aplikaci, tak se bude hledat `<Admin>Module\\Homepage` (opět záleží na routeru). Pokud trošku pozměníme mapping, musí to už být úplně jasné:\n\n```neon\napplication:\n\tmapping:\n\t\t*: *\\*\n```\n\nNette teď nebude nic řešit. Řekněme že máme router nastavený tak, aby destination bylo `Front:Homepage:default`. V při tomto mappingu se bude hledat přesenter s názvem `\\Front\\Homepage`. Ještě uvedu jeden příklad, aby to bylo úplně zřejmé. Teď nebudu mít destination v routě jen `Homepage:default` a mapping nastavím takto:\n\n```neon\napplication:\n\tmapping:\n\t\t*: App\\Presenters\\*Presenter\n```\n\nPřesně tak, bude se to chovat úplně stejně jako první příklad. Když totiž aplikace nepracuje s moduly, tak se druhá část toho velkého reguláru zahazuje. Než se dostanu k limitním případům, kdy je mapping omezující, rozeberme si ještě konfigurační část před dvojtečkou (klíč pole). Do této chvíli všude byla jen hvězdička. To znamená, že se tento mapping aplikuje na všechny příchozí požadavky. Se vzrůstající složitostí projektu však může přijít požadavek, že chceme mapovat jinak administraci a jinak zbytek aplikace. Routování by mohlo být třeba takové:\n\n```php\npublic static function createRouter()\n{\n\t$router = new RouteList;\n\t$router[] = new Route('test', 'Admin:Homepage:default');\n\t$router[] = new Route('<presenter>/<action>[/<id>]', 'Homepage:default');\n\treturn $router;\n}\n```\n\nA mapping:\n\n```neon\napplication:\n\tmapping:\n\t\t*: App\\*Module\\Presenters\\*Presenter\n        Admin: App\\Controllers\\*Controller\n```\n\nTakže vše bude mapováno pomocí první masky, ale pro `Admin` modul bude používat MVC jako v druhé ukázce. Tohoto se dá velmi dobře využít pokud stavíte aplikaci pomocí [rozšíření pro DIC](rozsireni-pro-dic). V tomto případě je totiž docela dobrý nápad mít presentery ve vlastní namespace a tedy vytvořit si pro ně nový mapping, který bude mapovat jen tuto část aplikace. Používám to hodně.\n\n# Limitující případy\n\nCo vím, tak existují dva limitující případy s tím, že ten druhý je vyřešen v budoucí verzi Nette Application (zatím jen dev-master). Na první případ narážím velmi často. Bohužel totiž není možné (pokud vím) definovat více mappingů pro jeden modul. Nejde tak vytvořit mapping třeba pro modul API a zároveň mapping, který by využíval stejný modul, ale byl umístěn v úplně jiném namespace (bundle). To je při tvorbě bundles hodně limitující. Tento problém je vyřešen ve skvělé knihovně [librette/presenter-factory](https://github.com/librette/presenter-factory). Celkově se v Librette skrývá spoustu pokladů, jen <del>Kdyby</del> je autor nějak dokumentoval... ;-)\n\nDruhý případ je dobře popsán v [tomto issue](https://github.com/nette/application/issues/101). Totiž jak jsem se letmo zmínil dříve, tak pokud existuje více zanořených modulů, tak se maska pro moduly opakuje. Ale ne tak, jak by bylo občas potřeba. Mějme například tento mapping z issue #101:\n\n```neon\napplication:\n\tmapping:\n\t\t*: App\\Module\\*Module\\Presenter\\*Presenter\n```\n\nPokud budeme mít v routeru nadefinováno více zanoření modulů (`A:B:Homepage:default`), tak se bude hledat tento presenter:\n\n```\nApp\\Module\\AModule\\BModule\\Presenter\\HomepagePresenter\n```\n\nTo docela dává smysl, že? Jenže ne vždy je to vhodné chování a lepší by bylo, aby se pro moduly opakovala větší část definice a hledaný presenter se ve skutečnosti jmenoval takto:\n\n```\nApp\\Module\\AModule\\Module\\BModule\\Presenter\\HomepagePresenter\n```\n\nToho však nelze se současným mappingem jednoduše dosáhnout. Řešením je právě vývojová verze balíčku Nette\\Application, kde lze mapping nadefinovat také pomocí pole:\n\n```neon\napplication:\n\tmapping:\n\t\t*: [App, Module\\*Module, Presenter\\*Presenter]\n```\n\nVyřešení takové mappingu je už jednoduché a aplikace se chová přesně podle očekávání. Původní chování samozřejmě zůstává stejné. Při tomto novém zápisu opět platí vše co jsem již psal, jen je třeba dodržet pořadí v poli:\n\n```neon\napplication:\n\tmapping:\n\t\t*: ['', *, *]    #nebo *\\*\n```\n\nTedy opět je hledaný presenter `Front\\Homepage` při routeru nastaveném na `Front:Homepage:default`. A poslední příklad uvedu přepsaný první příklad podle tohoto alternativního přístupu:\n\n```neon\napplication:\n\tmapping:\n\t\t*: [App, *Module, Presenters\\*Presenter]\n```\n\nVíc o tom asi nejde napsat, protože je to přesně takto jednoduché... :)","frontmatter":"id: 098b3cf2-dc80-4c7f-b02b-c5918cc1c94c\ntimestamp: 1459632882000\ntitle: Magie zvaná mapping presenterů\nslug: magie-zvana-mapping-presenteru"},{"attributes":{"id":"6b057983-39a9-4328-a526-2dfb03babbbb","timestamp":1457796154000,"title":"Rozšíření pro DIC","slug":"rozsireni-pro-dic"},"body":"Jednu z věcí, které jsem zde na blogu moc nepopsal jsou rozšíření pro DIC (Dependency Injection Container, potomek `Nette\\DI\\Container`). A protože se chci vrátit jednodušším článkům, zaměřím se na úplně základy. Jaká je motivace k psaní rozšíření DIC a co to vlastně je?\n\nSvé aplikace rozděluji poměrně důsledně na jakési balíčky (bundles - název ze Symfony). Cílem je rozškatulkovat celou aplikaci podle logických celků, tzn. každý bundle by se měl starat pouze o tu svojí věc a zároveň si s sebou nést vše potřebné. Jedná se o balíčky typu *Articles*, který se stará (jak sám název napovídá) pouze a jenom o články, nebo *Eshop*, *GoPay*, *Media*, *Users*, atd. Výhodou tohoto přístupu je to, že mohu kdykoliv z balíčku udělat Composer balíček a úplně ho oddělit od aplikace. Zároveň některé balíčky směřují k jednoduchému oddělení do [microservices](http://martinfowler.com/articles/microservices.html). Nevýhodou je pak to, že je to oproti běžným způsobům jak navrhovat aplikaci poměrně složité.\n\nNapsat takto aplikaci většinou zamená zasahovat do nějaký globálních prostor, popřípadě mít vytvořené nějaké body v aplikaci, na které je možné se navěsit. Jelikož však využívám(e) Nette, je nejlepší způsob využít právě rozšíření DIC.\n\n# Píšeme první rozšíření DIC\n\nCelé je to vlastně velmi jednoduché. Třeba do `src/Articles/DI` umístíme třídu `ArticlesExtension`, která dědí od `Nette\\DI\\CompilerExtension`. Struktura je libovolná, podstatné je, aby třída dědila právě od *CompilerExtension*. Druhá věc, kterou je třeba udělat, je zaregistrování našeho nového rozšíření do DI kontejneru. To uděláme velice jednoduše v konfiguračním souboru:\n\n```neon\nextensions:\n\t- Ant\\Articles\\DI\\ArticlesExtension\n```\n\nV tuto chvíli je již rozšíření funkční a Nette s ním počítá. Jen zatím nic neumí. To napravíme velmi rychle, nejdříve však trošku nezbytné teorie. Takto zaregistrované rozšíření se zpracovává pouze v okamžiku kompilace DIC. Na toto je důležité myslet - je to jedna z nejčastějších chyb začátečníků. Ono to dává smysl. Je to rozšíření DIC. Kontejner se tedy jednou nějak pomocí rozšíření upraví, vygeneruje, uloží a hotovo.\n\nDruhá důležitá informace se týká životního cyklu rozšíření. Při kompilaci (generování) DIC se každé zaregistrované rozšíření volá celkem třikrát a pokaždé se spustí jiná metoda. Je to podobné jako [životní cyklus presenteru](https://doc.nette.org/cs/2.3/presenters#toc-zivotni-cyklus-presenteru).\n\nPrvní volanou metodou je `loadConfiguration` a volá se v okamžiku, kdy Nette začne s rozšířením pracovat. V tu chvíli je již k dispozici konfigurace jednoho konkrétního rozšíření. Kde se ale tato konfigurace vezme? Tak to se musíme vráti kousek zpět a rozšíření zaregistrovat trošku jinak:\n\n```neon\nextensions:\n\tarticles: Ant\\Articles\\DI\\ArticlesExtension\n```\n\nDíky tomu, že je rozšíření pojmenované a ne anonymní jako to bylo doposud, můžeme rozšíření předat libovolnou vlastní konfiguraci:\n\n```neon\narticles:\n\toption_1: value_1\n\toption_2: value_2\n\t# ...\n```\n\nA přesně tyto hodnoty (`option_1`, `option_2`) můžeme získat jako pole pomocí metody `$this->getConfig()` v rozšíření. K čemu se tedy `loadConfiguration` hodí? Jedná se o místo, kde je vhodné načíst (a zvalidovat) konfiguraci. Já osobně nejraději načítám extra config, který si s sebou nese samo rozšíření, takže se mi rozšíření zjednoduší na:\n\n```php\npublic function loadConfiguration()\n{\n\t$this->addConfig(__DIR__ . '/services.neon');\n}\n```\n\nKde `services.neon` obsahuje třeba:\n\n```neon\nservices:\n\t- Ant\\Articles\\Components\\IArticlesGridFactory\n\t# ...\n```\n\nJe to jednudché a chápe to každý kdo chápe konfigurace. Jen pozor na to, že funkce `addConfig` jsem si napsal sám. Mrkněte se do [dokumentace](https://doc.nette.org/cs/2.3/di-extensions#toc-loadconfiguration) jak se to dá udělat. Pokud se někomu nelíbí mít u každého rozšíření vlastní config, je možné vše napsat v rozšíření ručně. Zde také odkážu na dokumentaci.\n\nKdyž už je konfigurace všeho připravena, přichází ke slovu druhá funkce `beforeCompile`. Ta se volá v okamžiku, kdy už je skoro vše připraveno, ale ještě se kontejner negeneruje. Já osobně tento čas využívám například k registraci presenter mappingu pro jednotlivé bundly:\n\n```php\npublic function beforeCompile()\n{\n\t$builder = $this->getContainerBuilder();\n    $builder->getDefinition($builder->getByType(IPresenterFactory::class))->addSetup(\n        'setMapping',\n        [['Articles' => 'Ant\\Articles\\*Module\\Presenters\\*Presenter']]\n    );\n}\n```\n\nTím jsem chtěl ukázat, že se jedná o místo, kde je vhodné upravovat již připravené služby a různě je ještě donastavit s tím, že až se zavolají metody `beforeCompile` nad každým rozšířením, přijde ke slovu poslední metoda a tou je `afterCompile`. Tato metoda dostává v parametrem `Nette\\PhpGenerator\\ClassType` což je jinak řečeno vygenerovaný DI kontejner v paměti, tedy ještě neuložený do souboru (cache). Existuje tedy ještě poslední možnost jak s DIC ještě něco udělat. Stačí využít síly `Nette\\PhpGenerator` a můžete tvořit kouzla. Většinou se však poupravuje metoda DIC `initialize` třeba jako to dělá `Nette\\DI\\Extensions\\ConstantsExtension` nebo [PhpExtension](https://api.nette.org/2.3.9/source-DI.Extensions.PhpExtension.php.html#19-48):\n\n```php\npublic function afterCompile(Nette\\PhpGenerator\\ClassType $class)\n{\n\tforeach ($this->getConfig() as $name => $value) {\n\t\t$class->getMethod('initialize')->addBody('define(?, ?);', array($name, $value));\n\t}\n}\n```\n\n*Initialize* je totiž metoda, která se volá jako jedna z [prvních vůbec](https://api.nette.org/2.3.9/source-Bootstrap.Configurator.php.html#224).\n\nTolik jinak (pro normální lidi) napsáno to, co je v [dokumentaci](https://doc.nette.org/cs/2.3/di-extensions). Mělo by teď být jasné, k čemu je psaní rozšíření pro DIC vůbec dobré a proč by o tom měl člověk vůbec uvažovat. Je zřejmé, že je to zase další složitost navíc, ale když programátor ovládne psaní takových rozšíření, celá aplikace se najednou začne pěkně škatulkovat a rozpadat na jednodušší části. Ostatně takto se píšou všechny normální [addony](https://componette.com/) pro Nette.\n\n# Ještě nějaké jednoduché testy\n\nŠpatný test je sice pořád špatný, zároveň je však lepší, než test žádný. Všímám si však toho, že se o testech hodně a dlouho blábolí, ale když přijde ten správný čas, tak o nich nepadne ani slovo. Proto jsem je začal ve svých ukázkách hodně tlačit a blog nezůstane pozadu. Jak by tedy takový jednoduchý test mohl vypadat? Asi nebude překvapením, když na to použiju svůj [mrtnzlml/testbench](https://github.com/mrtnzlml/testbench), který si může kdokoliv stáhnout a který mi ušetří hodně trápení. K testu mi bude stačit pouze traita `Testbench\\TCompiledContainer` a celý test case by mohl vypadat třeba takto:\n\n```php\n<?php\n\nnamespace Ant\\Tests\\Articles;\n\nuse Ant\\Articles\\Components\\IArticlesGridFactory;\nuse Tester\\Assert;\n\nrequire __DIR__ . '/../bootstrap.php';\n\n/**\n * @testCase\n */\nclass Extension extends \\Tester\\TestCase\n{\n\n\tuse \\Testbench\\TCompiledContainer;\n\n\tpublic function testFunctionality()\n\t{\n\t\t$articlesGridFactory = $this->getService(IArticlesGridFactory::class);\n\t\tAssert::type('Ant\\Articles\\Components\\IArticlesGridFactory', $articlesGridFactory);\n\t\tAssert::type('Ant\\Articles\\Components\\ArticlesGrid', $articlesGridFactory->create(NULL));\n\t}\n\n}\n\n(new Extension)->run();\n```\n\nCo to vlastně testuje? Podívejte se na obsah `service.neon`, kde jsem dříve v rozšíření přidával najkou generovanou továrničku `IArticlesGridFactory`. V první řadě si tak otestuji, že je zaregistrována správně a že ji kontejner zná. Když mám továrničku, tak mohu ještě otestovat, jestli je vůbec možné vytvořit komponentu pro kterou je tato továrna určena. To už je skoro nadbytečný test, protože to bych si měl asi otestovat až v testu pro komponentu, ale tak proč ne.\n\nTo nebylo tak složité, že? A navíc je to celé pokryté testy. Nádhera... :)","frontmatter":"id: 6b057983-39a9-4328-a526-2dfb03babbbb\ntimestamp: 1457796154000\ntitle: Rozšíření pro DIC\nslug: rozsireni-pro-dic"},{"attributes":{"id":"9b774295-d6af-413e-9431-6a05bdedfd7e","timestamp":1454786953000,"title":"Jednoduché testování pro úplně každého","slug":"jednoduche-testovani-pro-uplne-kazdeho"},"body":"Konec slibů, článek je tu. Tentokrát se rozepíšu o nástroji [Testbench](https://github.com/mrtnzlml/testbench). Testbench by měl pomoci s rychlým testováním Nette aplikace. Je zaměřen spíše integračně a vhodně doplňuje [Nette\\Tester](https://tester.nette.org/), který je zaměřen spíše jednotkově. Myšlenka, která stála za vytvořením tohoto nástroje je velmi prostá - testování je složité. Je složité hlavně pro lidi, kteří dokonale nerozumí problému. Proto je tento nástroj zaměřen na rychlý start pro úplně každého (kdo si prošel alespoň quickstart a chce testovat). To se projevuje v tom, jak je Testbench postaven (viz další povídání). Testbench se sestává z různých nápadů, které jsem všude možně okoukal za posledních X měsíců a něco mě na nich zaujalo. Pojďme se tedy společně podívat jak se Testbench používá a proč ho sám rád používám pro rychlé testy.\n\n# Základní nastavení testovacího prostředí\n\nU každého testování je vhodné testovat v co nejvíce čistém prostředí. Proto je dobrý nápad vytvořit si vlastní bootstrap (`tests/bootstrap.php`), jehož obsah může být velmi jednoduchý:\n\n```php\n<?php\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\nTestbench\\Bootstrap::setup(__DIR__ . '/_temp');\n```\n\nJediným parametrem se nastaví odkládací složka pro cache testů a testy jsou připraveny. Prakticky jsou však potřeba další dodatečné konfigurace. Zde pomůže druhý parametr `setup` metody:\n\n```php\nTestbench\\Bootstrap::setup(__DIR__ . '/_temp', function (Nette\\Configurator $configurator) {\n\t$configurator->createRobotLoader()->addDirectory([\n        __DIR__ . '/../app',\n    ])->register();\n\n    $configurator->addParameters([\n        'appDir' => __DIR__ . '/../app',\n        'testsDir' => __DIR__,\n    ]);\n\n    $configurator->addConfig(__DIR__ . '/../app/config/config.neon');\n    $configurator->addConfig(__DIR__ . '/tests.neon');\n});\n```\n\nProč takto zvláštně přes callback? Zvykem je totiž, že bootstrap vrací rovnou instanci DIC. To se však hodí pouze pro aplikaci, nikoliv pro testy. Testbench si oproti tomu tuto konfiguraci uschová a když bude někdy v testech potřeba DIC, tak si jej pomocí této konfiguraci vytvoří. Tento kontejner navíc vytváří pouze jednou, aby se ušetřil čas při dalším testování.\n\nDíky tomu, že se Testbench stará o DI kontejner sám, může si dovolit dělat zajímavé věci. Jednou z nich je například skutečnost, že se sám registruje jako rozšíření do DIC, takže je možné v konfiguračních NEON souborech používat sekci `testbench`. Ta se v současné době hodí pouze pro práci s databází:\n\n```neon\ntestbench:\n\tdbname: <nazev_databaze>\n\tsqls:\n\t\t- %testsDir%/_helpers/sqls/1.sql\n        - %testsDir%/_helpers/sqls/2.sql\n```\n\nPřesně tak. Když přijde na přetřes práce s databází (zatím jen Doctrine), Testbench si vytvoří úplně čistou databázi (kterou na konci testu smaže) a postupně do ní nahraje zde vyjmenované SQL soubory (např. pro základní strukturu + nějaká demo data). Název databáze je zde potřeba z toho důvodu, že se při mazání potřebuje na nějakou databázi připojit a tu dočasnou (testovací databázi) smazat. Zatím nevím, jak to udělat lépe.\n\nToto je asi tak vše, co je potřeba udělat před prvním spuštěním. K dispozici je potom spustitelný skript ve vendoru `vendor/bin/run-tests`, který funguje na Win i na Linuxu a pokud je vše připraveno podle předchozího návodu, tak po spuštění promaže cache testů, nastaví správně Nette\\Tester a spustí jej. Zde asi časem budu dělat ještě hodně úprav, ale chci je dělat postupně - jak co bude potřeba.\n\n# Testujeme presentery\n\nU testování presenterů to vlastně celé začalo. Napsat si takový základní test na presenter je velmi jednoduché. Stačí použít tu správnou traitu a je půl práce hotovo:\n\n```php\n<?php //HomepagePresenterTest.phpt\n\nrequire __DIR__ . '/../bootstrap.php';\n\n/**\n * @testCase\n */\nclass HomepagePresenterTest extends \\Tester\\TestCase\n{\n\n\tuse \\Testbench\\TPresenter;\n\n\tpublic function testRenderDefault()\n\t{\n\t\t$this->checkAction('Homepage:default');\n\t}\n\n\tpublic function testRenderDefaultModule()\n    {\n        $this->checkAction('Module:Homepage:default');\n    }\n\n}\n\n(new HomepagePresenterTest())->run();\n```\n\nZ této ukázky plyne jedna důležitá věc. Testbench podporuje pouze PHP 5.4 a více (5.5, 5.6, 7.0 a HHVM). Co se zde vlastně testuje? Testbench si přebere první parametr, spustí danou akci na daném presenteru a provede úplně nejzákladnější testy které lze provést. To je konkrétně kontrola správné odpovědi a dále se pokusí najít základní HTML prvky na stránce. Je to velmi jednoduchý test, ale o tom to celé je. Už samotné spuštění akce presenteru může odhalit nějaké hloupé chyby v aplikaci. Že je to málo? Metoda `checkAction` vrací [IResponse](https://api.nette.org/2.3.8/Nette.Application.IResponse.html), takže je možné dopsat si vlastní testy podle potřeby. V tomto duchu se to celé nese - otestovat jen to základní a nudné a předat otěže programátorovi, ať si své speciální případy otestuje sám.\n\nTakových základních a nudných věcí ja samozřejmě více (viz [readme](https://github.com/mrtnzlml/testbench/blob/master/readme.md)). Může se hodit například testování přesměrování `checkRedirect`, signálů `checkSignal`, JSON odpovědí `checkJson` nebo testování RSS a sitemap (`checkRss` a `checkSitemap`). Zajímavé může být také testování formulářů:\n\n```php\npublic function testSearchForm()\n{\n    $response = $this->checkForm('<action-name>', '<form-name>', [\n        'input' => 'value',\n    ]);\n\n    //Tester\\Assert::... with IResponse $response\n}\n```\n\nOpět se Testbench postará o potřebné nudné náležitosti, otestuje to základní a vrátí zpět odpověď se kterou je možné cokoliv dalšího je potřeba. Tesbench \"by default\" testuje, jestli došlo po odeslání formuláře k přesměrování. To je asi nejčastnější chování u formulářů. Neprovedení přesměrování je tedy považováno za chybu. Toto lze ovlivnit čtvrtým parametrem. Ten může být `FALSE` - kontrola na přesměrování se neprovádí, nebo může být přímo nějaká URL cesta. Pak se kontroluje, jestli formulář přesměroval na správnou URL.\n\nK dispozici je ještě AJAX varianta `checkAjaxForm`, která testuje formulář v AJAX módu aplikace a jako výsledek očekává [JsonResponse](https://api.nette.org/2.3.8/Nette.Application.Responses.JsonResponse.html). Čtvrtým parametrem lze pak předat cestu jako v předchozím případě. V této situaci se nejdříve provede test formuláře s normálním přesměrováním a následně ještě ten samý formulář v AJAX módu.\n\nV neposlední řadě je možné se v testech přihlašova a odhlašovat podle libosti pomocí metod `logIn` a `logOut`.\n\n# Testování komponent\n\nTato traita je novější, takže toho neumí tolik (nikdo asi nic dalšího zatím nepotřeboval). V praxi se ale ukázalo jako šikovné ověřit si, že naše skvělá, malá a chytrá komponenta vykresluje to co má. k tomu slouží `checkRenderOutput`:\n\n```php\nuse \\Testbench\\TComponent;\npublic function testComponentRender()\n{\n    $control = new \\Component;\n    $this->checkRenderOutput($control, '<strong>OK%A%'); //match string\n    $this->checkRenderOutput($control, __DIR__ . '/Component.expected'); //match file content\n}\n```\n\nInterně zde Testbench využívá [match](https://tester.nette.org/#toc-assert-match) resp. `matchFile` z Nette\\Testeru. Je to šikovná pomůcka jak si rychle ověřit, že třeba komponenta co se stará o `<title>` se o něj stará skutečně správně a vrací takové HTML, jaké vracet má. Navíc se vnitřně komponenta připojuje k `PresenterMock`, který má zkrácený životní cyklus oproti běžným presenterům - takže by to celé mělo být hned rychlejší. Pokud by připravený mock z nějakého důvodu nevyhovoval, je možné jej vyměnit:\n\n```php\nservices:\n\ttestbench.presenterMock: CustomPresenterMock\n```\n\nTakových mocků je připravená celá řada, mrkněte se do [kódu](https://github.com/mrtnzlml/testbench/tree/master/src/mocks). Může se hodit...\n\n# Práce s databází\n\nKdyž začnou mít testy velké ambice a potřebují pracovat s databází, je zde jednoduché řešení ve formě `Testbench\\TDoctrine` traity. Jak název napovídá, tak Testbench momentálně podporuje pouze Doctrine, protože s ničím jiným momentálně nepracuju. Ačkoliv je příprava práce s databází asi nejsložitější, tak samotná traita poskytuje pouze jednu metodu na získání EntityManageru:\n\n```php\nuse \\Testbench\\TDoctrine;\npublic function testDatabase()\n{\n    $em = $this->getEntityManager();\n    //Tester\\Assert::...\n}\n```\n\nTestbench tedy připravuje čisté izolované databáze, konfiguruje jednotlivé testy a dává k dispozici připravený ObjectManager resp. EntityManager z Kdyby. Teď už se může programátor jakkoliv nad testovací databází vyřádit. Klidně bych přidal i další funkce, ale jak jsem již psal. Nechce se mi přidávat hovadiny. A proč pouze Doctrine? Protože jsem další databáze ještě nenapsal. Ani vlastně nevím jak to udělat správně vzhledem k tomu, že se používají traity. Asi by bylo nejpohodlnější napsat další traitu, třeba `TNetteDatabase` nebo `TDibi`. Stejně tak existuje [tato issue](https://github.com/mrtnzlml/testbench/issues/7) která narážela na skutečnost, že se může traita při MySQL chovat jinak než PostgreSQL. Ani to vlastně nevím jak udělat správně. Takže když nekdo budete mít volnou chvilku, tak ocením jakoukoliv pomoc... :)\n\n# Drawbacks\n\nNemám rád traity. Jsou sice cool, ale nemám je rád. Hlavně asi kvůli tomuto [bugu v PHP](https://bugs.php.net/bug.php?id=63911). Ale myslím si, že zrovna Testbench je vhodné místo, kde lze traity použít lépe, než cokoliv jiného. Jen je třeba myslet, že může v určitých situacích nastat problém. Zároveň také zatím není stabilní tag této druhé verze, takže zatím používejte `dev-master` (případně existuje RC). Stabilní mám v plánu vydat někdy po tomto článku až sesbírám ohlasy a zapracuju je. Zároveň bych rád také vyřešil již zmiňovanou issue.\n\n# Advantages\n\nTestbench sám o sobě obsahuje poměrně bohaté testy. Byla by ostuda, kdyby to tak nebylo. Jak jsem se zde snažil popsat, tak napsat nějaké rychlé testy, které odhalí největší chyby je velmi jednoduché. Sám Testbench rád používám. Zejména teď je tato knihovna mojí velkou oporou, protože pracuji s legacy kódem, který je velmi složité otestovat. Jakýkoliv test tedy může zachránit můj zadek a proto se mi i ty nejzákladnější testy na presentery (a hlavně na `UI\\Control` komponenty) hodně hodí. Využití ale bude mít i u jednoduchých webů, kde není skoro co testovat, protože aplikace skoro nic nedělá, ale je fajn vědět, jestli ještě všechny stránky fungují. U složitějších webů by měl Testbench poskytnout dostatečnou oporu při konfiguraci prostředí s tím, že v ničem nebrání a je možné dopsat si vlastní testy.\n\nJsem zvědav, kam co budu ještě přidávat za funkce. Asi to bude hodně kopírovat stav té legacy appky. Ale rád bych to dotáhl až někam k akceptačním testům, pokud to nebude zbytečně složité. To je ale daleká budoucnost.\n\n[Have fun!](https://github.com/mrtnzlml/testbench)","frontmatter":"id: 9b774295-d6af-413e-9431-6a05bdedfd7e\ntimestamp: 1454786953000\ntitle: Jednoduché testování pro úplně každého\nslug: jednoduche-testovani-pro-uplne-kazdeho"},{"attributes":{"id":"e05a6170-c3ca-427d-bf0c-e9b088aa541c","timestamp":1449682578000,"title":"ZČU - Nette je fajn, ale máme raději Javu","slug":"zcu-nette-je-fajn-ale-mame-radeji-javu"},"body":"![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/dd9f40eb-4a68-4b9d-9b09-e59a6beec7c8/screenshot-from-2015-12-09-17-54-49.png)\n\nDnes jsem měl opět tu čest přednášet studentům předmětu KIV/WEB na fakultě aplikovaných věd (ZČU) o tom, jak se dají dělat webové aplikace pomocí webového frameworku. Je to vždy skvělý zážitek.\n\nJako vždy sedělo v publiku (doslova) pár lidí, kteří už mají s frameworkem nějaké základní zkušenosti. Ostatní jsou většinou studenti, pro které je toto první seznámení s webovým světem a právě tato přednáška je jedna z posledních - takový vrchol pomyslného ledovce. Odnesl jsem si asi dva poznatky. Prvně - následující přednáška je **moc složitá**. Kdybych prezentaci dokázal zkrátit na polovinu, tak by to bylo OK. Není třeba zmiňovat se o DI, routování atd. (*to jen spíš taková moje osobní poznámka*).\n\nDruhý poznatek je však méně uspokojivý (i když o tom vím). Z nějakého důvodu se neustále FAV snaží tlačit Javu i na místa, kde si myslím, že nemá zase až takový smysl (tedy do webových aplikací). Každý rok se o tom na FAV rozhoří ta stejná, nikdy nekončící debata. Snažil jsem se argumentovat třeba tím, koho je potřeba nejčastěji (podle StartupJobs.cz). Jinak řečeno koho potřebujeme i my ve firmě. Fakt hodně. Abych to uvedl na pravou míru, nejsem proti Javě na FAV. Je to skvělý jazyk. Ale podle mě je prostě PHP na takový ten běžný web vhodnější. Když nad tím tam přemýšlím, tak vlastně nikdo nebyl úplně proti. Jen asi není o webové aplikace na FAV takový zájem, takže se to dále nevyučuje. O to horší je spolupracovat s absolventem, který zná pouze základy PHP. Není pak divu, že je Plzeň tak hladová po dobrých PHP programátorech.\n\nTo, že existují na této fakultě (a obecně na univerzitě) vzdělaní lidé, kteří se frameworkům brání a dokonce je zakazují je věc jiná. A tak mě napadá další otázka. **Která vysoká škola se webovým aplikacím věnuje nejvíce?** Nejde jen o to, kolik obsahuje webových předmětů, ale že se nebrání tomu, co se ve firmách skutečně používá. Já mám totiž pořád problém pochopit to, proč se někomu nelíbí framework (nehledě na značku). Protože buďme k sobě upřímní - nevěřím tomu, že dané problematice tento člověk rozumí více. Pro mě je to zatím pořád jen známka tvrdohlavosti. Asi tak stejně jako že někdo tlačí jen Nette a nic jiného. Jak jsem dnes říkal studentům - já Nette vlastně také tlačím, protože ho jako jediný framework ovládám. Jiné neumím. Ale podívejte se, kolik existuje integrací Symfony balíčků. Kdybych někde kydal na Symfony (nebo na jakýkoliv jiný framework) hnůj, tak si přijdu jako pitomec.\n\nMožná se na to dívám úplně blbě, ale člověk, který tlačí nepoužívání frameworků podle mého nepatří mezi nejbystřejší. Stejně tak, když se některé věci straní a nemá pořádné argumenty. Že se bez framewoku naučíte lépe daný programovací jazyk? **Bullshit.** Když jsem začínal s Nette já, tak jsem PHP skoro neuměl. Naučil jsem se ho jen díky frameworku. True story.\n\nA pokud mi ani teď nevěříte, dám vám reálný příklad. Víte kolik lidí mi dokázalo odpovědět na otázku jak se escapují proměnné v HTML? Jeden student. Nikdo už ale nedokázal vysvětlit parametry této funkce. Pokud je toto lepší přístup než použít pořádný šablonovací systém, tak to teda potěš koště...\n\nFuj, to jsem se ale rozohnil. Mrkněte se o čem jsem dnes povídal:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/5ovazIJDcXy8xH\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\n:)","frontmatter":"id: e05a6170-c3ca-427d-bf0c-e9b088aa541c\ntimestamp: 1449682578000\ntitle: ZČU - Nette je fajn, ale máme raději Javu\nslug: zcu-nette-je-fajn-ale-mame-radeji-javu"},{"attributes":{"id":"d0a905ac-329a-46a9-899b-bfe7518519c4","timestamp":1448405176000,"title":"Znovupoužitelné části formuláře","slug":"znovupouzitelne-casti-formulare"},"body":"Před nějakým časem jsem psal o tom, jak vytvořit [znovupoužitený formulář](znovupouzitelny-formular). Nejedná se o nic jiného, než o správné navržení a následné použití komponent, tedy potomků `UI\\Control`. Pokud bych měl být upřímný, nemyslím si, že se formuláře nějak často na webu opakují a osobně tento princip používám spíše pro oddělení části aplikace do samostatného balíčku. Tím spíš najde následující ukázka méně použití. Právě mám totiž za úkol navrhnout předělání jedné administrace. Úkolem není hledět na to, jak moc je tento přístup špatný, ale navrhnout řešení, které nahradí stávající 1:1. Tato administrace obsahuje často se opakující (a velmi rozsáhlý) formulář, který se skládá z několika karet. Navíc některé části formuláře spolu vůbec nesouvisí a na každé stránce je formulář trošku jiný (i když je podobnost zřejmá). Vzhledem k tomu, že se jedná o tak rozsáhlý kód, upustil jsem od znovupoužitelného formuláře a navrhnul jsem znovupoužitelné pouze jeho části. A na následujících řádcích nastíním jak.\n\n# Na začátku stála komponenta\n\nPořád platí, že je samotný formulář komponenta. Na tom se nic nemění. V mém případě se však hodilo udělat si ještě nějaké bázové třídy. Pokusím se ukázky ořezat co nejvíce od zbytečností tak, aby to pokud možno ještě dávalo smysl:\n\n```php\nclass NewsForm extends BaseControl {\n\n\t/** @var News|NULL */\n\tprivate $news;\n\n\tpublic function __construct($news) {\n\t\tparent::__construct();\n\t\t$this->news = $news;\n\t}\n\n\tpublic function render() {\n\t\t$this->template->render(__DIR__ . '/NewsForm.latte');\n\t}\n\n\tprotected function createComponentNewsForm() {\n\t    $form = $this->form;\n\t    // nastavení společných prvků formuláře\n\t    return $form\n\t}\n\n}\n```\n\nK tomu (třeba) nějaká ta generovaná továrnička a komponenta tak jak ji známe všichni je hotova. Bude však nutné rozklíčovat, co se děje třeba pod třídou `BaseControl`. Jedná se o jednoduchého předka, který krom dalších věcí obsahuje hlavně toto:\n\n```php\nabstract class BaseControl extends UI\\Control {\n\n\t/** @var BaseForm */\n\tprotected $form;\n\n\tpublic function __construct() {\n\t\tparent::__construct();\n\t\t$this->form = new BaseForm;\n\t}\n\n\tprotected function attached($obj) {\n\t\tparent::attached($obj);\n\t\tif ($obj instanceof UI\\Presenter) {\n\t\t\t$this->form->addComponent(new SubmitButtonsContainer, 'submitButtons');\n\t\t\t$this->form->addComponent(new AnotherContainer, 'another');\n\t\t}\n\t}\n\n}\n```\n\nZde se vytvoří nějaký formulář (s kterým pak pracuji v komponentě) a po připojení formuláře k presenteru se připojí i nějaké formulářové kontejnery. Než se však k těmto kontejnerům dostanu, tak by bylo dobré prozradit i co se děje v třídě `BaseForm`. Popravdě nic moc:\n\n```php\n/**\n * @method addTinyMCE($name, $label = NULL, $cols = NULL, $rows = NULL)\n */\nclass BaseForm extends UI\\Form {\n\n\t/** @var callable[] */\n\tpublic $onSaveAndStay;\n\n\t/** @var callable[] */\n\tpublic $onSaveAndExit;\n\n\t/** @var callable[] called BEFORE onClick event */\n\tpublic $onSuccess;\n\n\tpublic function __construct() {\n\t\tparent::__construct();\n\t\t$this->addProtection();\n\t}\n\n}\n```\n\nNastavím si zde nějaké věci, které jsou pro každý formulář v administraci obecně společné. Konkrétně tedy CSRF ochranu a pár polí pro události. Události jsem si zde musel nadefinovat sám, běžně se na formuláři volá `onSuccess` událost až po `onClick` ([link](https://api.nette.org/2.3.7/source-Forms.Form.php.html#380-420)), ale zrovna zde jsem to potřeboval obráceně. Hodí se to v okamžiku, kdy chci využívat `onSuccess`, ale v `onClick` už z formuláře třeba přesměrovávám pryč. Vzhledem k tomu, že oba eventy se volají jen při validním odeslání, tak to ničemu nevadí. V této třídě je také vhodné místo pro umístění nějakých dynamických metod do anotací, aby je IDE dobře napovídalo (viz `addTinyMCE`). Byl to dlouhý úvod, ale vše je připraveno a můžeme se vrhnout na kontejnery.\n\n# Formulářové kontejnery\n\nOsobně [formulářové kontejnery](https://pla.nette.org/cs/dedicnost-vs-kompozice) nemám moc rád. Jsou sice super, ale pohybují se na další úrovni formuláře. Pokud se však s tímto faktem smíříme (a nejlépe z něj uděláme výhodu), pak jsou docela super a zde se skvěle hodí. Můžu si pěkně oddělit například odesílací tlačítka a ty pak vesele používat ve všech formulářích:\n\n```php\nclass SubmitButtonsContainer extends BaseFormContainer {\n\n\tprivate $form;\n\n\tpublic function attached($obj) {\n\t\tparent::attached($obj);\n\t\tif ($obj instanceof BaseForm) {\n\t\t\t$this->form = $obj;\n\t\t\t$obj->onSuccess[] = function (BaseForm $form) {\n\t\t\t\t$path = $this->lookupPath(BaseForm::class);\n\t\t\t\tdump($form->getValues()->$path); // další zpracování hodnot\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic function render() {\n\t\t$this->template->_form = $this; // kvůli formulářovým makrům v šabloně\n\t\t$this->template->render(__DIR__ . '/SubmitButtonsContainer.latte');\n\t}\n\n\tprotected function configure() {\n\t\t$this->addSubmit('saveAndStay', 'Uložit a zůstat')->onClick[] = function (SubmitButton $button) {\n            $form = $button->getForm();\n            $this->form->onSuccess($form, $form->getValues());\n            $this->form->onSaveAndStay($form, $form->getValues());\n\t\t};\n\t}\n\n}\n```\n\nPokud sledujete fórum, tak vám je tento návrh jistě povědomý. Jedná se o [slavné řešení pod čarou](https://forum.nette.org/cs/11747-skladani-komponent-a-formulare#p84652). Přesně toto se odehrává v rodičovské třídě `BaseFormContainer`. Doplnil jsem si do této třídy však jednu malou vychytávku. Chtěl jsem totiž, aby každý kontejner mohl mít vlastní šablonu. To běžně není možné. Kontejner tedy mohu vykreslovat pomocí dobře známého makra `{control ...}` (což nedělá nic jiného, než že se zavolá metoda `render`). Jenže co je `$this->template`? Bázový kontejner jsem musel rozšířit ještě o vhodnou část z `UI\\Control`, která se stará o vykreslování:\n\n```php\nabstract class BaseFormContainer extends Forms\\Container {\n\n\t/** @var UI\\ITemplateFactory */\n\tprivate $templateFactory;\n\n\t/** @var UI\\ITemplate */\n\tprivate $template;\n\n    public function injectTemplateFactory(UI\\ITemplateFactory $templateFactory) {\n\t\t$this->templateFactory = $templateFactory;\n\t}\n\n\tabstract public function render();\n\n    public function getTemplate() {\n\t\t// bla bla, mrkni na: https://api.nette.org/2.3.7/source-Application.UI.Control.php.html#45\n\t\treturn $this->template;\n\t}\n\n\tprotected function createTemplate() {\n\t\t/** @var UI\\ITemplateFactory $templateFactory */\n\t\t$templateFactory = $this->templateFactory ?: $this->lookup(UI\\Presenter::class)->getTemplateFactory();\n\t\treturn $templateFactory->createTemplate(NULL);\n\t}\n```\n\nJednoduché vykreslitelné formulářové kontejnery. Cool. Abych to rychle zrekapituloval. Máme jednoduchou komponentu na formulář, která dědí od `BaseControl`. Tato třída připojuje ve vhodný čas formulářové kontejnery, které se umí vykreslit (což běžně nejde).\n\nV šabloně `SubmitButtonsContainer.latte` je možné používat normálně `{input ...}` makra a další, jako kdybych pokračoval dál v šabloně jednoho velkého formuláře. Samotné připojené formulářové kontejnery je možné vykreslovat pomocí klasického makra `{control newsForm-submitButtons}` v hlavním formuláři. To je možná trošku nevýhoda, protože kontejnery se připojují do formuláře a stávají se tak podkomponentou. Musím tedy control makro volat stylem *rodič-podkomponenta*.\n\n# Znovupoužitelnost vykreslitelných kontejnerů\n\nKde je ta znovupoužitelnost? Jak bych udělal to, že použiju třeba odesílací tlačítka (nebo jakoukoliv jinou část formuláře) někde jinde? Jednoduše. Prostě vytvoříme formulář (to je podmínka nutná) a kontejner v něm použijeme:\n\n```php\nprotected function createComponentTest() {\n    $form = new UI\\Form;\n    $form->addComponent(new AnotherContainer, 'another');\n    $form->addSubmit('odeslat', 'Odeslat');\n    $form->onSuccess[] = function ($_, ArrayHash $values) {\n        dump($values);\n    };\n    return $form;\n}\n```\n\nK tomu třeba nějaká taková šablona:\n\n```\n{form test}\n    {control test-another}\n    {input odeslat}\n{/form}\n```\n\nFormulář se samozřejmě vykreslí i při obyčejném `{control test}`, ale bez šablony kontejneru (píšu si nápad na vylepšení). Vlastně je ta myšlenka docela jednoduchá, že? Jen je třeba dát pozor na to, že kontejner takto umisťuje formulářové prvky na jinou úroveň.\n\nMalá poznámka na závěr, která je sice mimo, ale může se hodit. Občas je potřeba zajistit si někde inject závislostí, ale z nějakého důvodu je to problematické. Může se jednat třeba o závislost v abstraktní rodičovské třídě. V takovém případě je možné v configu nastavit [decorator](https://github.com/dg/nette-di/blob/master/tests/DI/DecoratorExtension.basic.phpt):\n\n```neon\ndecorator:\n\tBaseFormContainer:\n\t\tinject: on\n```\n\n<del>Příště se podíváme znovu na [Dependent select box](dependent-select-box). Původní článek si totiž zaslouží důkladnou revizi a po krátké anketě jsem byl přesvědčen, že bude lepší napsat nový článek a podívat se na celý problém podrobněji.</del> <span style=\"color:green\">Podívejte se raději na <a href=\"https://github.com/NasExt/DependentSelectBox\">tento doplněk</a>, který závislý select box řeší jinak - možná lépe.</span>","frontmatter":"id: d0a905ac-329a-46a9-899b-bfe7518519c4\ntimestamp: 1448405176000\ntitle: Znovupoužitelné části formuláře\nslug: znovupouzitelne-casti-formulare"},{"attributes":{"id":"334c8bae-af8a-4b17-9735-dfba909f5fa1","timestamp":1447611844000,"title":"Od indexu až po presenter","slug":"od-indexu-az-po-presenter"},"body":"Když jsem se učil pracovat s Nette Frameworkem, musel jsem v začátcích hodně přivírat oči a říkat si \"prostě to tak je\". Hodně věcí bylo zahaleno do tmy. Teď už to tak naštěstí není, ale stále se stává, že mi někdo napíše a děkuje za poodhalení a vysvětlení toho, jak to funguje na pozadí (za což zase děkuji já). Pokusím se tedy pokračovat a vrátím se na úplný začátek - do `index.php` a poodhalím, jak probíhá start takové běžné aplikace. A jako vždy - co nejjednodušeji.\n\nZodpovím (nebo alespoň nastíním odpovědi na) následující otázky:\n- proč redirect vyvolává AbortException\n- jak napsat vlastní NanoPresenter\n- proč má Nette dva request objekty\n- kde se bere životní cyklus presenteru\n\n# Start aplikace\n\nNedávno jsem dostal v práci na starost implementovat Nette do jednoho legacy projektu. Už jsem tu o tom [psal](navrhovy-vzor-legacy-code). Byl to nesmírně vyčerpávající úkol, ale už mám hotovo a jsem ve fázi nekonečného refaktoringu. Jednou z prvních věcí, které bylo nutné vyřešit byl start aplikace z jednoho místa. Toto naštěstí řeší [web-project](https://github.com/nette/web-project) (nebo [sandbox](https://github.com/nette/sandbox) chcete-li) už v základu takto (`.htaccess`):\n\n```\n<IfModule mod_rewrite.c>\n\tRewriteEngine On\n\n\tRewriteCond %{REQUEST_FILENAME} !-f\n\tRewriteCond %{REQUEST_FILENAME} !-d\n\tRewriteRule !\\.(pdf|js|ico|gif|jpg|png|css|rar|zip|tar\\.gz|map)$ index.php [L]\n</IfModule>\n```\n\nČímž se velmi rychle dostáváme k prvnímu bodu, kterým je `index.php`:\n\n```php\n/** @var \\Nette\\DI\\Container $container */\n$container = require __DIR__ . '/../app/bootstrap.php';\n/** @var \\Nette\\Application\\Application $application */\n$application = $container->getByType(\\Nette\\Application\\Application::class);\n$application->run();\n```\n\nV tomto souboru vše začíná a také končí. Totiž zavolá se ještě minimálně `\\Tracy\\Debugger::shutdownHandler`, `\\Nette\\Http\\Session::clean` a `\\Nette\\Http\\Response::__destruct`, ale zůstaňme u toho, že zde vše začíná a také končí. O co v indexu vlastně jde? Hned přeskočím první řádku, ačkoliv se jedná o nezanedbatelnou část. Z bootrapu získáme hotovou instanci [DIC](https://doc.nette.org/cs/2.3/dependency-injection), resp. přímého potomka. Následuje vytažení [Application](https://api.nette.org/2.3.7/Nette.Application.Application.html) a naškytnutí aplikace pomocí metody `run`. To je předpokládám všem jasné, proto jsem to vzal letem světem. Cílem tohoto článku je však popsání právě `run` metod.\n\n# Run, run!\n\nMetoda `\\Nette\\Application\\Application::run` vypadá přesně takto:\n\n```php\npublic function run()\n{\n    try {\n        $this->onStartup($this);\n        $this->processRequest($this->createInitialRequest());\n        $this->onShutdown($this);\n    } catch (\\Exception $e) {\n        $this->onError($this, $e);\n        if ($this->catchExceptions && $this->errorPresenter) {\n            try {\n                $this->processException($e);\n                $this->onShutdown($this, $e);\n                return;\n            } catch (\\Exception $e) {\n                $this->onError($this, $e);\n            }\n        }\n        $this->onShutdown($this, $e);\n        throw $e;\n    }\n}\n```\n\nPro přehlednost to ještě zjednoduším a vyhodím vše, co pro samotné spuštění aplikace není nezbytně nutné:\n\n```php\npublic function run()\n{\n    try {\n        $this->processRequest($this->createInitialRequest());\n    } catch (\\Exception $e) {\n        if ($this->catchExceptions && $this->errorPresenter) {\n            $this->processException($e);\n            return;\n        }\n        throw $e;\n    }\n}\n```\n\nMoc toho opět nezbylo. Vlastně se zde dějí jen tři věci. Prvně [createInitialRequest](https://api.nette.org/2.3.7/source-Application.Application.php.html#102-124). Tato metoda vrátí (jak už název napovídá) tzv. aplikační request. To je objekt, který pak putuje celou aplikací a nese si informaci o tom co vlastně uživatel chce. Vzpomínáte si na článek o [dynamickém routování URL adres](dynamicke-routovani-url-adres)? Tam jsem ukazoval, jak se HTTP request změní právě na aplikační a zpět. Celá sranda se tedy odehrává někde v RouterFactory (zatím to platí, do budoucna ale [nebude](https://github.com/nette/routing/commit/e802a85e96f5814ddf1a16ea1517398eb560bab6)). Samotný HTTP request se pak dostane do `Application` díky DI. Už v `createInitialRequest` je tedy jasné, jestli je možné požadavek přeložit, nebo 404. Pokud 404, tak konec, resp. `processException` pokud je to v configu zapnuté (což jinými slovy znamená forward na error presenter):\n\n```neon\napplication:\n    catchExceptions: yes\n```\n\nPokud se však povede získat aplikační request, nastupuje funkce `processRequest`. Mrkněte na [implementaci](https://api.nette.org/2.3.7/source-Application.Application.php.html#127-150). Opět se nejedná o nic složitého. Jde zde vlastně jen o jedinou věc. Získat presenter a zavolat nad ním `run`. Proč `run`? Presenter totiž není potomek `\\Nette\\Application\\UI\\Presenter` jak si pamatují skoro všichni, ale spíše objekt, který implementuje interface `\\Nette\\Application\\IPresenter` jehož jedinou metodou je právě `run` do které se jako jediný parametr předává již zmíněný aplikační request. Zároveň musí tato metoda vracet `\\Nette\\Application\\IResponse`.\n\nZ toho plyne, že pokud potřebujeme velmi jednoduchý presenter (který skoro nic neumí, ale je rychlý), stačí si implementovat `IPresenter` rozhraní a hotovo:\n\n```php\nclass NanoPresenter extends Nette\\Object implements Nette\\Application\\IPresenter\n{\n\n\tpublic function run(Nette\\Application\\Request $appRequest)\n\t{\n\t\treturn new Nette\\Application\\Responses\\TextResponse('It works!');\n\t}\n\n}\n```\n\nV běžném presenteru se toho však děje samozřejmě mnohem více. Právě v metodě `run` se schovává celý dobře známý životní cyklus presenteru. Než se však dostanu k reálnému příkladu, začnu na tomto jednoduchém. `NanoPresenter` vrací pouze `TextResponse` s obyčejným textem. Tato odpověď je předána zpět do `processRequest` a následně je hned zavoláno `\\Nette\\Application\\IResponse::send` což v tomto konkrétním případě vyústí v obyčejné echo. Co se však děje v běžném presenteru?\n\n# Vykreslení šablony\n\nPresenter, který dědí od `\\Nette\\Application\\UI\\Presenter` dělá téměř to samé. Jediný rozdíl je v tom, že presenter vlastně vykreslitelná komponenta, takže si vezme šablonu a předá ji stejně jako v předchozím případě do `TextResponse`. Zde je oproti mému `NanoPresenter` příkladu malý implementační rozdíl, ale ve výsledku presenter tak jako tak `TextResponse` vrátí zpět `Application` objektu do `processRequest` metody. Dále se opět zavolá `\\Nette\\Application\\Responses\\TextResponse::send`, tentokrát však nedojde k obyčejnému echu, ale spustí se renderování předané šablony (`\\Nette\\Application\\UI\\ITemplate`). Většinou to tedy propadne na Latte, ale to samozřejmě není podmínkou.\n\n```php\npublic function send(Nette\\Http\\IRequest $httpRequest, Nette\\Http\\IResponse $httpResponse)\n{\n    if ($this->source instanceof Nette\\Application\\UI\\ITemplate) {\n        $this->source->render();\n    } else {\n        echo $this->source;\n    }\n}\n```\n\nZ předchozího textu by mělo být zřejmé, kudy požadavek putuje. Když si prohlédnete detailněji to co jsem zde popsal, mělo by být jasné, že se interně používá `\\Nette\\Application\\AbortException` a proto je nebezpečné v presenterech chytat bezmyšlenkovitě všechny výjimky. Nikdo pak nechce řešit \"proč to Nette zase nepřesměrovává\".\n\nTento text by měl překlenout tu temnou propast mezi `index.php` a akcí v presenteru. Příště už se snad vrhnu na něco zajímavějšího... :)","frontmatter":"id: 334c8bae-af8a-4b17-9735-dfba909f5fa1\ntimestamp: 1447611844000\ntitle: Od indexu až po presenter\nslug: od-indexu-az-po-presenter"},{"attributes":{"id":"8474ac83-61b4-4afe-b0d5-ca7ba4e62501","timestamp":1444573684000,"title":"Ještě lepší struktura Nette aplikace","slug":"jeste-lepsi-struktura-nette-aplikace"},"body":"Každý, kdo postavil pár aplikací, musel vždy řešit ten samý problém. Jakou strukturu by měla aplikace mít? A co když se začne projekt rozrůstat? Měl bych se držet toho jak to dělá [sandbox](https://github.com/nette/sandbox) (resp. [web-project](https://github.com/nette/web-project))? Postupem času jsem dokonvergoval k relativně přijatelnému výsledku a vzhledem k tomu, že projekt na kterém jsem to poprvé pořádně rozjel byl ukočen, [rozhodl jsem se jej zveřejnit](https://github.com/mrtnzlml/CMS-lite). Už je to sice nějaký čas, ale v době největšího vrcholu tohoto projektu jsem jej považoval za takovou osobní špičku. A to hned z několika důvodů. K tomu se ale dostanu postupně. A vezmu to pěkně od těch nejmenších částí.\n\n# Presentery a komponenty\n\nU presenterů se mi vlastně docela líbí jak to dělá sandbox. Ve složce presenterů jsou logicky presentery a také složka `templates`, která obsahuje šablony právě k těmto presenterům:\n\n```\npresenters/\n    templates/\n        Homepage/\n            default.latte\n        @layout.latte\n    BasePresenter.php\n    HomepagePresenter.php\n```\n\nDříve to bylo jinak. Šablony a presentery měl dříve sandbox na stejné úrovni, ale souhlasím s tím, že šablony patří spíše (a poměrně úzce) k presenterům. Je tedy nutné zmínit, že díky tomu jak je Nette framework chytrý, tak je v podstatě jedno jakou bude mít projekt strukturu, protože bude fungovat vše. Za chvíli se však začne vše nabalovat a bude třeba neustále udržovat pořádek. Proto je nutné mít jasno i v takto triviálních otázkách.\n\nKomponenty se od presenterů tolik neliší. Spíše naopak. Komponenty mohou být poměrně komplikované, ale rád je dělám co nejjednodušší. U komponent používám několik návrhů. Pro velmi triviální komponenty zachovávám plochou strukturu:\n\n```\nContactForm/\n    ContactForm.latte\n    ContactForm.php\n```\n\nJe totiž otrava vytvářet spoustu zbytečných složek. To platí i pro soubory. Proto jsou generované továrničky vždy k nalezení pod třídou komponenty v jednom a tom samém souboru. Jakmile se však komponenta jen o trošku zkomplikuje, automaticky přepínám do klasického presenterového stylu:\n\n```\nContactForm/\n    providers/\n        IContactFormTemplateProvider.php\n    templates/\n        ContactForm.latte\n    ContactForm.php\n```\n\nDobře, základní stavební kameny jsou položeny. Co by však mělo být okolo. A kde jsou vlastně položeny? Inu pojďme na to opět postupně.\n\n# Supercore věci\n\nFakt nevím jak to nazvat jinak, protože ke core záležitostem se ještě dostanu. O co tedy jde? Jedná se o části aplikace, které tvoří to nejzákladnější jádro. Jádro, na které je pak možné napojovat další věci. Tuto část aplikace nechávám ve složce `app`:\n\n```\napp/\n    AdminModule/\n        presenters/ <-- viz první ukázka (je zde jen BasePresenter)\n    AuthModule/\n        presenters/ <-- jen SignPresenter\n    FrontModule/\n        presenters/ <-- viz první ukázka (Base, Contact, Homepage)\n    components/\n        ContactForm/ <-- také už známe (viz druhá ukázka)\n        AControl.php\n    config/\n    extensions/\n    bootstrap.php\n```\n\nJak je vidět, tak všechny moduly obsahují jen kritický základ. Žádné další presentery. Tak kde je zbytek? Zbytek se nechází v rootu aplikace, konkrétně ve složkách `custom` a `src`. Je celkem jedno jaký je název těchto složek, vtip je v tom nějaké mít a vše sem přesunout. Důvod proč jsou dvě je prostý. Zatímco v `src` jsou části aplikace, které tvoří jádro (tedy spoustu funkčnosti), v `custom` jsou velmi podobné částí aplikace, bez kterých lze však žít. Původní myšlenka byla taková, že se pak custom složka zruší a vše v ní se velmi elegantně rozpadne na composer balíčky. Obě složky jsou však strukturálně stejné, proto budeu řešit jen `custom`.\n\n# Business logika\n\nOk, to jsem také nazval pěkně debilně. Alespoň však vysvětlím jednu důležitou věc, se kterou jsem v začátcích bojoval a kterou je potřeba se odnaučit. Sadbox vždy totiž vedl k takovéto podobné struktuře:\n\n```\napp/\n    config/\n    forms/\n    presenters/\n    model/\n    router/\n```\n\nTo nikomu nemám za zlé. Je to jednoduše pochopitelné a to je dobře. Takže s tím vlastně spíš souhlasím. Problém je v tom, že u rozrůstající aplikace už to začíná být děsný mrdník, protože `presenters` najednou obsahují všechny presentery a `model` obsahuje všechnu logiku. Ale v tom aby se prase vyznalo. Tento efekt se nechá trošku umírnit rozdělením aplikace na moduly a s tím už jsem byl (a vlastně do dneška jsem) spokojen. Jenže co s tím modelem? Fuck model! Rozdělte si model podle logických částí, které na sobě nejsou závislé a vše oddělte. Třeba takto:\n\n```\ncustom/\n    Error/\n    Eshop/\n    Files/\n    Notes/\n    Pages/\n```\n\nJak řekl kdosi moudrý, existují dva nejnáročnější problémy v programování a to správná invalidace cache a pojmenovávání věcí. Naprosot s tím souhlasím. Moc mi to nejde, ale mělo by být zřejmé, že jsou zde části, které se starají (výhradně) o eshop, o poznámky, stránky atd. Pojďme se tedy zanořit hlouběji:\n\n```\nPages/\n    AdminModule/\n        presenters/\n            CategoryPresenter.php\n            PagePresenter.php\n    components/\n        PageForm/\n        PagesGrid/\n    DI/\n    FrontModule/\n    listeners/\n    Category.php\n    Page.php\n    ...\n```\n\nA voilà, máme tu zase strukturu složky `app`. Nebo alespoň její obdobu. A v tom je síla toho návrhu. Mělo by už teď být jasnější, proč jsou v `app` právě ty věci co tam jsou. Celém vždy bylo mít v systému místa, které obsahují velmi podobné věci, ale nic dalšího. Drobné niance se zde najdou, to je jasné, ale základ zůstává. Jenže jak to sakra funguje?\n\n# Jak to sakra funguje\n\nPrávě teď je ten správný čas [proklikat si celý systém](https://github.com/mrtnzlml/CMS-lite). Je zřejmé, že už je to trošku komplikovanější a samo od sebe to fungovat nemůže (ani to není žádoucí). Zkušenější už tuší, že celé kouzlo je ve složce `DI`. Zde je tedy mé další doporučení. Až rozsekáte aplikaci do komponent, udělejte to samé s funkcionalitou. A víte co, udělejte to se vším co spolu nějak logicky souvisí. Proto jsem do složky `custom/Pages` umístil vše co patří ke stránkám. Komponenty, doctrine entity, servisní třídy, fasády, ale také presentery. Prostě všechno. Dělejte to tak dlouho, dokud v `app` nezůstane nic.\n\nTento způsob však s sebou nese celou řadu úskalí. Prvně je to komplikované. A pak je třeba vše napojit. Existují dva způsoby, které mi přijou v pořádku. První je poněkud agresivní, ale jednoduchý. Vychází vlastně z myšlenky [Flame\\Modules](http://flame-org.github.io/Modules/). Napíšete si nějaké rozšíření, které bude implementovat nějaký interface. Třeba `IFaviconProvider`. Pak je třeba mít (právě v supercore) rozšíření, které takový interface najde a při vytváření DIC zpracuje. Hodně toho využívají šablony (`custom/Versatile/DI/VersatileExtension.php`). Nebezpečí je však v tom, že se to prostě stane jakmile přidáte toto rozšíření do aplikace. Není zde moc rozumná možnost jak třeba rozšíření deaktivovat. A ještě komplikovanější je pak při vytváření DIC přeba automaticky spustit nějaký SQL dotaz.\n\nProto je zde druhý způsob (který jsem pořádně nestihl dodělat). Využívá jej například `\\Eshop\\DI\\EshopExtension`. To implementuje `ICustomExtension`. Jiné (supercore) rozšíření se toho chytí a udělá pouze to, že jej zobrazí v administraci včetně potřebných odadtečných informací. Stejně tak jako to dělá WordPress. Uživatel zde může kliknutím modul nainstalovat, což se přesně u eshopu děje a spustí se tak celá řada komplikovaných operací, které tento modul nainstalují. Jedná se zejména o předání URL adres, nastavení ACL, zaregistrování položek do menu atd. Elegantně se tak celý systém připraví a díky tomu, že dojde k registraci do DIC, není důvod k tomu, aby se s narůstajícím počtem modulů systém nějak dusil. Prostě se chová jako jakákoliv jiná velká aplikace. Nic není hledáno a řešeno dynamicky za běhu aplikace. Druhý krok je už pak dodělat instalace modulů ze vzdáleného repozitáře, ale to už je jednoduchý úkol.\n\nA je to. Elegantní instalační systém pluginů pro vaší Nette aplikaci.\n\n# Další zajímavé vlastnosti systému\n\nTakže to máme peckovou strukturu aplikace, kterou je velmi jednoduché udržovat a rozšířovat + automatickou registraci modulů (pluginů chcete-li). A to jsem teprve na začátku. Proto už jen bodově vypíchnu a připomenu některé zajímavé věci, které všem dávám k dispozici.\n\n1. Každé rozšíření je v Nette nutné registrovat do konfiguračního souboru. To by s tím ale nešlo nělat takové švíky. Proto jsem napsal `\\App\\Extensions\\CoreExtension`, které to dělá automaticky. Není to zrovna ukázka čistého kódu, ale svůj účel to plní dobře. Už touto vlastností jste několik mil před konkurencí... (-:\n2. Vzpomínáte si na [Hierarchický router](hierarchicky-router)? Tak i ten je zde v celé své kráse. Jen pro připomenutí. Je možné měnit si URL adresy jak chcete, nikdy nepřijdete o ty staré a výkonově to nestojí nic navíc.\n3. [Dynamické routování URL adres](dynamicke-routovani-url-adres). To je další fičura, kterou jen tak někdo nemá. Nebo snad ano? Použijte ji. Vybudujte něco úžasného.\n4. A co takhle Fixtures. [Vzpomínáte si](fixnete-si-databazi)?\n5. Všimněte si, že hodně rozšíření obsahuje jakési providery. Je tak možné jednoduše třeba zaměnit šablonu kontaktního formuláře, nebo navigace. Obdobně mohou rozšíření registrovat vlastní styly i javascriptové skripty.\n6. K dispozici jsou Doctrine migrace. K dispozici jsou v nabídce přes `php index.php`. Samotné migrační skripty jsou pak v `migrations` složce.\n\nJe toho fakt ranec, co pouštím na obdiv i kritiku. Proto ještě stručněji přehled technologií, které v projektu naleznete:\n\n- grunt + grunt-contrib packages (concat, copy, cssmin, less, uglify)\n- bootstrap, nette.ajax.js, nette-forms, jquery, selectize\n- nette (application, caching, DI, finder, forms, robot-loader, security, utils, ...)\n- latte, tracy, texy, webloader, minify, faker, secured-links\n- kdyby (doctrine, annotations, console, events, translation, autowired, monolog, ...)\n- doctrine (data-fixtures, migrations, ORM, ...)\n- testbench, nette\\tester\n\nA to jsem zde ještě nenapsal vše. Mrkněte se na náhled, nejedná se jen o nějaký marný pokus:\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/9b3c176d-4884-45c5-95c3-53cac2999d0f/admin.png)\n\n# Instalace systému\n\nBohužel jsem nevychytal všechny mouchy, půlka věcí zůstala nerozdělána a celý materiál je spíše pro inspiraci. Pokud by si to však někdo chtěl rozjet, dávám k dispozici také poněkud složitější návod na instalaci (viz readme):\n\n- Nainstalujte si [GIT](http://git-scm.com/)\n- `git clone https://github.com/mrtnzlml/CMS-lite.git`\n- Nainstalujte si [Composer](http://getcomposer.org/)\n- `composer install` (natáhne PHP závislosti)\n- Vytvořte si prázdnou MySQL databázi\n- Přejmenujte `config.local.neon.dist` (v app/config) na `config.local.neon` a nastavte přístupové údaje k databázi\n- `php index.php orm:schema-tool:create` (vygeneruje strukturu databáze)\n- `php index.php cms:fixtures:load` (našte základní data, teď už by měla aplikace fungovat)\n- Nainstalujte si [Bower](http://bower.io/), popř. [npm](https://www.npmjs.com/) je-li třeba\n- `bower install` (fetches JS dependencies)\n- Nainstalujte si [Grunt](http://gruntjs.com/)\n- `grunt` (připraví JS, CSS, fonts, ...)\n\nKaždý příkaz by měl být spouštěn z rootu webu. Výjimku tvoří příkazy obsahující `index.php`. Ty je třeba spouštět ze složky `www`. To dá asi rozum.\n\nA na závěr. Jsem realista. Nepředpokládám, že by se projektu někdo doprovolně chytil a nakopl mě, aby v něm pokračoval aktivněji. Zatím jej spíš nikdo nepochopil a musel jsem si protrpět i pár klacků pod nohama. Proto jej dávám k dispozici jako inspiraci pro ostatní. Nemám strach, že by si to někdo přivlastnil, nebo na tom zbohatl. To si spousta firem (lidí) neuvědomuje a tak nikdo raději nezveřejňuje nic. Zveřejňujte, předávejte znalosti - nepřijdete o ně. Nicméně v rámci gentlemanské dohody bych rád vyměnil své předané znalosti za hvězdičku u tohoto nového repozitáře. Nic víc nežádám.\n\n<iframe src=\"https://ghbtns.com/github-btn.html?user=mrtnzlml&repo=CMS-lite&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"160px\" height=\"30px\"></iframe>\n\nPokorně děkuji.","frontmatter":"id: 8474ac83-61b4-4afe-b0d5-ca7ba4e62501\ntimestamp: 1444573684000\ntitle: Ještě lepší struktura Nette aplikace\nslug: jeste-lepsi-struktura-nette-aplikace"},{"attributes":{"id":"00ea90cf-cd53-48f0-959a-bb1a2264344d","timestamp":1443869668000,"title":"Crazy JavaScript PDF generator","slug":"crazy-javascript-pdf-generator"},"body":"Kdysi mi někdo řekl, že správný programátor by měl být tak trošku děvka pro všechno. Nestačí jen umět PHP. Nestačí jen umět JavaScript. S tímto názorem jsem od samého začátku souhlasil. Ostatně je to jeden z důvodů, proč se občas zajímám i o věci, které v nejbližší době nevyužiju a zase tolik jim nerozumím (také to podle toho pak vypadá). Jednou z takových věcí je [React](http://facebook.github.io/react/index.html). Nedávno jsem si hrál také s [PhantomJS](http://phantomjs.org/) a když už jsme u toho, tak ani [NodeJS mi není cizí](http://www.slideshare.net/MartinZlmal/nodejs-42314371). A co se stane, když se jednoho večera rozhodnete spojit všechno dohromady? Něco šíleného... (-:\n\n# Krátké seznámení\n\nVzhledem k tomu, že tento blog byl vždy zacílen spíše na začátečníky, bylo by vhodné jednotlivé projekty krátce přiblížit.\n\n[React](http://facebook.github.io/react/index.html) vytvořený Facebookem se sám prezentuje jako knihovna pro stavění uživatelských rozhraní. V sekci [Why React?](http://facebook.github.io/react/docs/why-react.html) se lze však dočíst zajímavější skorodefinici: *\"Many people choose to think of React as the **V** in MVC.\"* Celá myšlenka Reactu je postavená na komponentách. A já mám [komponenty rád](https://doc.nette.org/cs/components). Myslím si, že je to dobrý směr jak udržet v aplikaci chaos na rozumné úrovni. Než abych to zde však dlouhosáhle popisoval, doporučuji pojet si [Getting Started](http://facebook.github.io/react/docs/getting-started.html).\n\n[PhantomJS](http://phantomjs.org/) je oproti tomu úplně něco jiného. Jedná se o tzv. \"headless browser\" - velmi volně přeloženo prohlížeč bez grafického rozhraní. Je to takové Safari bez Safari. Prohlížeč, kterému úplně chybí (jinak pomalá) renderovací vrstva. Nejedná se tedy o prohlížeč, který by chtěl kdokoliv používat, ale spíše o nástroj, kterým lze skutečný prohlížeč nahradit třeba na serveru. Primárně se tedy používá pro testování aplikací, ve fantazii se však meze nekladou. Je tak možné např. tvořit screeny webů, nebo spouštět plně JavaScriptové stránky a koukat se na jejich obsah. Já jej začal používat kvůli rychlosti (oproti Seleniu), v tomto konkrétním případě však slouží právě pro spuštění čistě JavaScriptové stránky.\n\nNo a konečně [NodeJS](https://nodejs.org/en/) - JavaScriptové prostředí pro server. Zatímco ostatní jej využívají pro tvorbu aplikací, které jsou napsány v JS prakticky kompletně (server,  klient), já jej využíval kvůli svým vlastnostem spíše na rychlou komunikaci elektronika - server. To se mi na JS líbí. Dnes se nechají napsat i velmi složité věci pomocí pár řádek, ale třeba práce s časem a datumem bude vždy oser... (-:\n\n# Něco šíleného\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/e80e305e-8431-4c0e-9c79-5db761c22608/199aff3.jpg)\n\nTo je tak když se sejde několik věcí najednou. Vytvořit si faktury, otestovat aplikaci, neustálý přirozený hlad po NodeJS. A pak to přišlo. Co si tak vytvořit [generátor faktur](https://github.com/mrtnzlml/js-invoice-generator), který bude samotnou fakturu stavět pomocí Reactu, server bude tvořit NodeJS a PDF budu generovat tak, že si tu stránku otevřu v PhantomJS a uložím (čímž snad získám velmi přesný výsledek)? Samozřejmě jsem se pokukoval i po již hotových řešeních jako je třeba [Fakturiod](https://www.fakturoid.cz/). A kdybych byl jen o kousek línější, tak bych asi nic takového netvořil. Nakonec jsem se však pouze inspiroval [peckovým designem jedné z jejich faktur](https://www.fakturoid.cz/blog/2015/08/25/nova-verejna-stranka-faktury) (protože k designu mám asi tak daleko jako k Praze z Azor) s tím, že jí komplet napíšu znova pomocí komponent v Reactu a budu se modlit, aby to nikoho z Fakturoidu (až si tento článek přečte) neurazilo... (-:\n\nPrvním krokem bylo [naškytnout samotný server](https://github.com/mrtnzlml/js-invoice-generator/blob/master/run.js). Zde bylo potřeba nastartovat ještě samotný PhantomJS pomocí [child_process](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options). Mohl jsem to udělaj jakkoliv jinak, ale takovou opičárnu jsem si vždy chtěl vyzkoušet. Samotná příprava stránky pro PhantomJS je pak [jednoduchá](https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.js). Takže server funguje a PhantomJS běží. Co dál?\n\nChtělo by to něco co by šlo renderovat. Takové minimální rozumné HTML může vypadat fakt jednoduše:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\"/>\n    <script src=\"react.js\"></script>\n</head>\n<body>\n    <div id=\"react-root\"></div>\n    <script src=\"build/index.js\"></script>\n</body>\n</html>\n```\n\nKde `react.js` je samotný React a `build/index.js` obsahuje definici komponent:\n\n```jsx\nvar LikeButton = React.createClass({\n\trender: function () {\n\t\treturn (\n\t\t\t<button>LikeButton</button>\n\t\t);\n\t}\n});\n\nReact.render(<LikeButton />, document.getElementById('react-root'));\n```\n\nJe to fakt minimální, ale funkční kód, takže si to může vyzkoušet každý. Přechozí zápis samozřejmě není JavaScript, ale [JSX](https://facebook.github.io/jsx/), takže je třeba jej ještě přeložit (`jsx --watch src/ build/`). Výsledný kód je pak v tomto konkrétním jednoduchém případě velmi podobný:\n\n```javascript\nvar LikeButton = React.createClass({displayName: \"LikeButton\",\n\trender: function () {\n\t\treturn (\n\t\t\tReact.createElement(\"button\", null, \"LikeButton\")\n\t\t);\n\t}\n});\n\nReact.render(React.createElement(LikeButton, null), document.getElementById('react-root'));\n```\n\nPokud se vrátím zpět k faktuře, tak její HTML [je také velmi jednoduché](https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.html) a celá sranda se odehrává [zde](https://github.com/mrtnzlml/js-invoice-generator/blob/master/src/react-invoice.js). Zde jsem si také schválně chtěl vyzkoušet, jak reálně funguje [Inline Styles](https://facebook.github.io/react/tips/inline-styles.html). Samotná faktura je tedy tvořena pouze krátkým HTML a pěknou kopou JavaScriptu. Žádné CSS. Abych řekl pravdu, tak se mi s tím moc dobře nepracuje, ale to je dáno spíše tím, že zase až tolik CSS nehovím a proto bylo místy komplikované přemýšlet nad tím jak funguje React a zároveň držet v hlavě to, jak má faktura nakonec vypadat. Koukal jsem se, jak se to řeší na jiných webech jedoucích na Reactu a asi se o zase až tak nepoužívá. Ale konec naříkání. Podívejte se [na výsledek](https://github.com/mrtnzlml/js-invoice-generator/blob/master/invoice.pdf).\n\n# QR kód\n\nJeště bych se rád zaměřil na samotný QR kód, který je na faktuře ([komponenta](https://github.com/mrtnzlml/js-invoice-generator/blob/master/src/react-invoice.js#L246-L269)). Použil jsem [stejnou knihovnu](https://larsjung.de/jquery-qrcode/), kterou používám zde na blogu v záhlaví (nejlepší). Protože se jedná o QR, tak se nedá čekat, že by obsahoval něco složitého ([podrobný popis formátu](http://qr-platba.cz/pro-vyvojare/specifikace-formatu/)):\n\n```\nSPD*1.0*ACC:CZ4101000000123456789101+KOMBCZPPXXX*AM:2750.00*CC:CZK*MSG:PLATBA FAKTURY 2015-0001*X-VS:20150001\n```\n\nJe to takový hloupý [RESP](http://redis.io/topics/protocol). Řetězec začíná označením formátu `SPD*1.0*` a následuje vždy výčet položek `klíč:hodnota*`, které chceme do QR kódu dostat. Povinný je pouze `ACC`, což je IBAN, popř. IBAN+BIC. Následuje částka, měna, zpráva pro příjemce a variabilní symbol.\n\nTakže úkol někdy na příště. Přepsat **V** u blogu do Reactu? (-:","frontmatter":"id: 00ea90cf-cd53-48f0-959a-bb1a2264344d\ntimestamp: 1443869668000\ntitle: Crazy JavaScript PDF generator\nslug: crazy-javascript-pdf-generator"},{"attributes":{"id":"23efba3e-e7da-496e-a75f-5e9f736879e6","timestamp":1440940560000,"title":"Návrhový vzor Legacy code","slug":"navrhovy-vzor-legacy-code"},"body":"Asi každý se k tomuto návrovému vzoru jednou dostane. Zatím jsem vždy takovou práci striktně odmítal, ale tentokrát šlo o jinou situaci a svolil jsem k poklesu od OOP frameworku ke špagetě. Ačkoliv má pojem \"legacy code\" celou řadu definic, já osobně jej chápu jako kód, který je prostě starý. Vhodnější by však bylo asi říci, že se jedná o kód se kterým teď musím pracovat, ale nenapsal jsem ho. Zůstaňme však u první definice. Zde platí, že (stejně tak jako jakýkoliv jiný navrhový vzor) obsahuje celou řadu opakujících se poznávacích prvků.\n\nNapříklad mezi vývojáři panuje pozoruhodná pasivita. Nikdo se nepostaví na zadní a nepřijde s něčím novým. Nemyslím novou fičuru, ale nějakou systémovou věc. Na druhou stranu se to dá pochopit. Je to ta nejdražší změna a zase až tak ničemu to z vnějšího pohledu neprospěje. Nepovažuji to za správný přístup, ale taková je asi realita. Bohužel se pak často argumentuje (totální) zpětnou kompatibilitou. Dále tento návrhový vzor předpokládá, že se používá nějaký vypíčený verzovací systém a nikoho to netrápí (viz pozoruhodná pasivita vývojářů). O coding standardu ani nemluvě a globální prostor je samozřejmostí. No a pak samozřejmě klasické věci jako RY přístup (opak [DRY](https://cs.wikipedia.org/wiki/Don%27t_repeat_yourself) - Don't Repeat Yourself), šablonovací systém (pokud vůbec existuje) je stejně debilní jako ten verzovací a v neposlední řadě neotestovaný/neotestovatelný kód.\n\nV mém konkrétním případě jsem se musel potýkat ještě s něčím. Jednak jsem se musel poprat s opačným smýšlením vývojářů. Takže například zatímco všude se direktiva `magic_quotes_gpc` [vypínala](http://php.vrana.cz/vypnuti-magic_quotes_gpc.php), zde se globálně zapínala atd. No a pak samotný globální prostor to je písnička sama pro sebe. Myslel jsem si, že to až takový problém nebude, ale neuvědomoval jsem si, co to vlastně obnáší. Pokud stejně jako já nikdy globální proměnné nepoužíváte, zde je příklad na připomenutí.\n\nJakákoliv globální proměnná, která není nijak dále zabalená je automaticky globální:\n\n```php\n$x = 'y';\ndump($GLOBALS['x']); //y\n```\n\nTo dává smysl a není na tom nic divného. Za mnohem větší problém však považuji fakt, že to funguje i obráceně:\n\n```php\n$GLOBALS['x'] = 'y';\ndump($x); //y\n```\n\nProč je to problém? Protože druhý případ je striktně závislý na použitém kontextu. Tím pádem tato pseudoglobální proměnná funguje ve špagetě, ale když chcete takový kód jinak uspořádat a nedej bože ještě obalit, tak je to problém. Vzhledem k tomu, že bylo mým úkolem integrovat [Nette Framework](https://nette.org/) do takového systému, musel jsem trošku upravit start aplikace a tím jsem hodně věcí rozbil.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/d6ca5ea3-5c1a-43af-8488-73d4fae836f1/strip-wordpress-550-finalenglish.jpg)\n\n# Jak jsem na to šel\n\nNebudu zde rozebírat přesně důvody proč jsem to udělal tak a ne jinak. Většinou mě to k tomu řešení jasně dovedlo, protože dělat to jinak by bylo nesmyslně složité - pokud vůbec možné. Berte to jako inspiraci. Myslím si, že se to bude ještě nekomu hodit, protože je tento návrhový vzor rozšířen více, než si přiznávám.\n\nV první řadě bylo nutné do projektu přidávat závislosti pomocí Composeru. Jednak se tak projekt trošku vyčistil od zbytečně nakopírovaných knihoven a potom jsem mohl s výhodou používat jednotlivé Nette komponenty. Pak je velmi důležité celý projekt poznat trochu hlouběji. Na to není vždy čas. Začal jsem proto tak, že jsem napojil na systém jednodušší části frameworku jako je třeba Tracy, Cache, Utils, RobotLoader atd. S tím se samozřejmě svezlo několik úprav, jako je například zapnutí error reportingu nebo vypnutí zahazování výjimek a další podobné hovadiny. Samotné zapnutí error reportingu je neskutečný oser, protože se tím ukáže, jak se daná aplikace hrozně sype ([však jsou to jen notices](https://media.giphy.com/media/11c2hRHwmvgFOg/giphy.gif), co se může stát). Každopádně už třeba použitím cache na správných místech a úpravou několik funkcí se aplikace rozjela daleko rychleji.\n\nDalší čeho bych se rád zbavil jsou `mysql_*` funkce a nahradil je PDO. To není úplně jednoduchý úkol a pořád je to \"in progress\". Zde jsem zvolil NDB, ale nejsem si tou volbou vůbec jistý. No a pak nastal čas, kdy je třeba přistoupit k hlubší integraci frameworku. To jsem chtěl udělat jako štít před celou aplikací. Tím jsem samozřejmě polovinu věcí rozbil, ale naštěstí už to tak nějak funguje. Co to vlastně znamená? V první řadě například startování aplikace z jednoho místa (což nebylo normální a rozbilo to všechno) a potom napsání LegacyPresenteru, který se stará o zpětnou kompatibilitu se starým jádrem (což zase rozbilo pseudoglobální kontext). No a potom bylo potřeba vyřešit také routování. To však ve výsledku bylo velmi triviální a stačilo napsat několik základních pravidel, za která se schová jakákoliv URL v systému. Jednoduchá implementace takového presenteru může vypadat třeba takto:\n\n```php\n//dodatečná nastavení ve startup()\n\npublic function renderDefault($fakePath = NULL)\n{\n    if (NULL !== $fakePath) {\n        if (file_exists($file = SITE_ROOT . DS . $fakePath)) {\n            require $file; //bacha na Local File Inclusion\n        }\n    }\n}\n```\n\nTato implementace vlastně kopíruje původní chování. Napsání routovacích pravidel je fakt jednoduché:\n\n```php\n$router[] = new Route('<? index(\\.html?|\\.php)>', 'Legacy:default', Route::ONE_WAY);\n$router[] = new Route('[<fakePath .+>]', 'Legacy:default');\n```\n\nMnohem zajímavější je však implementace Smarty šablonovacího systému. K tomu je vhodné napsat si vlastní implementaci render metody objektu [Template](https://api.nette.org/2.3.5/source-Bridges.ApplicationLatte.Template.php.html). Zde se rozhodne, jak se bude šablona vykreslovat. V mém případě jestli pomocí Latte, nebo Smarty. Je samozřejmě nutné upravit i TemplateFactory hlavně kvůli [této řádce](https://api.nette.org/2.3.5/source-Bridges.ApplicationLatte.TemplateFactory.php.html#56).\n\n# Špatné pořadí\n\nVšechno špatně. Teď vím, že jsem měl začít obráceně a nejdříve si na to napsat testy. Alespoň dodatečně (klasicky po prvním problému) jsem si na to ještě napsal jednoduché scénáře pro akceptační testy v Codeception. A pak jsem si měl stát za svým a neústupně odstranit všechny weird věci, protože ty prostě nejsou kompatibilní s moderním frameworkem a způsobuje to jen nepředvídatelné problémy.\n\nJsou vlastně nějaké výhody takové integrace frameworku do starého systému? Vyjma těch klasických, které přináší framework sám o sobě, je teď možné psát nové věci Nette stylem a využívat všechny možnosti (hlavně asi DIC a Latte). Se starým kódem se kromě vyčištění od hovadin vlastně zase až tak dít nic nebude a je možné jej přepisovat do nového kabátku. Osobně bych nejraději odstranil globální proměnné úplně, to je ale na tak velkém projektu skoro nemožné.\n\nNo a pak je zde psychická stránka věci. Jak se budou tvářit ostatní vývojáři až zjistí, že framework nemá jen pomáhat, ale i omezovat, aby programátor nedělal píčoviny? Najednou je programování náročnější. Spousta objektů, žádný `$GLOBALS`, dependency injection... Skvělé však je, že má takovýto úkol i svá nesporná pozitiva. Jedině zde budete pracovat s frameworkem skutečně po částech a tím spíš se nechají jednotlivé části poznat.\n\nMáte také nějaké zkušenosti s legacy projektem?","frontmatter":"id: 23efba3e-e7da-496e-a75f-5e9f736879e6\ntimestamp: 1440940560000\ntitle: Návrhový vzor Legacy code\nslug: navrhovy-vzor-legacy-code"},{"attributes":{"id":"90a00b9f-47cd-4a93-bb59-13a8e1893ab3","timestamp":1436618301000,"title":"Hierarchický router","slug":"hierarchicky-router"},"body":"Tento článek volně navazuje na [předchozí](dynamicke-routovani-url-adres). Zde jsem ukázal, jak vytvořit routy tak, aby bylo možné mít zcela libovolnou adresu a routovat ji na jakoukoliv akci v aplikaci. Dnes to trošku vylepšíme. Přidáme totiž další dva požadavky s tím, že první je ten důležitější:\n\n1. Když se změní adresa (například článku), musí se stará přesměrovat na novou. To se může dít opakovaně a nechceme mít mnohonásobný redirect. Redirect může být maximálně jeden a to pro jakoukoliv starou (i původní) adresu.\n2. Bude možné vytvořit jakoukoliv adresu, která bude přesměrovávat na jakoukoliv jinou.\n\nDruhý požadavek je vlastně jen speciální (zjednodušený) případ toho prvního. Co to znamená? Podívejte se na následující ASCII art. Obsahuje pět obrázků znázorňujících postupné změny přesměrování při přidávání dalších přesměrování. Nebudeme již řešit routování na akce v presenterech, ale práci se samotným URL a jak se bude chovat, když se přesměruje aktuální cílové URL jinam.\n\n```\nURL-1\n\n\nURL-1 ----> URL-2\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-3\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-4 <---- URL-3\n\n\nURL-1 -------.\n             v\nURL-2 ----> URL-5 <---- URL-3\n             ^\n             '----------URL-4\n```\n\nSlovy řečeno, nesmí se **nikdy** stát, aby byla cesta od staré adresy k nové delší, než je jeden skok. Je zřejmé, že původně byla pouze URL-1. Ta byla přesměrována na URL-2. V okamžik, kdy se přesměruje URL-2 na URL-3, původní propojení mezi URL-1 a URL-2 se musí úplně zrušit a naměrovat URL-1 až na URL-3. A tak to pokračuje dále. Z toho je zřejmé, že nazývat tento router hierarchickým je poněkud zavádějící, protože ve skutečnosti se udržuje takový obrácený les. S troškou režie na začátku je to však vhodnější, protože se tím hezky mění průběžně struktura redirectů a je to lepší, než například takto, to je asi všem jasné:\n\n```\nURL-1\n '--> URL-2\n       '--> URL-3\n             '--> URL-4\n                   '--> URL-5\n```\n\n# Přepočet odkazů\n\nV tom to vlastně celé vězí. Je nutné při vytváření redirectu najít všechny staré odkazy a změnit je na nové. Vrátíme se však k předchozímu článku a trošku vylepšíme cache. Tedy cache zůstane stejná, ale vylepšíme její invalidaci následovně:\n\n```php\n$destination = $this->cache->load($path, function (& $dependencies) use ($path) {\n    $destination = $this->em->getRepository(Url::class)->findOneBy(['fakePath' => $path]);\n    if ($destination === NULL) {\n        $this->monolog->addError(sprintf('Cannot find route for path %s', $path));\n        return NULL;\n    }\n    $dependencies = [Nette\\Caching\\Cache::TAGS => ['route/' . $destination->getId()]];\n    return $destination;\n});\n```\n\nPřidáme ke každému uložení cache tzv. tag, díky čemuž bude možné později tuto cache snadno najít a zrušit její platnost. V closure je nutné dělat to takto přes dependencies proměnnou. Jsou samozřejmě i jiné možnosti [jak cache zneplatnit](http://doc.nette.org/cs/2.3/caching#toc-expirace-a-invalidace), ale tento způsob považuji za dostatečný. Hodí se to proto, že až budeme upravovat staré odkazy, tak je (a pouze je) smažeme z cache, čímž zapříčiníme jejich opětovné vytvoření, tentokrát však s jiným přesměrováním.\n\nDo entity URL adresy je třeba přidat další vlastnost - odkaz na sebe.\n\n```php\n/**\n * @ORM\\ManyToOne(targetEntity=\"Url\", cascade={\"persist\"})\n * @ORM\\JoinColumn(referencedColumnName=\"id\", onDelete=\"SET NULL\")\n * @var Url\n */\nprotected $redirectTo = NULL;\n```\n\nTento odkaz využijeme v routeru, který v případě existence tohoto odkazu bude pracovat právě s ním. V opačném případě router pracuje normálně viz předchozí článek. To už tu nebudu řešit. Spíše se podíváme na samotnou tvorbu redirectů. Tu mám umístěnou v `@RedirectFacade::createRedirect`. Tato metoda přijímá dvě čísla (ID) a to odkud se přesměrovává a kam se přesměrovává. Bohužel není možné předat si parciální entitu, protože není možné ji naplnit a odeslat do databáze (vlastnost Doctrine). No a předávat celé entity je zbytečné. Proto jen ID. Zjednodušeně vypadá tato metoda takto:\n\n```php\npublic function createRedirect($from, $to)\n{\n    $this->em->transactional(function () use ($from, $to) {\n        /** @var Url $oldLink */\n        foreach ($this->em->getRepository(Url::class)->findBy([\n            'redirectTo' => $from\n        ]) as $oldLink) {\n            $oldLink->setRedirectTo($this->em->getPartialReference(Url::class, $to));\n            $this->cache->clean([Nette\\Caching\\Cache::TAGS => ['route/' . $oldLink->getId()]]);\n        }\n\n        /** @var Url $from */\n        $from = $this->em->find(Url::class, $from);\n        $from->setRedirectTo($this->em->getPartialReference(Url::class, $to));\n        $this->em->flush();\n        $this->cache->clean([Nette\\Caching\\Cache::TAGS => ['route/' . $from->getId()]]);\n    });\n}\n```\n\nDalo by se to optimalizovat z hlediska databázových dotazů lépe, ale jednak to není (zatím nebylo) potřeba a pak se hodí tahat si jednotlivé záznamy postupně právě kvůli invalidace cache. Jak to funguje? V první části si vytáhnu všechny odkazy, které ukazují na odkaz ze kterého budu přesměrovávat. To jsou ty staré, které je třeba zrušit. Ty jsou nahrazeny odkazy na nové stránky a jejich cache je samozřejmě smazána. To je ta důležitější část. V druhé polovině dojde jen k uložení nového přesměrování a opět smazání cache pro tento odkaz. Za povšimnutí stojí funkce `getPartialReference` o které jsem psal už minule. Je to funkce, která nevrací celou entitu, ale pouze nenaplněnou entitu s ID (parciální). Nic víc totiž dost často není potřeba...\n\n# Druhá část řešení\n\nDruhá část řešení je již jednoduchá.\n\n> Bude možné vytvořit jakoukoliv adresu, která bude přesměrovávat na jakoukoliv jinou.\n\nStačí entitě povolit, aby mohlo být NULL `destination` (tedy interní odkaz na presenter a akci) a `internalId`. To jsou totiž informace, které nejsou známé a pro tetno účel jsou i zbytečné. Důležitá je totiž jen cesta a odkaz na cílovou URL. A to je vlastně vše, protože vše ostatní už přirozeně umí dříve napsaný router.\n\nJeště jsem nedávno narazil na zajímavý router, který umožňoval smazat jakoukoliv část cesty a on si jí domyslel a přesměroval. Nekoukal jsem úplně do střev, ale asi tak, že vyhledá přesně znění cesty a když ji nemůže najít, tak položí nějaký LIKE% dotaz ve snaze alespoň ji odhadnout. To už ale považuji za zbytečné a nevyužitelné. Osobně se mi ještě více líbí routy, které jsou na ČSFD. Obsahují totiž přirozený zkracovač adres viz tyto dvě adresy, které jsou stejné:\n\n```\nhttp://www.csfd.cz/film/5911\nhttp://www.csfd.cz/film/5911-tenkrat-na-zapade/\n```\n\nVyzkoušejte [si](http://www.csfd.cz/film/5911) [to](http://www.csfd.cz/film/5911-tenkrat-na-zapade/). První přesměruje na druhou. Bohužel ne všem se čísla v adresách líbí (i když podle mého názoru bezdpůvodně).\n\nAčkoliv budu na routeru dále pracovat, tak k němu zatím nemám v plánu další komentáře. Pokud tedy něco není jasné, teď je ta správná chvíle zeptat se. Jo mimochodem. Předchozí router už není obyčejnou implementací `\\Nette\\Application\\IRouter`, ale dědí od `\\Nette\\Application\\Routers\\RouteList`. Je to z toho důvodu, že se bez toho Kdyby\\Console [nerozjede](https://github.com/Kdyby/Console/blob/master/src/Kdyby/Console/CliRouter.php#L124). Pokud bych tedy nepoužíval tuto knihovnu, tak by to nebyl problém. Samotná quick'n'dirty úprava spočívá v přidání tohoto kódu na začátek match metody:\n\n```php\n/** @var Application\\IRouter $route */\nforeach ($this as $route) {\n    /** @var Application\\Request $applicationRequest */\n    $applicationRequest = $route->match($httpRequest);\n    if ($applicationRequest !== NULL) {\n        return $applicationRequest;\n    }\n}\n```\n\nA to je vše...","frontmatter":"id: 90a00b9f-47cd-4a93-bb59-13a8e1893ab3\ntimestamp: 1436618301000\ntitle: Hierarchický router\nslug: hierarchicky-router"},{"attributes":{"id":"66b21edb-b3c2-426c-a1f4-80b189562720","timestamp":1436098908000,"title":"Dynamické routování URL adres","slug":"dynamicke-routovani-url-adres"},"body":"A když říkám dynamické, tak tím myslím opravdu kompletně. Jinými slovy to znamená, že chceme jakoukoliv cestu za doménou přeložit na jakýkoliv interní požadavek ([Application\\Request](http://api.nette.org/2.3.3/Nette.Application.Request.html)). Kousek routovací tabulky tedy může vypadat následovně:\n\n```\n/\t\t\t\t\t\t=> \tFront:Homepage:default\n/neco.html\t\t\t\t=> \tFront:Page:default\n/neco-jineho-8\t\t\t=> \tFront:Page:default(id=56)\n/neco/treba/takoveho\t=> \tFront:Page:default(id=96)\n/a/b/c/d/e/f \t\t\t=> \tAdmin:Dashboard:new\n...\n```\n\nTím jsem doufám dostatečně přesně nastínil zadání a od toho se odvíjející požadavky na router. V URL může přijít jakákoliv cesta a aplikace ji musí umět správně naroutovat.\n\n# Jak funguje routování v Nette\n\nPokusím se to vysvětlit trošku jinak než je to vysvětlováno jinde. Většinou se totiž dočtete, jak pracovat s [třídou Route](http://api.nette.org/2.3.3/Nette.Application.Routers.Route.html). To je samozřejmě správně, protože takto se routování v Nette aplikacích naprosto běžně dělá. Nicméně pro tento účel mi přijde vhodnější napsat si router vlastní - o něco hloupější, ale pasující na toto zadání lépe. Proto opustíme tuto třídu a budeme se raději zajímat o [IRouter interface](http://api.nette.org/2.3.3/Nette.Application.IRouter.html).\n\nTento interface má dvě metody - `match` a `constructUrl`. Metoda `match` má za úkol přeložit HTTP request na již zmíněný [Application\\Request](http://api.nette.org/2.3.3/Nette.Application.Request.html). Jedná se tedy o překlad ve směru šipky viz zadání. Podívejte se, jak to řeší třída Route, v tomto konkrétním prípadě však bude potřeba pracovat s databází a napsat si jinou logiku. Oproti tomu metoda `constructUrl` má přesně opačný úkol. Překládá příchozí Application request na (absolutní) URL adresu.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/9ab04acb-febc-4901-aaad-5b554f77e529/vystrizek.png)\n\nZatímco Route dokáže tyto překlady sestavit pouze z masky routy a namapovat je na interní odkazy v aplikaci, v tomto případě bude nutná databáze. Po chvíli laborování a asi pěti variantách jsem nakonec udělal ústupek a zvolil tu nejjednodušší (ale dostatečnou) variantu viz obrázek. Stačí si tedy uchovávat cestu, interní odkaz a interní ID. To je vše, co by mělo být potřeba.\n\n# Konkrétní řešení\n\nNechci sem dávat celé zdrojáky (jen útržky), protože je tento článek hlavně o teorii. Proto se podívejte na nějakou jinou již hotovou implementaci IRouteru, třeba na [StaticRouter](https://github.com/nextras/static-router/blob/master/src/StaticRouter.php). Ostatně s dobrým nápadem je samotná implementace jednoduchá. V `match` si stačí podle cesty vytáhnout interní odkaz třeba nějak takto:\n\n```php\n$destination = $this->em->getRepository(Url::class)->findOneBy(['fakePath' => $path]);\nif ($destination === NULL) {\n\t$this->monolog->addError(sprintf('Cannot find route for path %s', $path));\n\treturn NULL;\n}\n```\n\nSamozřejmě je fajn si tu cestu ještě před dotazem nějak upravit, podle toho jak jí máte v databázi. Já je tam mám třeba bez úvodního lomítka. Tato cesta odkazu směrem do aplikace je velmi jednoduchá, protože pouze na základě cesty v URL si natáhnete vše, co je potřeba a už vlastně jen sestavíme Application request:\n\n```php\n$params = $httpRequest->getQuery();\n$params['action'] = $action;\nif ($destination[$internalDestination]) {\n\t$params['id'] = $destination[$internalDestination];\n}\nreturn new Application\\Request(\n\t$presenter,\n\t$httpRequest->getMethod(),\n\t$params,\n\t$httpRequest->getPost(),\n\t$httpRequest->getFiles(),\n\t[Application\\Request::SECURED => $httpRequest->isSecured()]\n);\n```\n\nNedělá se zde nic zvláštního, prostě postavím request a přibalím do něj cílový presenter (ten jsem si vytáhl z databáze), do parametrů je třeba přidat action a volitelně ještě to interní ID. Stanovil jsem si takovou konvenci, že aplikace bude používat interně pouze ID. Proč? Prvně je to velmi jednoduché a neřeším žádné hovadiny. Nepotřebuji něco jako je slug, protože jsou adresy konstruovány jinak. Takové je zadání. No a potom práce s ID je i z hlediska Doctrine [velmi přirozené](http://forum.nette.org/cs/23681-kdyby-doctrine-use-cases-best-practices-a-jak-vam-to-dava-smysl#p159096). Jeden příklad za všechny. Mám aplikaci rozsekanou na komponenty co nejvíce to šlo. Je jich fakt hodně - stránku vlastně jen skládám z komponent. To považuji za skvělý návrh, ale vede k tomu, že se jednolivé komponenty od sebe aplikačně trošku vzdalují. No a když bych chtěl třeba v každé komponentě vytáhnout něco stejného, tak při nevhodném dotazu by Doctrine položila dva stejné dotazy na databázi. Je však možné využít ID a zeptat se jinak. Porovnejte následující dotazy:\n\n```php\n$this->em->getRepository(File::class)->findOneBy(['id' => 930]);\n$this->em->getRepository(File::class)->find(930);\n```\n\nNejsou stejné. Ten druhý můžete použít kolikrát chcete, ale pokud již Doctrine zná odpověď, tak se nezeptá databáze znova. Obdobně (ještě lépe) to funguje s `getPartialReference`. Takže bod pro práci pouze s ID.\n\nJe třeba zajistit i obrácený překlad. Ten mi vždy přijde náročnější a měl jsem vymyšlený fakt pěkný nápad, ale neuměl jsem ho zrealizovat. Ale díky tomu, že se využívá interně jen ID, mohu jej uložit jako třetí sloupec do databáze a je možné jednoduše patřičnou cestu dohledat. Je však třeba uvědomit si, že existují čtyři možné stavy:\n\n1. Odkaz nemá žádné ID, hledáme cestu pouze podle destination (např. Front:Homepage:default - ID je volitelné)\n2. Odkaz má ID, hledáme cestu podle destination a ID\n3. Odkaz sice má ID, ale v databázi takový záznam není, v tom případě použít první bod a parametry pověsit do query odkazu (fallback)\n4. Odkaz se nepodařilo najít ani odhadnout v dalších bodech, routa vrací NULL\n\nProč vrací v posledním bodě routa NULL? Určitě víte, že při definování klasického routeru záleží na pořadí rout. Je to právě kvůli tomuto. Když první routa nedokáže příchozí požadavek sestavit, vrací NULL a na řadě je další routa, která se o to pokusí. Požadavek propadne dále. Tak to jde až do okamžiku, kdy už není žádná jiná možnost a to je chybový stav (404). Vzhledem k tomu, že používám pouze tento vlastní router, tak NULL je ekvivalent právě k chybě 404. Ale napsal jsem si to tak, aby routa byla hodně žravá a pokusila se za každou cenu nějaký odkaz postavit. Třetí bod je navíc stav, který se loguje.\n\nJeště je důležitá poslední věc. Jak jsem psal dříve, tak se v `match` metodě přidává do Application requestu action a volitelně ID. V metodě `constructUrl` je potřeba zvolit opačný přístup a zase je zrušit. Nedostanou se tak do URL. V tom je celé kouzlo takto volně definovaných adres. Na vstupu přidám nějaké informace navíc (action, ID), s nima aplikace pracuje a na výstupu je zase z adresy odstraním.\n\n# Bez cache ani ránu\n\nZatím je to docela fajn. By default mám v databázi nějaké základní odkazy a například při ukládání článku vytvořím odkazy nové, které se pak naroutují. Výhoda je jednak v tom, že mohu mít úplně libovolné adresy. Mohu je ale také různě upravovat podle nastavení a pak co je asi nejdůležitější, adresy jsou unikátní a když ji u článku změním, mohu starou (automaticky) přesměrovat na novou. Po tomto musí SEO odborníci čvachtat blahem... :)\n\nProblém je však v tom, že je to spousta práce a bez nějaké alespoň jednoduché cache by to bylo moc komplikované, skoro až nepoužitelné. Řešení je však jednoduché. Prostě cache použijeme:\n\n```php\n$destination = $this->cache->load($path, function (& $dependencies) use ($path) {\n\t$destination = $this->em->getRepository(Url::class)->findOneBy(['fakePath' => $path]);\n\tif ($destination === NULL) {\n\t\t$this->monolog->addError(sprintf('Cannot find route for path %s', $path));\n\t\treturn NULL;\n\t}\n\treturn [$destination->destination => $destination->internalId];\n});\nif ($destination === NULL) {\n\treturn NULL;\n}\n```\n\nJe to vlastně stejný kód jako v první ukázce, ale výsledek si uloží do cache a příště už ví jaký odkaz použít. Trošku nevýhoda je, že to vygeneruje cache soubůrek pro každý individuální odkaz. Myslím si však, že je to správně, protože skutečně každý odkaz může být úplně jiný. Takže jsem si alespoň pro dobrý pocit vyrobil ještě upravený [FileStorage](http://api.nette.org/2.3.3/Nette.Caching.Storages.FileStorage.html), který cache zanořuje ještě o úroveň níže podle prvních dvou znaků (resp. podle druhého a třetího). No a celá ta sranda se chová tak, že při načtení stránky vyřeší ty dotazy, které je potřeba vyřešit a při dalším načtení již nic nedělá, pouze je přečte z cache. Při průchodu stránkou pouze dochází k řešení dalších - ještě nevyřešených odkazů. Pak to se postupně vyřeší všechny a už se na to nikdy nebude sahat (není to moc žádoucí).\n\n# Pár důležitých poznámek\n\nVzhledem k tomu, že v tomto konkrétním případě chci používat pouze tuto routu, tak je možné všechny ostatní úplně vyhodit pryč. Fakticky stačí z rozšíření vyhodit definici původní nativní routy:\n\n```php\n$containerBuilder->removeDefinition('routing.router');\n```\n\nUdělal jsem to teď, takže to ještě nemám pořádně vyzkoušené a doufám, že jsem tím nic nerozbil. Ale neměl bych. Po zaregistrování této vlastní routy v configu vše začne krásně fungovat. Stačí, že implementuje IRouter a tato implementace je jediná v celém projektu (což je po této úpravě pravda).\n\nNo a na závěr ještě úvaha, kterou jsem sice ještě neimplementoval, ale asi bych to tak rád udělal. Jedná se o jazykové mutace. Jednak je mohu ovlivňovat přidáním nějakého `/en/` do cesty (což se tento router jednoduše naučí), ale pak může přijít složitější požadavek. Máme dvě domény směřující na jednu aplikaci a každá doména představuje jinou jazykovou mutaci. To je docela naprd, ale vzhledem k tomu, že do `match` metody v argumentu vstupuje HTTP request, mohu tuto jazykovou mutaci nastavit pouze na základě adresy zase velmi jednoduše. Jediná modifikace bude v tom, že začnu v Application requestu posílat i locale proměnnou pro translátor.\n\n# Poslední nejdůležitější upozornění\n\nMožná si již někdo všiml, že jsem změnil doménu. Nová doména je `zlml.cz`. Vzhledem k tomu, že původní byla pouze dočasná (i když na několik let) a nepodařilo se mi získat tu co jsem moc chtěl, zvolil jsem tuto. Jak si jí snadno zapamatovat? Je to jednoduché. Prostě moje příjmení bez samohlásek. Původní doména je přesměrována 1:1 a ještě ji budu docela dlouhou dobu držet. Ale až uvidím, že to nemá takový smysl, tak bych jí třeba za pár let zrušil. Pokud tedy chcete mít jistotu, že se k vám vždy nové články dostanou, změňte si prosím ve svých RSS čtečkách adresu na [http://zlml.cz/rss](rss).\n","frontmatter":"id: 66b21edb-b3c2-426c-a1f4-80b189562720\ntimestamp: 1436098908000\ntitle: Dynamické routování URL adres\nslug: dynamicke-routovani-url-adres"},{"attributes":{"id":"425908f8-6a85-43fa-a029-b4615b7635ae","timestamp":1435428633000,"title":"Vzhůru dolů! A pak zase nahoru...","slug":"vzhuru-dolu-a-pak-zase-nahoru"},"body":"Na relativně dlouhou dobu jsem se teď odmlčel. Psal jsem totiž někam jinam než na blog a svůj příděl písmenek na měsíc jsem odevzdával právě tam. Ale stálo to za to. Totiž jak se to vezme. Projděme si sled událostí. Událost první. Poprvé jsem [představil](http://www.slideshare.net/MartinZlmal/nodejs-42314371) svůj projekt na FAV, kde studenty zaujal a na konci přednášky se kolem samotného projektu utvořil hlouček zvědavců toužící prohlédnout si zařízení lépe. Událost druhá. Představil jsem tento projekt [širší veřejnosti](http://www.slideshare.net/MartinZlmal/barcamp2015) na Barcampu v Plzni a získal jsem velkou spoustu negativních reakcí. Samotná zadávající firma se dále přestala o tento projekt více zajímat a musel jsem se s tím chvíli pasovat, abych věděl na čem jsem. Událost třetí. I když mi to chvíli trvalo, tak jsem se vzpamatoval, implementoval jsem ještě několik cool věcí a tento projekt uvedl do finální fáze, kdy bych byl ochoten se s ním pochlubit před odborným publikem. Tak jsem také u SZZ udělal a práci úspěšně obhájil. Událost čtvrtá a poslední. Tato práce [vyhrála soutěž](http://www.abb.cz/cawp/seitp202/67b19426a3ab3b8fc1257e6e004f2d33.aspx) ABB University Award 2015 - soutěž o nejlepší technicky zaměřenou vysokoškolskou práci v ČR.\n\nProč to vůbec říkám? Abych si trošku zamachroval... (-: Ale také proto, abych s lehkým úšklebkem poděkoval všem lidem, díky kterým jsem se chvíli cítil fakt špatně a díky kterým jsem tu práci po Barcampu přihlásil do soutěže. Chtěl jsem vědět, jestli je to fakt taková sračka a bude to jasná tečka za mým snažením, nebo ta práce (resp. myšlenka) má nějaký smysl. A smysl to mělo. Hodnotil se nápad, zpracování a to jak jsem to ústně přednesl (pravděpodobně). Pokud máte čas, tak si tuto práci můžete přečíst. Budu rád pokud tak (alespoň nějak rychle) učiníte a můžeme si o tom popovídat více.\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/q1xdPbSZTIUXQ\" width=\"600\" height=\"750\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nCo celá práce velmi jednoduše řečeno řeší? Jak co nejrychleji dostat data z nějaké elektroniky (koncentrátoru) až do webové aplikace a zpět. K tomu by mělo být (a je) možné změnit zapojení sítě, tzn. jedná se o logickou síť, která není závislá ani na fyzickém zapojení, ani na použitých zařízeních a technologiích. Ve výsledku je to triviální problém, ale ne každý jej dokáže vstřebat, nebo si něco takového vůbec připustit.\n\nCo dál ještě nevím. Uvidím, jestli se to nějaké firmě zalíbí více, než té současné a bude schopna se za to postavit. Pokud ne, tak celý nápad postrádá smysl a vrhnul bych se asi do nějakých myšlenek uvedených ke konci práce, jako je například [Li-Fi](https://en.wikipedia.org/wiki/Li-Fi), nebo částečně decentralizovaný přístup sítě. Jedno vím ale jistě. Na Barcamp už s tím ani nepáchnu... :-))","frontmatter":"id: 425908f8-6a85-43fa-a029-b4615b7635ae\ntimestamp: 1435428633000\ntitle: Vzhůru dolů! A pak zase nahoru...\nslug: vzhuru-dolu-a-pak-zase-nahoru"},{"attributes":{"id":"c8a25638-706f-4849-8965-d4aa66144ffc","timestamp":1432200241000,"title":"Fixněte si databázi","slug":"fixnete-si-databazi"},"body":"Možná to znáte. Již nějaký čas nepoužíváte žádný SQL soubor a strukturu databáze si generujete z entit pomocí Doctrine. Je to super, rychlé a funguje to. Paráda. Jenže málokterá databáze se obejde bez nějakých inicializačních dat. Jenže jak na to?\n\n# První přístup\n\nNebudu ho popisovat moc dlouho, protože ukazuje přesně to, co nechci ukázat. Jendoduše si napíšete nějaké to SQL, které pak nahrnete do databáze. Třeba nějak takto:\n\n```sql\nREPLACE INTO `options` (`key`, `value`)\nVALUES\n('option1', 'value1'),\n('option2', 'value2'),\n('option3', 'value3');\n```\n\nTo jak si to pošlete do databáze je celkem jedno. Jestli ručně, nebo přes PHP. Pořád někde zůstává SQL. Proč mi to vadí? Tak třeba zde na blogu je nějaká instalace. A protože jsem se ještě nedokopal k tomu to přepsat, tak musím mít tyto soubory dva. Jeden pro MySQL a druhý pro PosgreSQL. _(Jo správně, blog jde nainstalovat na více databází...)_ A to je voser.\n\nAle jsou i projekty, kde jsem to udělal rovnou pořádně (i když jsou jen na jedné databázi).\n\n# Lepší přístup pomocí fixtures\n\nZnáte [Doctrine Data Fixtures Extension](https://github.com/doctrine/data-fixtures)? Neznáte? Tak to doporučuji, protože vám pomohou vyřešit přesně tento problém. Lépe tuto knihovnu poznáte pomocí composeru:\n\n```\ncomposer require doctrine/data-fixtures\n```\n\nSamozřejmě je takový nepsaný předpoklad, že používáte Doctrine... :) Co dál? Ještě než se pustím do dalšího vysvětlování, bylo by fajn napsat si nějaký command. Na takový command objekt se nejlépe hodí moje oblíbená knihovna [Kdyby/Console](https://github.com/Kdyby/Console), která integruje [command ze Symfony](http://symfony.com/doc/current/components/console/introduction.html). Už jsem o tom psal něco málo [dříve](kdyby-console). A díky této přehršli odkazů již víte jak na to a můžeme rovnou nějaký psát. A protože jsem líný programátor, tak se podívám jak to vyřešil [někdo jiný](https://github.com/doctrine/DoctrineFixturesBundle/blob/master/Command/LoadDataFixturesDoctrineCommand.php). A trošku si to zjedoduším:\n\n```php\n<?php\n\nuse Doctrine\\Common\\DataFixtures\\Executor\\ORMExecutor;\nuse Doctrine\\Common\\DataFixtures\\Loader;\nuse Doctrine\\Common\\DataFixtures\\Purger\\ORMPurger;\nuse Kdyby\\Doctrine\\EntityManager;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass DefaultData extends Command\n{\n\n\t/** @var EntityManager @inject */\n\tpublic $em;\n\n\tprotected function configure()\n\t{\n\t\t$this\n\t\t\t->setName('orm:demo-data:load')\n\t\t\t->setDescription('Load data fixtures to your database.');\n            //->addOption...\n    }\n    \n    protected function execute(InputInterface $input, OutputInterface $output)\n\t{\n\t\ttry {\n        \t$loader = new Loader();\n\t\t\t$loader->loadFromDirectory(__DIR__ . '/../basic');\n            $fixtures = $loader->getFixtures();\n\n\t\t\t$purger = new ORMPurger($this->em);\n            \n            $executor = new ORMExecutor($this->em, $purger);\n\t\t\t$executor->setLogger(function ($message) use ($output) {\n\t\t\t\t$output->writeln(sprintf('  <comment>></comment> <info>%s</info>', $message));\n\t\t\t});\n\t\t\t$executor->execute($fixtures);\n\t\t\treturn 0; // zero return code means everything is ok\n        } catch (\\Exception $exc) {\n\t\t\t$output->writeLn(\"<error>{$exc->getMessage()}</error>\");\n\t\t\treturn 1; // non-zero return code means error\n\t\t}\n\t}\n}\n```\n\nOk, to jsem to možná ořezal více než je třeba. Mrkněte na tu ukázku pro Symfony, bude to velmi podobné. A teď už konečně k samotným fixture objektům. To jsou ty co načítám ze složky basic pomocí `loadFromDirectory`. Jedná o objekty, které implementují interface `FixtureInterface`, nebo možná lépe dědí od abstraktní třídy `AbstractFixture`. Obojí je v `Doctrine\\Common\\DataFixtures` namespace. Objekt obsahující defaultní uživatele může vypadat takto:\n\n```php\n<?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\nuse Nette\\Security\\Passwords;\n\nclass UsersFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n\tpublic function load(ObjectManager $manager)\n\t{\n\t\t$admin = new \\Users\\User('admin@nette.org');\n\t\t$admin->setPassword(Passwords::hash('admin'));\n\t\t$admin->addRole($this->getReference('admin-role'));\n\t\t$manager->persist($admin);\n\n\t\t$demo = new \\Users\\User('demo@nette.org');\n\t\t$demo->setPassword(Passwords::hash('demo'));\n\t\t$demo->addRole($this->getReference('demo-role'));\n\t\t$manager->persist($demo);\n\n\t\t$manager->flush();\n\n\t\t$this->addReference('admin-user', $admin);\n\t\t$this->addReference('demo-user', $demo);\n\t}\n\n}\n```\n\nV čem je to tak parádní? Používám PHP kód, používám vlastní nadefinované entity. Hned vidím, že mi to fugnuje, ověřuji svůj návrh databáze a rovnou poskytuji dalším ukázku toho, jak jsem to myslel. Za povšimnutí stojí funkce `addReference` a `getReference`. Je jasné, že v každé relační databázi budou nějaké relace a právě k tomu tyto funkce slouží. Vytvořím si tedy nějaké ukazatele a ty pak mohu použít v jiné části demo dat. Lépe to  bude vidět na druhé tabulce:\n\n```php\n<?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nclass RolesFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n\tpublic function load(ObjectManager $manager)\n\t{\n\t\t$user = new \\Users\\Role();\n\t\t$user->setName(\\Users\\Role::DEMO_USER);\n\t\t$manager->persist($user);\n\n\t\t$admin = new \\Users\\Role();\n\t\t$admin->setName(\\Users\\Role::ADMIN);\n\t\t$manager->persist($admin);\n\n\t\t$manager->flush();\n\n\t\t$this->addReference('demo-role', $user);\n\t\t$this->addReference('admin-role', $admin);\n\t}\n\n}\n```\n\nVidíte? Mám role, vytvořím si na ně odkaz a používám je při definici uživatele. Vyzkoušejte si to. Uvidíte, jak se krásně naplní referenční tabulky a vše bude tak, jak to má být...\n\nJen pozor na jedno věc. Ohlídejte si [pořadí těchto objektů](https://github.com/doctrine/data-fixtures#fixture-ordering). To lze vyřešit implementací rozhraní `OrderedFixtureInterface`, nebo `DependentFixtureInterface`, což je o něco lepší přístup.\n\nA jak toto celé použít? Však už to znáte:\n\n```\nλ php index.php\nλ php index.php orm:schema-tool:create\nλ php index.php orm:demo-data:load\n```\n\nPrvní příkaz vám nabídne všechny dostupné příkazy, druhý vygeneruje strukturu databáze bez dat a poslední spustí natažení demo dat. Pak už se jen kocháte:\n\n```\nλ php index.php orm:demo-data:load --demo\nCareful, database will be purged. Do you want to continue Y/N ? y\n  > purging database\n  > loading RolesFixture\n  > loading UsersFixture\n  > loading ArticlesFixture\n  > loading ProductsFixture\n  ...\n```","frontmatter":"id: c8a25638-706f-4849-8965-d4aa66144ffc\ntimestamp: 1432200241000\ntitle: Fixněte si databázi\nslug: fixnete-si-databazi"},{"attributes":{"id":"c7509237-b0ee-42d7-95e6-5dba3e937a4c","timestamp":1430044733000,"title":"Doctrine pro non-doctrine programátory","slug":"doctrine-pro-non-doctrine-programatory"},"body":"A také o tom proč jsem se ptal kdo studoval, studuje, nebo bude studovat elektrotechnickou fakultu a proč jsem si až pak uvědomil, že jsem se vlastně zeptal úplně blbě.\n\nAle napřed k samotné přednášce. Nemá smysl zde psát dlouhosáhlé slohy o tom co jsem říkal, počkejte si na video. Pár slov si však neodpustím. Myslím si, že jsem málo zdůraznil to, aby si každý koho to alespoň trošku zajímá Doctrine vyzkoušel. Ale ne jen tak si něco uložit a přečíst z databáze. Já jsem si například přepsal tento blog. Kompletně. Udělejte něco podobného. Teprve potom se ukáže jaké jsou výhody/nevýhody a hlavně - teprve teď se můžete rozhodnout co vám více sedí, protože už máte vyřešené nějaké konkrétní problémy, ne jen modelové situace. Výměnou za hvězdičku se můžete inspirovat například [zde](https://github.com/mrtnzlml/zlml.cz).\n\nA co když si nevíte rady? To nevadí. Stává se to často, proto existuje spoustu míst kde se ptát. Jedno je samozřejmě zde. Existuje však [Nette fórum](http://forum.nette.org/cs/) a pak (a to hlavně) [Kdyby HELP fórum](https://help.kdyby.org/). Na všech místech vám určitě někdo poradí.\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/key/79L3O5KfQJxyOc\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nJeště než prozradím jak je to s tou FEL, rád bych ještě jednou poděkoval lidem z [ANT studia](http://www.antstudio.cz/), protože bez nich bych si PoSobotu nemohl tolik užít a nemohl bych zajít na afterpivo - i když jen nealkoholické. Těší mě to i z toho důvodu, že právě s [ANT studiem](http://www.antstudio.cz/) začínám, po vyřešení všech studijních formalit, spolupracovat na zajímavých projektech v Nette... (-:\n\nA teď už konečně k oné nešťastné otázce. Správně měla znít:\n\n> Kdo studoval, studuje, nebo bude studovat nějakou **neprogramátorskou** školu?\n\nBylo totiž krátkozraké omezit se jen na elektro, ale tam to vše vzniklo a už jsem to neřešil dál. Upozornil mě na to až [@stekycz](https://twitter.com/stekycz). A proč jsem se na to ptal? Inu nastal čas kdy jsem se potřeboval posunout někam dál a začal jsem obcházet firmy v Plzni. Měl jsem tak příležitost potkat spoustu zajímavých lidí a skutečně si vybrat něco co by mě mohlo bavit. A při tomto kolečku mě zaujal často se opakující rozhovor:\n\n> Takže vy studuje asi FAV, že?\n>\n> Ne, FEL.\n>\n> Aha, to my také...\n\nA bylo to častější, než bych si byl kdy býval pomyslel. Došel jsem pak s kolegou k jednoduchému závěru. Zřejmě všichni kdo programují dobrovolně, tedy všichni které do programování nepřinutí škola, jsou prostě dobří. Mají obrovskou naději na uchycení se. Viděl jsem to i z pozice kdy jsem dělal pohovory s lidma. Je skutečně obrovský rozdíl potkat borce z FAV a programátora z FEL nebo odkudkoliv kde programování zase až tak nefrčí.\n\nA naposledy ještě jednou velké díky [@chemix_cz](https://twitter.com/chemix_cz)! Odvádíš neuvěřitelnou práci.","frontmatter":"id: c7509237-b0ee-42d7-95e6-5dba3e937a4c\ntimestamp: 1430044733000\ntitle: Doctrine pro non-doctrine programátory\nslug: doctrine-pro-non-doctrine-programatory"},{"attributes":{"id":"47afe102-bda4-448a-895e-fb948bdd9206","timestamp":1427631321000,"title":"Barák budoucnosti","slug":"barak-budoucnosti"},"body":"Aneb jak jsem poprvé a naposledy přešlápl. Je to jednoduché, nebudeme si nic nalhávat. Ještě jsem nepochopil smysl Barcampu. A tak se stalo, že jsem si připravil povídání o něčem, co nikdo moc nechápal. Jistě že mě to trošku mrzí, zároveň mi však přijde absurdní, že někdo přijde na přednášku, kde jsem upozorňoval v anotaci na použité technologie, které budou ve vyprávění zahrnuty a pak jsem slyšel, že někdo vůbec nevěděl o čem je řeč. To je ale kapitola sama pro sebe... (-:\n\nPoučím se a děkuji za feedback. Bylo to tak půl na půl. Půl lidí mi opakovala vlastně jednu a tu samou věc. Že to bylo moc složité. Že bylo potřeba znát hodně věcí okolo, aby se mohl člověk chytat. To je jeden z důvodů, proč už si nikdy nevezmu takovou přednášku na akci jako je Barcamp. Spektrum posluchačů totiž bylo extrémní. Od lidí úplně mimo mísu až po lidi, kteří této problematice perfektně rozumí (lépe než já). Proto jsem rád i za druhou polovinu feedbacku. Potkal jsem se totiž zhruba se stejným počtem lidí, ale s obráceným postojem, takže jsem měl prostor některé věci ještě dovysvětlit a vyjasnit. Bylo fakt super, když mě někdo zastavil na chodbě a chtěl vědět jak je technicky možné pořešit některé věci o kterých jsem mluvil, nebo si chtěl povídat o tom, jak jsou ty koncentrátory vlastně implementované a jak to funguje podrobněji, **že se mu to líbí!**\n\nZjednodušeně - nejsem spokojený se svým výstupem, ale jsem rád, že jsem mohl potkat několik inspirativních lidí a dobře si popovídat. Díky. Nebudu to zde více rozpatlávat. Podívejte se na prezentaci... (-:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/46412746\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nPřikládám ještě odkazy na zmiňovaný [referenční manuál](http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf) od mikrokontrolérů a dokument pojednávající o myšlence Fog Computingu: [Fog Computing and Its Role in the Internet of Things](http://conferences.sigcomm.org/sigcomm/2012/paper/mcc/p13.pdf).\n\n# A co ostatní přednášky?\n\nNo tak všechny skvělé. Já si vážím toho, když někdo vystoupí a ukáže co dělá a je z toho nadšený. Některé přednášky jsem tedy jen proseděl a nic nového jsem se moc nedozvěděl (a to právě nevím, jestli mám od Barcampů čekat). Ne všechny přednášky pro mě mají takovou informační hodnotu. Ale lidem se to líbí, takže za mě dobré.\n\nSoučástí Barcampu byl i [Arduino Day 2015](https://day.arduino.cc/#/). Tam jsem byl pouze na přednášce o Superkondenzátorech. Kamarád z toho byl úplně nadšený. Pokud vás zajímá elektronika a nejlépe ještě rádi bastlíte, tak doporučuji vyhledat si záznam. Já osobně považuji za nejlepší přednášky [8 a půl roku přednášení pro Microsoft](https://plzenskybarcamp.cz/2015/prednasky/5cd9cd30) a [Od zadání k release za dva dny: jak se programuje v novinách](https://plzenskybarcamp.cz/2015/prednasky/8eba3b56) aneb jak se hledá balanc mezi náprasem a perfektním kódem... (-:\n\nA když opomenu přednášky? No tak Afterparty byla super. I zde jsem měl příležitost prohodit pár zajímavých rozhovorů. Nakonec se to trošku protáhlo a do postele jsem ulehal až v 6 ráno. Ale s hezkým pocitem, že nedělám úplné hovadiny, jen se musím naučit své myšlenky lidem lépe prodat...","frontmatter":"id: 47afe102-bda4-448a-895e-fb948bdd9206\ntimestamp: 1427631321000\ntitle: Barák budoucnosti\nslug: barak-budoucnosti"},{"attributes":{"id":"55c2f8a2-9b13-46e2-b919-128c0c95a40d","timestamp":1427231722000,"title":"Generované továrničky - definitive guide","slug":"generovane-tovarnicky-definitive-guide"},"body":"No dobře, možná ne úplně definitivní, ale užitečná příručka snad. Pokusím se zde rozebrat všechny potřebné stavy generovaných továrniček, které považuji za důležité a jejich co nejjednodušší zápis v configu. Jedná se hlavně o pohled z hlediska předávání parametrů. Doufám, že to ještě někdo doplní o nějaké vylepšení, nebo další příklad, abych mohl tento seznam rozšířit. To je jeden ze dvou důvodů tohoto typu článků. Ten druhý je, abych měl kam odkazovat, až se mě někdo bude opět ptát.\n\nCelkem rozebírám tyto jednotlivé případy:\n- [Předání parametru z presenteru](#toc-predani-parametru-z-presenteru)\n- [Předání parametru z konfiguračního souboru](#toc-predani-parametru-z-konfiguracniho-souboru)\n  - Metodou \"create\"\n  - Metodou \"arguments\"\n- [All in One](#toc-all-in-one)\n\n# Předání parametru z presenteru\n\nToto považuji za asi úplně nejčastější požadavek. Komponenta je jednoduchá:\n\n```php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n\tpublic function __construct(array $xxx) {}\n}\n\ninterface IParameterComponentFactory {\n\n\t/** @return ParameterComponent */\n\tfunction create(array $xxx);\n\n}\n```\n\nDůležité je, že jak datový typ, tak název proměnné se musí shodovat. Config pak není o nic složitější:\n\n```neon\nservices:\n\t- IParameterComponentFactory\n```\n\nKontejner se potom vygeneruje dle očekávání:\n\n```php\nfinal class Container_59ca411ae5_IParameterComponentFactoryImpl_28_IParameterComponentFactory implements IParameterComponentFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Container_59ca411ae5 $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create(array $xxx) {\n\t\t$service = new ParameterComponent($xxx);\n\t\treturn $service;\n\t}\n\n}\n```\n\nSamotné použití je velmi jednoduché. Stačí si nechat v presenteru předat interface `IParameterComponentFactory` například pomocí anotace `@inject` a nad ním volat metodu `create`. Fígl je právě v tom, že vygenerovaný kód v kontejneru tento interface implementuje a odvádí tak zbytečnou práci za vás. Bez dalších změn lze využít autowire zaregistrovaných služeb. Předání parametru z configu a zároveň získání další závislosti pak může vypadat třeba takto (pouze upravená předchozí komponenta):\n\n```php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n\tpublic function __construct(array $xxx, App\\Model\\UserManager $userManager) {}\n}\n```\n\n# Předání parametru z konfiguračního souboru\n\nToto je trošku horší, ale pořád snadno pochopitelné. Kód komponenty bude opět podobný:\n\n```php\n<?php\n\nclass ConfigComponent extends Nette\\Application\\UI\\Control {\n\tpublic function __construct($configParam) {}\n}\n\ninterface IConfigComponentFactory {\n\tfunction create();\n}\n```\n\nVšimněte si, že je v tomto případě úplně zbytečná `@return` anotace. Co má factory vytvářet lze totiž specifikovat v configu:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\nservices:\n\t- implement: IConfigComponentFactory\n\t  create: ConfigComponent(%testkey1%)\n```\n\nZde by skoro šlo přestat interface úplně psát. To ale není v současné době možné a vygenerovaný kód je pak přesně takový, jaký by měl být:\n\n```php\nfinal class Container_59ca411ae5_IConfigComponentFactoryImpl_33 implements IConfigComponentFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Container_59ca411ae5 $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create() {\n\t\t$service = new ConfigComponent('testvalue1');\n\t\treturn $service;\n\t}\n\n}\n```\n\nAlternativně lze zvolit populárnější způsob a upravit konfigurační soubor takto:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\nservices:\n\t- implement: IConfigComponentFactory\n\t  arguments: [%testkey1%]\n```\n\nVygenerovaný výsledek je stejný. V tomto případě je však nutné dát pozor na to, že při psaní interface je nutné psát jej i s `@return` anotací.\n\nOk, toto je snad jasné. Co to trošku zkomplikovat?\n\n# All in One\n\nToto snad bude dostatečně krajní případ. Pokusíme se vytvořit továrničku pro komponentu, která bude ke svému vytvoření vyžadovat parametr z configu, parametr z presenteru, službu a opět parametr z configu - vše přesně v tomto pořadí. A nebudu se v tom snažit hledat závislosti. Je vyžadováno něco takového:\n\n```php\n<?php\n\nclass AllInComponent extends Nette\\Application\\UI\\Control {\n\n\tpublic function __construct($configParam1, array $userParam, App\\Model\\UserManager $userManager, $configParam2) {}\n\n}\n\ninterface IAllInComponentFactory {\n\n\t/** @return AllInComponent */\n\tfunction create(array $userParam);\n\n}\n```\n\nJe tedy jasné, že musím vytvořit `create` metodu s parametrem, který naplním v presenteru. Zde by opět `@return` anotace nemusela být. Je úplně zbytečná. A jak na ty parametry z configu? To už je přece vyřešené viz dřívější ukázky:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\ttestkey2: testvalue2\n\nservices:\n\t- implement: IAllInComponentFactory\n\t  create: AllInComponent(configParam2: %testkey2%, configParam1: %testkey1%)\n```\n\nZde jsem si to ještě zkomplikoval tím, že jsem zadal parametry v obráceném pořadí (což by přesně takto fungovalo). Abych docílil správného pořadí, musím parametry správně pojmenovat (shodně s konstruktorem komponenty). A vygenerovaný kód? Radost pohledět:\n\n```php\nfinal class Container_59ca411ae5_IAllInComponentFactoryImpl_32 implements IAllInComponentFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Container_59ca411ae5 $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create(array $userParam) {\n\t\t$service = new AllInComponent('testvalue1', $userParam, $this->container->getService('27_App_Model_UserManager'), 'testvalue2');\n\t\treturn $service;\n\t}\n\n}\n```\n\nI v tomto případě je možné zvolit jiný (úspornější) zápis v konfiguračním souboru. Vygenerovaný výstup je opět stejný:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\ttestkey2: testvalue2\n\nservices:\n\t- implement: IAllInComponentFactory\n\t  arguments: [configParam2: %testkey2%, configParam1: %testkey1%]\n```\n\nTeď mě nenapadá, jestli je někdy (běžně) potřeba ještě něco složitějšího. Toto jsou však dva základní přístupy zkombinované do jedné ukázky. Podívejte se na všechny tyto [příklady podrobněji na GitHubu](https://github.com/mrtnzlml/generated-factories).","frontmatter":"id: 55c2f8a2-9b13-46e2-b919-128c0c95a40d\ntimestamp: 1427231722000\ntitle: Generované továrničky - definitive guide\nslug: generovane-tovarnicky-definitive-guide"},{"attributes":{"id":"700bba3f-043d-4d84-b62f-7436e189f808","timestamp":1420324989000,"title":"Dva příklady toho, proč není JS připravený","slug":"dva-priklady-toho-proc-neni-js-pripraveny"},"body":"Tento článek nastartoval jeden hloupý tweet. Měl jsem jej na \"to do\" listu již nějaký čas, ale čekal jsem až to někdo tweetne... (-:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/MartinSadovy\">@MartinSadovy</a> Možná ale to není podstatné. Podstatné je, že JS běží v prohlížeči i na serveru. Isomorphism ftw. PHP je evoluční mrtvola.</p>&mdash; Daniel Steigerwald (@steida) <a href=\"https://twitter.com/steida/status/551431843560824832\">January 3, 2015</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nNebudu řešit jak je hloupý. Neznám totiž žádnou objektivní stupnici kam bych jej mohl zařadit. Pomůže mi však oprášit pár věcí, které mě štvou a třeba se ukáže, že to dělám úplně špatně. Poslední dobou totiž kopu za [Node.js](http://nodejs.org/) (potažmo [Express.js](http://expressjs.com/)), C i [Nette](http://nette.org/) tábor. Vše v jednom projektu. Nicméně jsem odkojen na Nette a tak některé věci řeším v jiném frameworku téměř až se slzou v oku.\n\nRád bych upozornil na to, že nejsem žádný superprogramátor, takže je skutečně možné, že k problému přistupuji špatně. Proto bych byl rád za rozumné podněty a připomínky, nikoliv osobní výstřednosti v komentářích...\n\n# 1. Odkazy\n\nA hned pěkně z ostra. Jak jsem již zmínil, jsem odkojen na Nette a proto jsem náležitě rozmazlen. Ale rozmazlen v dobrém slova smyslu. Považuji totiž framework za věc, která mi má pomoci. Nikoliv házet klacky pod nohy. Jednou z takových věcí je tvorba odkazů. Jak by to mělo být správně? Přesně tak jak je to v Nette, čili je zapotřebí najký systém, který mi umožní stavět odkazy a zároveň mi umožní je kdykoliv změnit bez zásahu do šablon. Jak je tomu v takovém Exresss.js, webovém frameworku pro Node.js? V Express.js je defaultně šablonovací systém [Jade](http://jade-lang.com/). Nemluvě o tom, jaký je to nešťastný systém, odkazy se v něm vytvářejí zhruba takto:\n\n```html\na(href='/') Home\na(href='/about') About\n```\n\nUž asi tušíte kam mířím a proč je to podle mého soudu fatální. Takový hard-code odkazů je totiž perfektně pomalá cesta do blázince. Ve skutečnosti je však mnohem větší anekdota označování aktivních odkazů. Podívejte se na [6 WTF rad](http://stackoverflow.com/questions/10713923/node-js-jade-express-how-can-i-create-a-navigation-that-will-set-class-acti), jak tento triviální problém vyřešit. Celý princip spočívá v tom použít hard-code odkazů na více místech v šabloně:\n\n```html\nul.nav.navbar-nav\n\tli(class=path == '/' ? 'active' : undefined)\n\t\ta(href='/') Home\n\tli(class=path == '/about' ? 'active' : undefined)\n\t\ta(href='/about') About\n```\n\nKde se bere `path`? Ten si musíte předat v routeru, např.:\n\n```js\nrouter.get('/', function (req, res) {\n\tres.render('homepage', {\n\t\tpath: '/'\n\t});\n});\n```\n\nTak to máme celkem 4 místa kde je to pěkně natvrďáka. Proč ne? **Proč jo?** Jistě, existuje možnost jak si to naprogramovat lépe, jinak, znova. Jen si říkám, kde se stala chyba a proč to framework nezvládá nějak lépe?\n\n# 2. Formuláře\n\nJedna z věcí, která se v tomto světě řeší poněkud laxně jsou formuláře. Na to nejsem zvyklý a trošku mě to děsí. Funguje to zhruba tak, že vytvoříte v šabloně formulář:\n\n```html\nform(id='save-form', method='POST', action='/save')\n\t.form-group\n\t\tlabel(for='xxx') XXX\n\t\tinput(type='text', name='xxx', class='form-control', id='xxx', placeholder='xxx', required)\n\t.form-group\n\t\tbutton.btn.btn-default Odeslat\n```\n\nA následně se napíše router pro zpracování dat:\n\n```js\nrouter.post('/save', function (req, res) {\n\tconsole.log(req.body.xxx); // <<< !\n\tres.render('save', {\n\t\tpath: '/save'\n\t});\n});\n```\n\nJistě, je to jednoduché. Ale to prostě [není ok](http://stackoverflow.com/questions/19030220/is-it-ok-to-work-directly-on-the-data-in-req-body). Kromě toho, že je v kódu opět hard-code, tak se jedná o nádherně \"ošetřený\" vstup. Takový krásně čistý `$_POST`. Takto si framework nepředstauji. Možná je to proto, že je Express.js ještě moc low-level, možná také proto, že ještě neuzrál.\n\n# Není to tak zlé\n\nMusím však utlumit některé pobouřené čtenáře. Nebylo by totiž fér jen něco hejtovat. Bez Node.js bych danou aplikaci naprogramoval jen velmi těžko. Je totiž super, že mohu využít \"event-driven, non-blocking I/O model\". Toto je však věc, kterou podle mého názoru moc lidí nevyužije, protože jí prostě nepotřebuje. Kolikrát něco takového programujete? Proto když jsem měl na téma Node.js [přednášku](prednaska-na-zcu-node-js), jen velmi těžko jsem lidem vysvětloval k čemu je to vlastně dobré. A právě proto jsem použití Node.js paradoxně neukazoval na webové aplikaci. Třeba proto, že se s ním nepracuje úplně nejlépe, zároveň je však v určitých směrech nenahraditelný.\n\nAčkoliv jsem tedy začínal jedním hloupým tweetem, není toto rekace na něj a je mi celkem hluboce ukradený. Spíše mě zajímá jestli to co jsem zde popisoval (a celá řada dalších problémů) je normální všední den server-side JS programátora, nebo se s těmito problémy vypořádáváte jinak?\n\nEvoluční mrtvola FTW!","frontmatter":"id: 700bba3f-043d-4d84-b62f-7436e189f808\ntimestamp: 1420324989000\ntitle: Dva příklady toho, proč není JS připravený\nslug: dva-priklady-toho-proc-neni-js-pripraveny"},{"attributes":{"id":"3d718b54-4cf2-40dd-8d54-fe865a3655d1","timestamp":1419375234000,"title":"RESP protokol - přímý přístup k Redis databázi","slug":"resp-protokol-primy-pristup-k-redis-databazi"},"body":"![](*RESP*)(http://redis.io/topics/protocol) (**RE**dis **S**erialization **P**rotocol) je něco, s čím se asi většina lidí nepotká. Důvod je prostý. Tento protokol je většinou zabalen hluboko v knihovně, která pracuje s Redis databází. Existují však situace, kdy se tento protokol hodí. Jednou ze situací je stav, kdy potřebujete předat, nebo naopak získat z Redisu nějaká data a všechno ostatní vyjma RESP komunikace je zbytečné zdržování (u mě třeba sypání dat z procesoru přímo do Redisu). Druhý případ nastane v okamžiku, kdy potřebujete zajistit komunikaci klient-server a potřebujete zvolit vhodný formát přenosu informací. Jedná se tedy o použití tohoto protokolu úplně mimo Redis. Důvodů může být celá řada, nejhlavnější by však byl asi ten, že se s RESP formátem dat dá snadno pracovat, protože používá prefixový zápis.\n\n# Formát RESP protokolu\n\nRESP používá celkem 5 způsobů jak zaobalit přenášenou informaci. Vždy však platí, že první byte je byte určující o jaký formát se jedná:\n\n- `+` jednoduchý string\n- `-` error\n- `:` integer\n- `$` bulk string (binary safe)\n- `*` array\n\nNásleduje samotný obsah, nebo dodatečné informace, například o délce a vše je ukončeno pomocí CRLF (`\\r\n`). Postupně tedy přenášené informace moho vypadat například takto:\n\n- `+PONG\\r\n`\n- `-Error 123\\r\n`\n- `:54986\\r\n`\n- `$4\\r\nPING\\r\n` (první část určuje délku bulk stringu, NULL je pak `$-1\\r\n`)\n- `*2\\r\n$3\\r\nGET\\r\n$3\\r\nkey\\r\n` (první je délka pole, následuje kombinace předchozích)\n\nTo je celé, žádná věda v tom není. Je to skutečně jednoduchý protokol a to je super, protože se s ním dá snadno pracovat. Navíc lze poslat celý dlouhý text obsahující více příkazů v jednom spojení.\n\n# Implementace v Node.js\n\nV Node.js by teď měla být realizace velmi jednoduchá. Napíšeme si krátký TCP client, který se nám napojí na Redis databázi (většinou port 6379) a budeme posílat/přijímat data:\n\n```javascript\nvar net = require('net');\n\nvar client = net.connect({port: 6379}, function() {\n\tconsole.log('Connected to the Redis server.');\n\n\tclient.write('*1\\r\n$4\\r\nPING\\r\n');\n\tclient.write('*3\\r\n$3\\r\nSET\\r\n$3\\r\nkey\\r\n$5\\r\nxxxxx\\r\n');\n\tclient.write('*2\\r\n$3\\r\nGET\\r\n$3\\r\nkey\\r\n');\n\tclient.write('*5\\r\n$5\\r\nPFADD\\r\n$11\\r\nHyperLogLog\\r\n$3\\r\nxxx\\r\n$3\\r\nyyy\\r\n$3\\r\nzzz\\r\n');\n\tclient.write('*2\\r\n$7\\r\nPFCOUNT\\r\n$11\\r\nHyperLogLog\\r\n');\n\n\tclient.write('*1\\r\n$7\\r\nFLUSHDB\\r\n');\n});\n\nclient.on('data', function(data) {\n\tconsole.log(data.toString());\n\tclient.end();\n});\n\nclient.on('end', function() {\n\tconsole.log('Disconnected from the Redis server.');\n});\n```\n\n<span style=\"color:green\">Ještě jednu poznámku, kterou jsem do původního článku nezahrnul. Proč jsou udesílaná data zabalena v RESP poli? Vychází to z toho, že podle dokumentace, by klient měl posílat na server pole bulk stringů. Nicméně dobře funkční a validní zápis je i bez pole (`client.write('GET key\\r\n');`) jen musí být opět ukončen pomocí CRLF.</span>\n\nOdesíláme do Redis databáze celkem 6 příkazů. První je obyčejný `PING`, následuje `SET` a `GET` klíče, `PFADD` a `PFCOUNT` z HyperLogLog datového dypu a nakonec jen smazání databáze. Co bude výstupem?\n\n```\n+PONG\n+OK\n$5\nxxxxx\n:0\n:3\n+OK\n```\n\nJak je možné, že server vrátil 7 odpovědí? Je to prosté, upravíme si datový callback ať je zřejmé, co skutečně dostáváme za data:\n\n```javascript\nclient.on('data', function(data) {\n\tconsole.log(JSON.stringify(data.toString()));\n\tclient.end();\n});\n```\n\nTeď už bude výstup o něco jiný:\n\n```\n\"+PONG\\r\n+OK\\r\n$5\\r\nxxxxx\\r\n:0\\r\n:3\\r\n+OK\\r\n\"\n```\n\nA vše již dává smysl. První odpověď je `PONG` (na `PING`), následuje reakce `OK` na nastavení klíče, odpověď ve formě bulk stringu, který má dvě části - délku a samotnou textovou odpověď (proto to odřádkování navíc), následuje odpověď z `PFADD` (0 nebo 1 podle situace) a také odpověď z `PFCOUNT` (mohutnost množiny v HyperLogLog). Poslední `OK` je reakce na `FLUSHDB`. Jak je vidět, tak i v odpovědi je prvním znakem formát dat dané odpovědi.\n\nTakto jsem to celkem zbytečně (ale pro přehlednost) rozepisoval. Celá komunikace směrem k serveru by se dala napsat do jednoho požadavku:\n\n```\n*1\\r\n$4\\r\nPING\\r\n*3\\r\n$3\\r\nSET\\r\n$3\\r\nkey\\r\n$5\\r\nxxxxx\\r\n*2\\r\n$3\\r\nGET\\r\n$3\\r\nkey\\r\n*5\\r\n$5\\r\nPFADD\\r\n$11\\r\nHyperLogLog\\r\n$3\\r\nxxx\\r\n$3\\r\nyyy\\r\n$3\\r\nzzz\\r\n*2\\r\n$7\\r\nPFCOUNT\\r\n$11\\r\nHyperLogLog\\r\n*1\\r\n$7\\r\nFLUSHDB\\r\n\n```\n\nOdpověď by zůstala stejná.","frontmatter":"id: 3d718b54-4cf2-40dd-8d54-fe865a3655d1\ntimestamp: 1419375234000\ntitle: RESP protokol - přímý přístup k Redis databázi\nslug: resp-protokol-primy-pristup-k-redis-databazi"},{"attributes":{"id":"45d3a9a8-d3e9-482c-b582-4dc3773de0c2","timestamp":1418241190000,"title":"Poslední přednáška na FAV - Nette","slug":"posledni-prednaska-na-fav-nette"},"body":"Tak a je to... (-:\n\nZveřejňuji mojí poslední přednášku v tomto roce, kterou jsem měl na ZČU na fakultě aplikovaných věd pro studenty předmětu KIV/WEB. Tentokrát jsem si pohrál trošku se zvukem, takže by to oproti [minulému týdnu](prednaska-na-zcu-node-js) mělo být o mnoho lepší.\n\nTématem této přednášky byl můj oblíbený Nette Framework, konkrétně ve verzi 2.3-dev. Cílem bylo seznámit studenty se základní myšlenkou MVC/P a rychle nastínit o co vlastně v Nette jde a  jak se v něm staví jednoduché aplikace. Přednáška nakonec utekla rychleji než jsem čekal a nemohl jsem ukázat vše, proto jsem připravil repozitář na [GitHubu](https://github.com/mrtnzlml/kivweb-nette-fcbk) ze kterého by mělo být vše jasné (pokud není, můžete se ještě dodatečně ptát).\n\nKonec písmenek, podívejte se sami:\n\n<iframe width=\"640\" height=\"360\" src=\"//www.youtube.com/embed/GdATlrmoPRM\" frameborder=\"0\" allowfullscreen></iframe>\n\nA samozřejmě nesmí chybět samotná prezentace:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42574181\" width=\"752\" height=\"462\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nOpět také děkuji [Honzovi *chemix* Černému](http://honzacerny.com/) za zapůjčení kamery.","frontmatter":"id: 45d3a9a8-d3e9-482c-b582-4dc3773de0c2\ntimestamp: 1418241190000\ntitle: Poslední přednáška na FAV - Nette\nslug: posledni-prednaska-na-fav-nette"},{"attributes":{"id":"5ed9400f-ee4e-4a62-b563-1cf97565ac87","timestamp":1417636504000,"title":"Přednáška na ZČU - Node.js","slug":"prednaska-na-zcu-node-js"},"body":"Jak jsem slíbil, tak zveřejňuji přenášku na téma **Node.js**, kterou jsem měl dnes na Západočeské univerzitě pro lidi studující předmět **KIV/WEB**, tedy Webové aplikace. Tato přednáška volně navazuje na předchozí obsah tohoto předmětu. Studenti se pozvolna seznamují s webovým prostředím od úplně základní práce s HTML a CSS až k pokročilým webovým frameworkům. Podívejte se na záznam této přednášky:\n\n<iframe width=\"640\" height=\"360\" src=\"//www.youtube.com/embed/eakg5THIbcI\" frameborder=\"0\" allowfullscreen></iframe>\n\nA prohlédněte si také připravenou prezentaci:\n\n<iframe src=\"//www.slideshare.net/slideshow/embed_code/42314371\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nRád bych také poděkoval [Honzovi *chemix* Černému](http://honzacerny.com/) za zapůjčení kamery.\n\nA příště? Příště se podíváme na skvělý PHP framework [Nette](http://nette.org/)! Tak doufám, že opět dorazíte... (-:","frontmatter":"id: 5ed9400f-ee4e-4a62-b563-1cf97565ac87\ntimestamp: 1417636504000\ntitle: Přednáška na ZČU - Node.js\nslug: prednaska-na-zcu-node-js"},{"attributes":{"id":"3979a0f0-f8ed-45c3-8311-d48e563a49b1","timestamp":1416264254000,"title":"Nadvláda inteligentních procesorů","slug":"nadvlada-inteligentnich-procesoru"},"body":"Pár dní zpátky jsem tweetoval o tom, nad čím právě teď trávím asi nejvíce času. Cílem celého mého snažení je dostat data z procesoru, který obsluhuje různé periferie na základní desce až do webového prohlížeče a zpět - vše v reálném čase. Právě dnes jsem dosáhl prvního milníku, tedy dostal jsem nějaká skutečně smysluplná data do prohlížeče a rád bych zde nastínil jak jsem postupoval a jaké technologie jsem volil. Již dříve se totiž ukázalo, že některé reakce na mé články jsou skutečně konstruktivní a tedy i velmi přínosné... (-:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Procesor ➡Ethernet ➡NodeJS ➡Redis ➡ExpressJS ➡Socket.IO ➡Browser ✅ <a href=\"http://t.co/MAIlmMZEL9\">pic.twitter.com/MAIlmMZEL9</a></p>&mdash; Martin Zlámal (@mrtnzlml) <a href=\"https://twitter.com/mrtnzlml/status/531104236571230208\">November 8, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n# Několik slepých uliček\n\nPůvodně byl celý nápad úplně jiný a rozhodně ne real-time. A stejně jako je teď velký trend stavět vše pomocí *Raspberry Pi* nebo pomocí *Arduino*, tak i já jsem tak chtěl učinit. Důvod je jednoduchý. Napsat se s pomocí těchto desek dá všelicos velmi rychle a nestojí to moc námahy. Navíc jsem chtěl více času věnovat webové aplikaci, než nějakému mikročipu. Postupem času a po několika vážných rozhovorech jsem začal přemýšlet nad real-time přenosem informace v obou směrech. Takže bylo zapotřebí najít vhodnou desku. Jenže na real-time už jsem si jen s *Raspberry* nevěřil a proto jsem hledal nějakou lepší desku na kterou bych nahodil nějaký velmi lehký Linux a NodeJS. Po dalších vážných rozhovorech jsem však i z této cesty ustoupil a zvolil jsem něco, co jsem ze začátku vůbec neuvažoval. Chtěl jsem zvolit desky od ST z řady [Nucleo](www.st.com/stm32nucleo), ale tyto desky nemají ethernet a tak bylo lehčí vypůjčit si [eval-boardy](www.st.com/stm3220g-eval). Tyto desky mají stejné procesory, ale více periferií okamžitě k dispozici. Jenže to znamená, že musím opustit všechno hraní si a hluboce se ponořit do **C**čka...\n\n# Správná ulička?\n\nDesky a procesory jsou tedy jasné. Co dál? Nezbývá než stanovit, jak se bude informace přenášet až do prohlížeče. Zde je zřejmě jasná věc to, že mezi procesorem a prohlížečem musí být nějaký mezičlen. Ten u mě tvoří [NodeJS](http://nodejs.org/) server v kombinaci s [Redis](http://redis.io/) databází zhruba tak, jak je znázorněno na [ASCII artu](http://cs.wikipedia.org/wiki/ASCII_art) níže:\n\n```\n------------      ----------      -----------\n| Procesor | ---> | NodeJS | ---> | Browser |\n------------      ----------      -----------\n        |             ^\n        |             |\n        |         ---------\n        --------> | Redis |\n                  ---------\n```\n\nJak celý přenos v současné chvíli probíhá? Procesor je teď aktivním prvkem, tzn. sbírá nějaká potřebná data (např. pomocí ADC snímá polohu natočení potenciometru) a pomocí UDP datagramů je odesílá na jasně danou IP adresu NodeJS serveru, kde se informace z datagramu uloží do dané struktury v Redis databázi. Tyto datagramy se skládají z klasické UDP hlavičky a datové části. Ta je v [RESP](http://redis.io/topics/protocol) formátu, takže teoreticky bude někdy později možné NodeJS server úplně přeskočit a data ukládat přímo z procesoru do databáze jak je na diagramu naznačeno. Server však nikdy nepůjde úplně odstranit, protože na NodeJS serveru běží v této chvíli UDP server, ale také tam běží webový server ([ExpressJS](http://expressjs.com/)), který mi umožňuje rovnou vytvořit webovou stránku a s pomocí [Socket.IO](http://socket.io/) si mohu otevřít websocket a z databáze opět informace odesílat bleskovou rychlostí do prohlížeče, kde je mohu javascriptem nějak dále zpracovat.\n\n# K čemu to celé je?\n\nNevím. (-: Tento článek jsem napsal proto, abych si utřídil myšlenky a získal zpětnou vazbu. Celý projekt měl však původně být pro tzv. inteligentní domy, kdy by stačilo dům pouze zasíťovat a vše ostatní by již bylo vlastně hotovo (přes ethernet lze i napájet). Výhodné je to v tom, že můžete kdykoliv jakýkoliv prvek domácnosti odpojit, dát ho na jiné místo (v rámci IP rozsahu) a vše by stále fungovalo. Jenže jak často přesouváte vypínače (termostaty, světla, senzory)? Proto se chci spíše zaměřit na objekty kde se tyto věci často řeší, proto vidím správný směr spíše v (relativně) často se měnících kancelářských budovách, nebo tam kde je potřeba například rychle připojit nějaké senzory a sledovat je online. Každopádně věřím, že díky svým možnostem tento systém natrhne zadek i současným systémům pro ovládání \"inteligentních\" domů využívajících PLC-like systémy.\n\nBudoucnost je zatím celkem jasná. Teď chci naučit systém komunikovat i v opačném směru a následně jej budu pilovat, čímž završím první etapu práce. Cest pro rozšiřování je však ještě spoustu. Jednak chci systém naučit komunikovat bezdrátově, pak také IPv6, šifrovanou komunikaci a v neposlední řadě chci vyrobit nějaké senzory a akční členy pro reálné použití a zprovoznit funkční ukázku pro prezentování celé této srandy.\n\nTak co, máte dostatek odvahy šoupnout si takový systém do baráku? Upozorňuji, že to není žádná Arduino-like stavebnice, takže to je spolehlivé... (-:","frontmatter":"id: 3979a0f0-f8ed-45c3-8311-d48e563a49b1\ntimestamp: 1416264254000\ntitle: Nadvláda inteligentních procesorů\nslug: nadvlada-inteligentnich-procesoru"},{"attributes":{"id":"420ed8a1-f8bb-42eb-9f8d-356783765357","timestamp":1414868997000,"title":"Dependent select box","slug":"dependent-select-box"},"body":"Občas je v Nette zapotřebí vyřešit dependent select box. Je to relativně málo častý požadavek a o to méně se o něm dá najít, když je to zrovna potřeba. V zásadě existují dvě řešení. Nudné - poctivé a pak zábavné - špinavé. Podívejme se na to, jak se dá takový dependent select box jednoduše vyřešit.\n\n# Čisté řešení\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/51d212f2-5aa9-44b9-9085-f6267e1974e9/vystrizek.png)\nToto řešení ukazuje jak by se takový problém měl zhruba řešit. Myšlenka je velmi jednoduchá. Prvně potřebujeme data do závislého select boxu. Ty se normálně vyřeší prostřednistvím databáze, v našem případě postačí jednoduché pole.\n\n```php\nprivate $database = [\n    [1 => '2', '4', '9'],\n    [4 => '.', '∴', '…'],\n    [5 => 'π', '€', '©'],\n];\n```\n\nNásledně je potřeba vytvořit samotný formulář:\n\n```php\nprotected function createComponentForm($name) {\n    $form = new UI\\Form;\n    $this[$name] = $form; // <- Zde je celý fígl\n    \n    $form->addSelect('one', 'One', ['Čísla', 'Tečky', 'Symboly'])->setDefaultValue(1);\n    //dump($form['one']->value);\n    \n    $form->addSelect('two', 'Two', $this->database[$form['one']->value]);\n    \n    $form->addSubmit('send', 'Odeslat');\n    $form->onSuccess[] = $this->success;\n    return $form;\n}\n```\n\nA k formuláři také šablonu:\n\n```html\n{form form}\n    {input one, size => 3}\n    {snippet two}\n    \t{input two, size => 3}\n    {/snippet}\n    {input send}\n{/form}\n```\n\nAby šlo použít snippet uvnitř formulářového makra, budeme muset udělat malý workaround:\n\n```php\npublic function beforeRender() {\n\tparent::beforeRender();\n\t$this->template->_form = $this['form']; // form {snippet} workaround\n}\n```\n\nSnippet je však možné zatím úplně vynechat, protože bude potřeba až při ajaxifikaci.\n\nCelý fígl je v tom, že musíme zajistit, aby se hodnota druhého select boxu nastavovala podle hodnoty prvního. V tomto stavu je již možné formulář spustit. Po vybrání v prvním select boxu a odeslání formuláře se vybraná hodnota následně projeví v druhém select boxu. Celé kouzlo je pouze v té druhé řádce formulářové továrničky, který mi umožní přistoupit k hodnotám prvků. Je samozřejmě nesmysl odesílat celý formulář pro získání obsahu druhého select boxu, proto si napíšeme krátký javascriptový kód, který to za nás vyřeší (nette.ajax.js):\n\n```javascript\n$(function(){\n\t$.nette.init();\n    \n\t$('select[name=one]').change(function () {\n\t\t$.nette.ajax({\n\t\t\turl: {link invalidate!},\n\t\t\tdata: {\n\t\t\t\t'value': $('select[name=one]').val(),\n\t\t\t}\n\t\t});\n\t});\n});\n```\n\nJakmile se změní hodnota prvního select boxu, zavoláme si handler a předáme mu novou hodnotu. Tento handler bude mít za úkol nastavit hodnoty druhého select boxu a pouze tento prvek invalidovat:\n\n```php\npublic function handleInvalidate($value) {\n\t$this['form']['two']->setItems($this->database[$value]);\n\t$this->redrawControl('two');\n}\n```\n\nTím je vlastně hotovo. Čistotu řešení ověříme tím, že si vyzkoušíme dump vybraných položek po odeslání formuláře:\n\n```php\npublic function success(UI\\Form $form, $vals) {\n\tdump($vals);\n}\n```\n\nČistota spočívá v tom, že požadované hodnoty skutečně získáme. To není úplně samozřejmé, protože v Nette existuje bezpečnostní obranný mechanismus, který zabraňuje odeslání hodnot v select boxu, které na začátku neobsahoval. Pokud něco takového uděláme třeba javascriptem, zíkáme `NULL`. Aby se toto nedělo, musíme takto relativně složitě vyřešit továrničku pro formulář.\n\n# Špinavé řešení\n\nŠpinavé řešení se od toho čisté o moc neliší. Myšlenka je pořád stejná, tentokrát však stojíme před jiným úkolem. Vezměme si příklad, kdy nám zase až tolik nezáleží na tom, jaké získáme v select boxu hodnoty a chceme ho používat spíše jako text input, kdy nabídneme uživateli nějaký vstup. Typický příklad je text input pro URL adresu API, kdy po zadání kontaktujeme nějaké API a nabídneme v selectu vrácené hodnoty tak, aby je uživatel nemusel psát. Netvrdím, že by to nešlo vyřešit čistě, ale špinavé řešení je v tomto případě pohodlnější, rychlejší a mohu na něm ukázat i něco jiného. Tentokrát si vytvoříme úplně obyčejný formulář, tak jako již mnohokrát. Není potřeba žádného fíglu. Opět si připravíme šablonu pro formulář obdobně jako v předchozím případě. A obdobně doplníme nějaký ten javascript. Zde bych klidně mohl formulář upravit javascriptově, ale mě se hodí zavolat si (po napsání URL adresy) handler, v něm vyřešit vše potřebné a invalidovat část formuláře.\n\n```javascript\nvar timer = null;\n$('input[name=url]').live('keyup', function () {\n\tif (timer) {\n\t\tclearTimeout(timer);\n\t}\n\ttimer = setTimeout(function () {\n\t\ttimer = null;\n\t\t$.nette.ajax({\n\t\t\turl: {link checkErp!},\n\t\t\ttype: 'POST',\n\t\t\tdata: {\n\t\t\t\t\"erpForm-url\": $('input[name=url]').val()\n\t\t\t}\n\t\t});\n\t}, 250);\n});\n```\n\nHandler nemá smysl uvádět. Jednoduše v něm vykonám nějakou logiku, vrátím data a invaliduji šablonu. Pozor na to, že předchozí javascriptová ukázka je tentokrát ze separátní komponenty.\n\nZbývá nám vyřešit pouze odeslání a zpracování formuláře. Jelikož jsem byl teď líný programátor a select v tomto případě beru spíše jako text input, nemohu získat hodnotu select boxu ve `$form->getValues()`, resp. v druhém parametru succeeded metody. Musím proto použít metodu `getHttpData`, která mi umožní získat jakákoliv data a zároveň mám jistotu, že jsou data ošetřena:\n\n```php\npublic function erpFormSucceeded(UI\\Form $form, Nette\\Utils\\ArrayHash $values) {\n\ttry {\n\t\t$this->erpSystems->create([\n\t\t\tErpSystems::COLUMN_URL => $values->url,\n\t\t\tErpSystems::COLUMN_DATABASE => $form->getHttpData(UI\\Form::DATA_LINE, 'database'), // <- náš select\n\t\t\tErpSystems::COLUMN_USER => $values->username,\n\t\t\tErpSystems::COLUMN_TOKEN => $values->password,\n\t\t]);\n\t\t//...\n\t} catch (\\PDOException $exc) {\n\t\t//...\n\t}\n\t//...\n}\n```\n\nV tomto špinavém řešení je však zapotřebí myslet na to, že v selectu může přijít naprosto cokoliv. To by však nikoho nemělo převapit. Ostatně i při vytváření formuláře stačí vytvořit select box prázdný, protože žádná vstupní data ani neexistují.","frontmatter":"id: 420ed8a1-f8bb-42eb-9f8d-356783765357\ntimestamp: 1414868997000\ntitle: Dependent select box\nslug: dependent-select-box"},{"attributes":{"id":"fc390f36-af8a-43af-a34c-619f305e288c","timestamp":1414243893000,"title":"Heatmapy ve Wolfram Mathematica","slug":"heatmapy-ve-wolfram-mathematica"},"body":"![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/1bb55605-d567-4fe0-b1d1-69e921940e0d/heatmap1.png)\n\nPrávě teď jsem řešil jak vizualizovat nějaká data, která jsou v maticovém formátu. Pro mé účely jsou prakticky dva grafy. Prvním grafem je heatmapa (viz obrázek) a druhým klasický 3D graf, který data reprezentuje stejně dobře (možná lépe), ale v určitých případech je špatně čitelný. Zejména pak když není možnost s grafem otáčet. V mém případě bylo zapotřebí poměrně velké množství grafů, které jsem nakonec minimalizoval na počet 40, takže bylo nemožné je vykreslovat ručně. Zvlášť pokud jsem zajistit, že budou všechny grafy stejné.\n\nK tomu jak jsem postupoval se dostanu v další části. Teď však ještě pár úvodních slov k tomu, co jsem to vlastně měřil. Cílem měření bylo změřit s využitím jasoměrů hodnoty jasů *L [cd/m^2]* určitých objektů a jejich okolí v pravidelné síti kontrolních bodů při různém osvětlení (denní, sdružené a umělé) a různé vzdálenosti a úhlu. Z těchto jasů je zapotřebí spočítat kontrast *C [-]* a tuto kontrastní mapu také vizualizovat. Je tedy zřejmé, že stačí změřit pár objektů a počet grafů rychle roste.\n\n# Vizualizace dat\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/40a97326-5410-4385-821c-62dc8542387a/3d2.png)\nTato část se sice jmenuje vizualizace dat, ale aby bylo co vizualizovat, je zapotřebí data připravit. Já jsem zvolil JSON formát vstupu, protože se velmi jednoduše parsuje a matici v něm mohu zapsat také jednoduše. Z měření jednoho objektu mi tedy stačí data v tomto formátu:\n\n```javascript\n{\n\t\"Tabule - umělé osvětlení\": {\n\t\t\"up\": \"STROP\",\n\t\t\"down\": \"PODLAHA\",\n\t\t\"left\": \"OKNA\",\n\t\t\"right\": \"DVEŘE\",\n\t\t\"values\": [\n\t\t\t[121.3, 146, 74.2, 39.5, 27.6, 53.9, 66.7],\n\t\t\t[96.5, 86.1, 80.2, 54.8, 47.3, 65.8, 79.5],\n\t\t\t[82.6, 78, 71.8, 65.3, 58.7, 62.3, 79.5],\n\t\t\t[63.8, 71.5, 66.7, 63, 59.4, 63.2, 77.5],\n\t\t\t[62.4, 61, 63.9, 62.4, 62.7, 63.4, 70.5]\n\t\t]\n\t}\n}\n```\n\nTakových dat je již možné se chytit a vykreslit celou řadu průběhů. Samotný parser se však postupem času poměrně zkomplikoval. Prohlédnout si ho však můžete [na GitHub Gistu](https://gist.github.com/mrtnzlml/9ec02541555e419a8df9#file-parser7-php) a to včetně kompletního vstupu a výsledného výstupu pro Wolfram Mathematica. Tento výstup je v zásadě jednoduchý. Například graf, který je v úvodu vykreslíme pomocí následujícího výstřižku:\n\n```php\nShow[MatrixPlot[{\n\t{-0.063, -0.753, -0.706, -0.788, -0.443, 0.311, 0.327},\n\t{0.619, 0.613, 0.671, -0.013, -0.162, 0.295, 0.344},\n\t{0.297, 0.441, 0.351, 0.178, 0.087, 0.166, 0.339},\n\t{-0.085, 0.27, 0.225, 0.155, 0.118, 0.163, 0.317},\n\t{-0.033, 0.017, -0.015, 0.03, 0.019, 0.077, 0.198}\n}, PlotTheme -> \"Detailed\", Mesh -> Automatic, MeshStyle -> Directive[GrayLevel[0], Opacity[0.5], Dashing[{0, Small}]]],\nFrameLabel -> {{HoldForm[OKNA], HoldForm[DVEŘE]}, {HoldForm[PODLAHA], HoldForm[STROP]}},\nPlotLabel -> RawBoxes[\"Tabule - umělé osvětlení, zezadu (kontrast, Lp = 59.7)\"], LabelStyle -> {GrayLevel[0]}]\n```\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/79b1a8e3-1efc-42b0-bb79-3409b9acd49d/3d.png)\n\nKromě nastavování popisek a záhlaví, tak je důležitý hlavně blok kde jsou data. V tomto grafu není žádná zrada. Malá zrada číhá až v 3D grafech. Zde je háček v tom, že občas relativně malá plocha grafu ustřelí mimo průměrnou hodnotu všech bodů a na grafu dojde k oříznutí. Aby se tomuto efektu předešlo, je bezpodmínečně nutné nastavit grafu `PlotRange -> All`. Tím se vykreslí celý graf nezávisle na tom, jaké obsahuje extrémní hodnoty. Je však otázka jestli je to žádoucí. V mém případě ano, ale umím si přestavit případy, kdy by velká špička totálně zničila celý graf a bylo by výhodnější spičku oříznout.\n\n```php\nListPlot3D[{\n\t{62.4, 61, 63.9, 62.4, 62.7, 63.4, 70.5},\n\t{63.8, 71.5, 66.7, 63, 59.4, 63.2, 77.5},\n\t{82.6, 78, 71.8, 65.3, 58.7, 62.3, 79.5},\n\t{96.5, 86.1, 80.2, 54.8, 47.3, 65.8, 79.5},\n\t{121.3, 146, 74.2, 39.5, 27.6, 53.9, 66.7}\n}, ColorFunction -> \"DarkRainbow\", PlotRange -> All, PlotTheme -> \"Business\"]\n```\n\nPro vykreslení horního pohledu stačí přidat další atribut `ViewPoint -> Above`, čímž získáme teplotní mapu v trošku jiném zobrazení a díky Business tématu budou na grafu vidět i vrstevnice, což ulehčí představu o tom jak je graf tvarově rozložen. <span style=\"color:green\">Také pozor na to, že do funkcí `MatrixPlot` a `ListPlot3D` se zadávají matice v obráceném pořadí z hlediska řádek matice! Dojde tak ke vykreslení stejných map.</span>","frontmatter":"id: fc390f36-af8a-43af-a34c-619f305e288c\ntimestamp: 1414243893000\ntitle: Heatmapy ve Wolfram Mathematica\nslug: heatmapy-ve-wolfram-mathematica"},{"attributes":{"id":"db4ac671-20f0-4c4b-b551-129b719fd510","timestamp":1413669750000,"title":"Nastavení TIM3 na STM32F207xx","slug":"nastaveni-tim3-na-stm32f207xx"},"body":"Tento článek už mám dlouhou dobu v hlavě, ale nikdy jsem se neodvážil jej sepsat. Má to svůj smysl. Jedná se o poměrně náročnou problematiku, kterou si myslím, že moc lidí nechápe. Rád bych tedy tímto popíchnul čtenáře o zpětnou vazbu a pokud by se ukázalo, že to smysl má, pokračoval bych někam dál do složitějších věcí, protože toto bude ve výsledku směšně jednoduché... (-:\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/f34b6d82-9aaf-4089-afe6-81993d596885/stm32.png)\n\nK dispozici mám momentálně dva procesory, ale budu řešit konkrétně `STM32F207xx`. Ten druhý je ze `4xx` řady, ale díky novým Cube knihovnám není v programech žádný rozdíl. Alespoň ne v tom, co bu ukazovat dnes. [STM32F207](http://www.st.com/web/catalog/mmc/FM141/SC1169/SS1575/LN9/PF245085) je procesor založený na 32-bit ARM(R) Cortex(R)-M3 od STMicroelecronics. Jedná se o procesor s 120 MHz jádrem, 1024 kB flash pamětí na program a 128 kB SRAM. Celkově se jedná o poměrně výkonnou mršku na které se toho nechá upočítat poměrně hodně a hlavně dokáže ovládat velké množství rozmanitých periferií viz obrázek. Na obrázku je přesně ta samá eval deska s tím samým procesorem, na kterou právě teď koukám. Nejzajímavější bude teď však právě onen procesor, který je uprostřed desky a SMD diody, které nejsou téměř vůbec vidět. Ty jsou umístěny nad Wakeup tlačítkem téměř pod displejem.\n\nA teď konečně o čem budu psát. TIM3 je timer ze skupiny TIM2-5. Jedná se o timer naprosto běžný a obyčejný. Celkem jich je k dispozici 14 ve 4 skupinách podle společných vlastností. Podívat se na ně můžete do [referenční příručky](http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf), ale pozor ať se vám z toho nezamotá hlava, je toho tam fak hodně... (-: Ukážeme jak tento timer nastavit tak aby bylo možné blikat diodou jednou za 1000 ms. Navíc k tomu nebudeme využívat výkonu procesoru, ale využijeme přerušení, takže nebudeme procesor vůbec ničím zdržovat. O zrovna čekání procesoru 1000 ms, než bude moci bliknout diodou by byl slušný zabiják výkonu.\n\n# Nastavení TIMx a diod\n\nJe to jednudché. V souboru `main.c` existuje klasická viod metoda s while smyčkou, která bude na začátku i na konci tohoto programu prázdná:\n\n```cpp\n#include \"main.h\"\nint main(void) {\n\tHAL_Init();\n    SystemClock_Config();\n\t# ...\n\twhile (1) {\n\t}\n}\n```\n\nCílem je neudělat žádnou blbost a nechat procesor nejlépe bez toho aby něco musel počítat, což je díky přerušení možné a doporučované. HAL (Hardware abstraction layer) vrstu a systémové hodiny nastavíme co nejdříve. `HAL_Init();` je systémová funkce Cube knihoven, která provede inicializaci HW abstraktní vrstvy. Ve skutečnosti HAL_Init spouští celou řadu dalších initů. `SystemClock_Config();` je již uživatelská metoda, která je umístěna v každém demu v Cube Examples, takže ji sem nebudu přepisovat. Je téměř vždy stejná. Následovat by však měla inicializace diod. Dalo by se to udělat i složitě, ale s využitím BSP (Board support package) je inicializace triviální:\n\n```cpp\nBSP_LED_Init(LED1);\n# LED2, LED3, LED4\n```\n\nTeď tedy máme nastartovanou desku, hodiny a připravené diody k použití. Nezbývá než se pustit do nastavování timeru:\n\n```cpp\n/*##-1- Configure the TIM peripheral #######################################*/\nTimHandle.Instance = TIMx;\nTimHandle.Init.Period = 10000;\nTimHandle.Init.Prescaler = (uint32_t)(((SystemCoreClock / 2) / 10000) - 1); //10kHz\n// T = 1/f = 1/10k = 0,0001 ; time = Period * T = 1s\nTimHandle.Init.ClockDivision = 0;\nTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;\nif(HAL_TIM_OC_Init(&TimHandle) != HAL_OK) {\n\tError_Handler();\n}\n```\n\n`TIMx` je v `main.h` nastaven na TIM3, period je délka intervalu a prescaler je předdělička frekvence, která je díky tomu výpočtu nastavena nezávisle na rychlosti hodin na jednotnou frekvenci 10 kHz. Teď si stačí jen oprášit středoškolskou elektroniku. Pokud víme, že `T = 1/f` a frekvence je 10 000 Hz, pak je perioda takového průběhu 0,1 ms. To je docela průser, protože je to srašně rychlé. Proto je zde právě ta perioda timeru, kde v podstatě říkáme, že toto má proběhnout 10 000x a pak až cvrnknout timerem. A voilà, máme 1 vteřinu. `TIM_COUNTERMODE_UP` přávě říká, že bude počítat dokud nenarazí na strop a pak timer přeteče. Snad jedině pozor na jednu zradu. TIM3 má prescaler 16 bitový, tzn. lze nastavit maximálně hodnotu 2^16 -1 = 65535! Vzhledem k tomu, že to z výpočtu není přímo vidět, tak se na to můžete snadno nachytat a timer pak poběží jinak než bylo požadováno. Dále si nastavíme kanál, který budeme využívat k blikání diodou, protože teď timer pouze dojede na 10 000 a vyresetuje se:\n\n```cpp\n/*##-2- Configure the Output Compare channels #########################################*/\nsConfig.OCMode = TIM_OCMODE_TOGGLE;\nsConfig.Pulse = uhCCR1_Val;\nsConfig.OCPolarity = TIM_OCPOLARITY_LOW;\nif(HAL_TIM_OC_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_1) != HAL_OK) {\n\tError_Handler();\n}\nsConfig.Pulse = uhCCR2_Val;\nif(HAL_TIM_OC_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_2) != HAL_OK) {\n\tError_Handler();\n}\n```\n\nPřed vstupem do main metody je zapotřebí nastavit si ještě pulse hodnoty:\n\n```cpp\n__IO uint32_t uhCCR1_Val = 100;\n__IO uint32_t uhCCR2_Val = 200;\n```\n\nAbych to krátce vysvětlil. Tímto jsem si nastavil, že až timer dosáhne hodnoty 100 a 200, tak cvrnkne a to pokaždé do jiného kanálu. Při dosažení maxima (10 000) dojde k přetečení timeru a ten začne počítat znovu. Je jedno jak tyto hodnoty nastavím, ale musí být od sebe 100 ms. Chci totiž zapnout diodu a dned ji vypnout. Toto se bude opakovat každných 1000 ms viz předchozí nastavení timeru. Super, takže teď máme timer co počítá a v určitém okamžiku pošle dva signály. Tak to nahodíme a jedeme... (-:\n\n```cpp\n/*##-3- Start signals generation #######################################*/\n/* Start channel 1 in Output compare mode */\nif(HAL_TIM_OC_Start_IT(&TimHandle, TIM_CHANNEL_1) != HAL_OK) {\n\tError_Handler();\n}\nif(HAL_TIM_OC_Start_IT(&TimHandle, TIM_CHANNEL_2) != HAL_OK) {\n\tError_Handler();\n}\n```\n\nSkvělé na tom je to, že teď už to fakt cvaká a stačí se na to jen pověsit přepínání stavu diod.\n\n# Konečně blikáme!\n\nK tomu, aby bylo možné blikat, musíme se chytit callbacku, který je v HAL připraven. Zde se podíváme, jestli je daný kanál aktivní a pokud ano, znamená to, že můžeme něco udělat. V tomto případě tedy nejdříve zapnu diodu a za 100 ms přijde signál druhým kanálem a já ji mohu opět vypnout. Za 1s se celý proces opakuje. Paráda!\n\n```cpp\n/**\n  * @brief  Output Compare callback in non blocking mode \n  * @param  htim : TIM OC handle\n  * @retval None\n  */\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim) {\n\tif(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) {\n\t\tBSP_LED_On(LED1);\n  \t}\n\tif(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2) {\n\t\tBSP_LED_Off(LED1);\n  \t}\n}\n```\n\nJeště bych měl zmínit metodu `Error_Handler();`, která se zde často opakuje. Je to metoda, která se zavolá, když se něco nepovede a její obsah může být opět prázdná smyčka, aby procesor nezačal dělat nějaké nesmysly:\n\n```cpp\n/**\n  * @brief  This function is executed in case of error occurrence.\n  * @param  None\n  * @retval None\n  */\nstatic void Error_Handler(void) {\n\tBSP_LED_On(LED4);\n\twhile(1) {}\n}\n```\n\nAsi není úplně hloupé zapnout i nějakou (červenou) diodu, která bude signalizovat error. Rád bych zmínil to, že by bylo možné v main metodě v cyklu spustit `BSP_LED_Toggle(LED4);` a počkat 1 vteřinu. To by bylo funkční, ale jak by se ukázalo časem, tak by tento program mohl sloužit pouze pro blikání diodou, což není moc užitečné. Pokud bych se k tomu dostal, tak si můžeme ukázat jak pracovat s ethernetem a zde se ukáže, že je prázdný while potřeba. Tímto způsobem mi však nic nebrání blikat si diodou a vedle toho ještě tlačit data ethernetem pryč...\n\nTak co, dalo se to vydržet? :-)","frontmatter":"id: db4ac671-20f0-4c4b-b551-129b719fd510\ntimestamp: 1413669750000\ntitle: Nastavení TIM3 na STM32F207xx\nslug: nastaveni-tim3-na-stm32f207xx"},{"attributes":{"id":"e469395b-c4f9-42db-bcf2-b2f1bc49f2e7","timestamp":1413406213000,"title":"Fígloidní odstranění záhlaví modulu","slug":"figloidni-odstraneni-zahlavi-modulu"},"body":"Dnešní článek bude spíše zápisek, protože jsem řešení tohoto problému hledal neskutečně dlouho a jak se později ukázalo, tak řešení je sice jednoduché, ale je zakořeněné hluboko v jádru Odoo ERP systému. O co jde. Občas je potřeba schovat záhlaví (viz obrázek) u některých modulů.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/ddfc321c-2190-4cf6-98a9-89852713e626/vystrizek.png)\n\nTento panel má sice dobrý důvod, ale existují případy, kde je prostě nadbytečný. Typický případ takové nadbytečnosti je modul Dashboards (technický název `board`) kdy je tento prostor nijak nevyužívaný. Zřejmě by tento problém šel řešit nějaký hackem, ale to prostě není dobře. Problém je [zde](https://github.com/odoo/odoo/blob/8.0/addons/web/static/src/js/views.js#L905). \"Special case for Dashboards\"...\n\n# Jak na to\n\nAsi úplně nejjasnější bude, když popíšu posloupnost kroků, které vedou ke správnému řešení. Nejedná se o nic kompikovaného. Všechny níže uváděné postupy jsou klasické postupy při vývoji modulu. Jen je (do teď) pravděpodobně nikde nenajdete, nebo nad tím zbytečně vytuhnete na zoufale dlouhou dobu. Ostatně [podívejte se](https://searchcode.com/?q=views_switcher%20lang:Javascript), jak je výskyt tohoto kousku užitečného kódu [používaný](https://github.com/odoo/odoo/search?l=javascript&q=views_switcher&type=Code&utf8=%E2%9C%93) v public repozitářích... :-)\n\n<span style=\"font-size:2em\">1.</span> Registrace XML definice v `__openerp__.conf`\n\nTato záležitost je asi celkem jasná. Jednoduše musíme definovat, že se má při compile-time brát ohled na XML soubor, ve kterém zaregistrujeme JS soubor viz další bod.\n\n```python\n{\n    #...\n    \n    'data': [\n        'views/header.xml',\n    ],\n    \n    #...\n}\n```\n\n<span style=\"font-size:2em\">2.</span> Registrace JS souboru\n\nTo jsem to ale nazval blbě... (-: V předchozím bodě je tedy definovanám soubor v podadresáři `views`, jehož obsah je např. takovýto:\n\n```html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data>\n        <template id=\"assets_backend\" name=\"queue assets\" inherit_id=\"web.assets_backend\">\n            <xpath expr=\".\" position=\"inside\">\n                <script type=\"text/javascript\" src=\"/module_name/static/src/js/header.js\"/>\n            </xpath>\n        </template>\n    </data>\n</openerp>\n```\n\nTato registrace je naprosto běžná. ERP se k tomu pak staví poměrně chytře, takže když je ERP v `?debug=` módu, tak souboru vrací tak jak jsou, jinak je všechny skládá do jednoho a provádí minimalizaci. V tomto případě je rozdíl signifikantní.\n\n<span style=\"font-size:2em\">3.</span> Javascript definice\n\nJe známá věc, že si toto ERP bez JS ani neuprdne. Na jednu stranu mě to trošku štve, na druhou stranu to nemá vůbec smysl řešit. Dalším krokem proto bude definice na straně JS, která zakáže tomuto konkrétnímu view vykreslení headeru:\n\n```javascript\nopenerp.module_name = function (instance) {\n    //var QWeb = instance.web.qweb;\n    if (!instance.module_name) {\n        instance.module_name = {};\n    }\n\n    //zde navíc např. definice pro instance.web.qweb\n\n    instance.web.ViewManagerAction.include({\n        init: function(parent, action) {\n            var flags = action.flags || {};\n            if (action.res_model == 'module_model' && action.view_mode === 'form') {\n                _.extend(flags, {\n                    views_switcher : false,\n                    display_title : false,\n                    search_view : false,\n                    pager : false,\n                    sidebar : false,\n                    action_buttons : false\n                });\n            }\n            action.flags = flags\n            this._super(parent, action);\n        },\n    });\n}\n```\n\nToto nastavení je vlastně úplně to stejné, jako je v jádru. Jedná se o naprosto korektní a čisté řešení. Bohužel je nutné jej řešit touto myškou, protože toto není funkce, která je (nebo by do budoucna měla být) přímo podporována. Dává to smysl, protože se jedná o skutečně krajní případ.\n\nA na závěr mám pro všechny čtenáře třešničku v podobě easter eggu. Vyzkoušejte si doplnit do URL parametr `?kitten=`, stejně jako se doplňuje například ten parametr pro zapnutí debug režimu... (-: *#yourewelcome*","frontmatter":"id: e469395b-c4f9-42db-bcf2-b2f1bc49f2e7\ntimestamp: 1413406213000\ntitle: Fígloidní odstranění záhlaví modulu\nslug: figloidni-odstraneni-zahlavi-modulu"},{"attributes":{"id":"62e5abe0-44b9-407d-9582-39b8ff2bd176","timestamp":1411922332000,"title":"Hledá se obchodník","slug":"hleda-se-obchodnik"},"body":"Tentokrát nebudu psát o ničem technickém, ale vezmu to hned od druhé věty vážně. Do [Orgis IT](http://www.orgis.cz/) scháníme obchodníka primárně pro Prahu / Plzeň pro rozšíření obchodního teamu. Po dlouhém rozmýšlení máme jasno co požadujeme. Nejedná se o nic zvláštního. Klasicky vyžadujeme samostatnost, pružnost a spolehlivost. To jsou celkem běžné požadavky, takže nemá smysl je zde řešit. Má však smysl řešit obchodní náplň. Jelikož se jedná o IT firmu, byl by vhodný alespoň základní přehled o tom co Orgis IT nabízí. Primárně se teď zaměřujeme na serverová řešení (opravdu velká) a vnitropodnikové ERP systémy o které je největší zájem. Jelikož se jedná o místy dost kompikovanou záležitost na pochopení, obchodník projde odborným zaškolením a i po zaškolení bude obchodník úzce spolupracovat se silnou technickou podporou a s lidmi z technické specifikace.\n\nŽivotopisy zasílejte na <span style=\"font-size:25px\"><a href=\"mailto:hr@orgis.cz\">hr@orgis.cz</a></span>\n\nUvítáme dlouhodobou spolupráci, protože se jedná o velice dynamický obor, kde je potřeba nemalá časová investice jak z naší strany, tak ze strany obchodníka. V případě oboustranné spokojenosti rádi navážeme spolupráci i pro rozvoj na zahraničním trhu. Preferujeme práci především na ŽL, kdy bude výše odměn závislá na obratu. Tato výše není omezena pásmově, ani žádnou horní hranicí.\n\nBtw, stav se pro více informací a zajdeme někam na pivko... (-:\n<br>\n(Plzeň)","frontmatter":"id: 62e5abe0-44b9-407d-9582-39b8ff2bd176\ntimestamp: 1411922332000\ntitle: Hledá se obchodník\nslug: hleda-se-obchodnik"},{"attributes":{"id":"827f7559-3d1a-4888-a6fb-4b421a6d7bd5","timestamp":1409409052000,"title":"Kdyby\\\\Console","slug":"kdyby-console"},"body":"Existují knihovny, bez kterých bych si vývoj webových aplikací již téměř nedokázal představit. Jedním z nich je [Kdyby\\Console](https://github.com/kdyby/console). Již dříve jsem sice napsal článek o [Nette CliRouteru](nette-2-1-dev-clirouter), ale postupem času a hlavně také díky Doctrine jsem velmi rychle a rád přešel na jiné a dokonalejší řešení. Vzhledem k tomu, že na jednom projektu používám tuto knihovnu velmi hodně a vlastně na ní celý projekt stojí, rád bych alespoň prostřednictvím tohoto článku autorovi poděkoval ([Filip Procházka](https://github.com/fprochazka)). Zároveň bych tímto počínáním rád postupně smazával věčný problém těchto knihoven, protože většinou z hlediska návštěvníka ani není jasné, na co ta knihovna je...\n\n# Proč uvažovat o konzoli?\n\nPro mě je tato otázka celkem jednoduchá, protože mám projekty, které nejedou jen na sdíleném hostingu, ale jsou to samostatně stojící aplikace. Z toho plyne, že je často zapotřebí vykonávat pomocí CRONu velké množství úkolů. Toto je hlavní část, proč vůbec o konzolovém nástroji uvažuju. Použití je totiž velmi jednoduché a právě samotná Doctrine nabízí prostřednictvím Kdyby\\Console celou řadu klasických příkazů a je škoda je nevyužívat. Stačí spustit z příkazové řádky `php index.php` u aplikace a pokud jsou příkazy zaregistrovány v konfigu, vypíše se jejich seznam včetně nápověd:\n\n```\nC:\\xampp\\htdocs\\zeminem.cz\\www>php index.php\nNette Framework version 2.2.3-RC2\n\nUsage:\n  [options] command [arguments]\n\nOptions:\n  --help           -h Display this help message.\n  --quiet          -q Do not output any message.\n  --verbose        -v|vv|vvv Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n  --version        -V Display this application version.\n  --ansi              Force ANSI output.\n  --no-ansi           Disable ANSI output.\n  --no-interaction -n Do not ask any interactive question.\n\nAvailable commands:\n  help                       Displays help for a command\n  list                       Lists commands\nblog\n  blog:install               Install database schema (set-up DB credentials in config.local.neon).\n  blog:update                Update database schema (set-up DB credentials in config.local.neon).\ndbal\n  dbal:import                Import SQL file(s) directly to Database.\norm\n  orm:clear-cache:metadata   Clear all metadata cache of the various cache drivers.\n  orm:clear-cache:query      Clear all query cache of the various cache drivers.\n  orm:clear-cache:result     Clear all result cache of the various cache drivers.\n  orm:convert-mapping        Convert mapping information between supported formats.\n  orm:convert:mapping        Convert mapping information between supported formats.\n  orm:generate-entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate-proxies       Generates proxy classes for entity classes.\n  orm:generate:entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate:proxies       Generates proxy classes for entity classes.\n  orm:info                   Show basic information about all mapped entities\n  orm:schema-tool:create     Processes the schema and either create it directly on EntityManager Storage Connection or generate the SQL output.\n  orm:schema-tool:drop       Drop the complete database schema of EntityManager Storage Connection or generate the corresponding SQL output.\n  orm:schema-tool:update     Executes (or dumps) the SQL needed to update the database schema to match the current mapping metadata.\n  orm:validate-schema        Validate the mapping files.\n```\nDíky této možnosti je možné rychle validovat Doctrine entity, nebo generovat SQL schéma přímo do databáze. Použití je opět jednoduché, např.: `php index.php orm:info`.\n\n# Tvorba vlastního příkazu\n\nPrvně je třeba si uvědomit, že tato knihovna je vlastně to samé jako je v [Symfony Console Component](http://symfony.com/doc/current/components/console/introduction.html), tzn. že potřebné informace se dají čerpat právě z této dokumentace a navíc existuje celá sada helperů, jako je například [Progress Bar](http://symfony.com/doc/current/components/console/helpers/progressbar.html), nebo třeba šikovný [Table](http://symfony.com/doc/current/components/console/helpers/table.html). Samotné napsání třídy (Commandu) je pak triviální záležitostí:\n\n```php\n<?php\n\nnamespace App\\Console;\n\nuse Doctrine;\nuse Entity;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass BlogInstall extends Command {\n\n\t/** @var \\Kdyby\\Doctrine\\EntityManager @inject */\n\tpublic $em;\n\n\tprotected function configure() {\n\t\t$this->setName('blog:install')->setDescription('Install database schema (set-up DB credentials in config.local.neon).');\n\t}\n\n\tprotected function execute(InputInterface $input, OutputInterface $output) {\n\t\ttry {\n        \t// Zde vykonáme vše co je potřeba\n\t\t\t// Zde vykonáme vše co je potřeba\n            // Zde vykonáme vše co je potřeba\n            //...\n\t\t\t$output->writeLn('<info>[OK] - BLOG:INSTALL</info>');\n\t\t\treturn 0; // zero return code means everything is ok\n\t\t} catch (\\Exception $exc) {\n\t\t\t$output->writeLn('<error>BLOG:INSTALL - ' . $exc->getMessage() . '</error>');\n\t\t\treturn 1; // non-zero return code means error\n\t\t}\n\t}\n\n}\n```\n\nZa povšimnutí stojí fakt, že tyto třídy jsou vedle presenterů dalším kandidátem na použití `@inject` anotace. V tomto příbadě bude tedy k dispozici příkaz `blog:install`, který je však nutné ještě zaregistrovat v konfiguračním souboru:\n\n```neon\nservices:\n\t-\n\t\tclass: App\\Console\\BlogInstall\n\t\ttags: [kdyby.console.command]\n```\n\nTento způsob registrace je jedna z věcí, která mě štve a rád bych, kdyby se toto Console naučila hackovat sama a já nemusel tagovat, že se jedná o command. Když je totiž těchto příkazů hodně, konfigurační soubor tímto způsobem poměrně rychle roste na své délce a stává se nepřehledným... (-:\n\n# A co je na tom?\n\nVždyť toto umí Symfony. To Kdyby nic jiného neumí? No, tak krom toho, že vůbec řeší integraci do Nette, což je asi hlavní úkol, tak jsou logicky součásti integrace i další části jako jsou například vlastní helpery. Není totiž nic horšího, než když v takovém commandu potřebujete presenter. Ale ono je to vlastně jednoduché:\n\n```php\n$presenter = $this->getHelper('presenter')->getPresenter();\n```\n\nA stejný problém je pak s odkazy. Jak totiž v CLI pracovat s URL, když žádná není? I to Console řeší. Stačí v configu uvést:\n\n```neon\nconsole:\n\turl: http://zlml.cz/\n```\n\nPak je tvorba odkazů v CLI úplná pohodička:\n\n```php\n$link = $presenter->link('//:Front:Homepage:default');\n```\n\nPodívejte se na [reálné ukázky](https://github.com/mrtnzlml/zlml.cz/tree/6d1ad3de5b1f98067a38d2085e4939cd17cf5db5/app/commands) příkazů pro Kdyby\\Console. Za sebe mohu tento nástroj jedině doporučit. Pokud potřebujete se svojí aplikací pracovat z příkazové řádky. Toto je jiná správná cesta. Díky! (-:","frontmatter":"id: 827f7559-3d1a-4888-a6fb-4b421a6d7bd5\ntimestamp: 1409409052000\ntitle: Kdyby\\\\Console\nslug: kdyby-console"},{"attributes":{"id":"ec59389a-b2a2-4033-bbc6-f778efe7095a","timestamp":1409163060000,"title":"Komunikace s ERP pomocí XML-RPC","slug":"komunikace-s-erp-pomoci-xml-rpc"},"body":"Spousta lidí by se ráda připojovala na API ERP systému [Odoo](https://www.odoo.com/), ne vždy je to však procházka růžovým sadem, protože se očekává místy až přehnaná interní znalost tohoto systému. Přitom je to zbytečné. V dnešním článku se pokusím zdokumentovat právě tuto žalostně zdokumentovanou stránku věci tak, aby to zvládl každý alespoň trochu zdatný programátor.\n\nPrvně však několik málo slov o co vlastně jde. Odoo je ERP ([Enterprise Resource Planning](http://www.orgis.cz/sluzby/in-house)) systém poměrně bohatý na funkce a má za úkol řešit zejména vnitrofiremní procesy a obecně všechny záležitosti, které se okolo jakékoliv firmy motají. Lze tedy řešit plánování projektů, jejich workflow, rozvrhování času, řízení zakázek, ale také například správu dokumentů, skladové zásoby, mass mailing, nebo tzv. [Point of Sale](https://www.odoo.com/page/point-of-sale) což je jedna z těch nejvíce zajímavých věcí, alespoň z mého pohledu. Zjednodušeně řečeno lze udělat naprosto cokoliv. A co nejde, tak se jednoduše doprogramuje. Aby však šlo udělat cokoliv, je potřeba připojovat se na tento systém vzdáleně, protože občas se hodí propojit stávající webovou aplikaci právě s takovýmto systémem. To může mít několik důvodů. Například chcete mít ve webové aplikaci data sjednocená s ERP systémem, nebo si chcete vzdáleně stahovat faktury, popř. tlačit data do účtovacího systému. Jak již bylo řečeno - možné je naprosto cokoliv.\n\n# Hello API!\n\nOdoo poskytuje klasické XML-RPC API. Toto API je velmi jednoduché na obsluhu, nicméně ani tento druh API [není můj favorit](srackoapi). S výhodou tedy můžeme použít lehce modifikovanou funkci [Jakuba Vrány](http://php.vrana.cz/webove-sluzby-v-php-xml-rpc-a-soap.php) pro obsluhu tohoto API (PHP):\n\n```php\n<?php\n\nfunction xmlrpc($url, $method, $params = array(), $types = array(), $encoding = 'utf-8') {\n    foreach ($types as $key => $val) {\n        xmlrpc_set_type($params[$key], $val);\n    }\n    $context = stream_context_create(array('http' => array(\n        'method' => \"POST\",\n        'header' => \"Content-Type: text/xml\",\n        'content' => xmlrpc_encode_request($method, $params, array('encoding' => $encoding))\n    )));\n    return xmlrpc_decode(file_get_contents($url, false, $context), $encoding);\n}\n```\n\nNásleduje krátká odbočka k tomu, co vše je možné přes API udělat. Opět bych mohl napsat, že cokoliv, ale zde už si nejsem jist a proto následuje výpis funkcí, které je možné přes api volat a hlavně které považuji za důležité. Existují totiž 4 služby a každá obsahuje jiné metody. Nejhlavnější služba je `common`. Zde jsou k dispozici mimo jiné funkce `login(db, login, password)`, `about(extended=False)`, `timezone_get(db, login, password)` a `version()`. Většina funkcí se dostatečně popisuje sama, pozor však na funkci \"about\", protože ta v době psaní tohoto článku [obsahovala chybu](https://github.com/odoo/odoo/pull/2028). Je tedy zřejmé, že tato skupina funkcí se hodí pro zalogování do systému, nebo pro zjištění časového pásma, popř. verze systému. Pojďme se tedy přihlásit:\n\n```php\n<?php\n//...\n$data = array('database', 'username', 'password');\n$uid = xmlrpc(\"http://.../xmlrpc/common\", \"login\", $data);\n```\n\nVýsledkem volání je unikátní identifikátor uživatele, který si můžeme dočasně někam uložit, aby ho nebylo potřeba zjišťovat pořád znovu. To není potřeba. Nutné ja však upozornit na to, že přes API získáte taková přístupová práva, jaké by měl uživatel, kdyby se přihlašoval normálně pomocí loginu.\n\n# Jedeme dál\n\nNásleduje služba `object`. Ta má na starost práci s databází z hlediska ORM. Ačkoliv má tato služba pouze dvě pro mě zajímavé funkce, užije se s ní nejvíce srandy a patří asi k té nejdůležitější. Zmiňované funkce jsou `execute(db, uid, obj, method, *args, **kw)` a `exec_workflow(db, uid, obj, signal, *args)`. Právě pomocí `execute` lze například vyhledávat v databázi a to tak, že si nejdříve získáme ID hodnoty pro daný výraz a následně si vytáhneme veškeré informace, které jsou potřeba (pokud jsou potřeba). Příklad pro vyhledávání v zákaznících:\n\n```php\n<?php\n//...\n$data = array($database, $uid, $password, 'res.partner', 'search', [['name', 'ilike', 'hledanyvyraz']]);\n$ids = xmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data); //získáme IDčka\n\n$data = array($database, $uid, $password, 'res.partner', 'read', $ids, ['image', 'display_name', 'function', 'email']);\n$users = xmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data); //získáme zákazníky\n\n//ukázka vytváření klienta:\n$data = array($database, $uid, $password, 'res.partner', 'create', ['name' => 'John Doe']);\nxmlrpc(\"http://.../xmlrpc/object\", \"execute\", $data);\n```\n\nJe tedy zřejmé, že pomocí execute můžeme vyhledávat, číst, ale i vytvářet, nebo mazat záznamy (`create`, `search`, `read`, `write`, `unlink`). Zajímavý je způsob zápisu při hledání (<em>ilike</em>). K dispozici jsou následující operátory: `=`, `!=`, `>`, `>=`, `<`, `<=`, `like`, `ilike`, `in`, `not in`, `child_of`, `parent_left`, `parent_right`. Opět se jedná o \"samosepopisující\" názvy. Nejzajímavější je však právě <em>ilike</em>, který není case sensitive a obaluje dotaz procenty jako je tomu například klasicky v MySQL (`%hledanyvyraz%`). U použíté funkce <em>read</em> lze vyjmenovat jaké sloupce se mají vrátit, nebo se vrátí veškerá data (včetně obrázků v base64).\n\n# Pokročilé dotazování\n\nPodmínky dotazování lze ještě zpřesnit pomocí logických operátorů (`&` - and, default, `|` - or, `!` - not). Podmínky se zapisují klasicky prefixově, takže pokud chceme například vyhledat zákazníka s nenastavenou češtinou z čech a německa, položíme například následující prefixový dotaz:\n\n```python\n[('name','=','Adam'),'!',('language.code','=','cs_CZ'),'](',('country_id.code','=','CZ'),('country_id.code','=','DE'))\n# ekvivalentní k:\n[('name','=','Adam'),('language.code','!=','cs_CZ'),'](',('country_id.code','=','CZ'),('country_id.code','=','DE'))\n```\n\nTo v jakých modulech (<em>res.partner</em>) se bude vyhledávat právě záleží na tom, co je naintalováno za moduly a je třeba vědět jak jsou interně označeny, což je podle mého nešťastné, ale zde je přehled těch nejčastějších\n\n- Zákazníci: `res.partner`\n- Telefonáty: `crm.phonecall`, obch. příležitosti - `crm.lead`\n- Produkty: `product.template`, kategorie produktů - `product.category`\n- Projekty: `project.project`, úkoly - `project.task`, tagy - `project.category`\n- Faktury: `account.invoice`, smlouvy - `account.analytic.account`\n- Zaměstnanci: `hr.employee`, výdaje - `hr.expense.expense`\n- Znalostní báze: `document.directory`\n- Kalendář: `calendar.event`\n\nJe svělé, že stačilo pár ukázek a s celým ERP lze dělat téměř cokoliv. Tím to však nekončí, protože existují ještě dvě skupiny příkazů. Třetí skupinou je skupina pro obsluhu a generování reportů `report`. Tato skupina mi v současné chvíli nepřijde natolik zajímavá, ale jmenovitě se jedná o funkce `report`, `report_get` a `render_report`. Mnohem zajímavější, ačkoliv možná trošku vyšší dívčí, je skupina pro přímou práci s databází ERP. Jedná se o skupinu `db` a ta ovládá právě instance celého ERP. Tyto funkce nejsou přímo pro zákazníky, ani obsluhu ERP, ale spíše pro administrátory serverů, tzn. je nutné autorizovat se master helem. Databáze lze mazat, vytvářet, přesouvat, zálohovat, migrovat, duplikovat atd. viz následující výčet funkcí: `create`, `drop`, `dump`, `restore`, `rename`, `change_admin_password`, `migrate_databases`, `create_database` a `duplicate_database`. Zejména pak třeba <em>rename</em> se hodí, protože tato operace nejde jinak vykonat. U všech zmíněných funkcí je nutné se ověřit. U následujících informativních to nuté není: `db_exist`, `list`, `list_lang`, `server_version`. Velký pozor na funkci <em>db_exist</em>. Ve skutečnosti totiž kontroluje, jestli se lze k databázi připojit, nikoliv jestli existuje, což nutně nemusí být jedno a to samé...\n\nPokud si chcete o dané problematice přečíst více, doporučuji tuto zastaralou [dokumentaci](https://doc.odoo.com/6.1/developer/12_api/). Je dobrá, nikoliv však postačující. Obsahuje však ukázky i pro jiné programovací jazyky, než je PHP. Doufám, že tento článek vyjasnil všechny zákoutí komunikace s API ERP systému Odoo... (-:","frontmatter":"id: ec59389a-b2a2-4033-bbc6-f778efe7095a\ntimestamp: 1409163060000\ntitle: Komunikace s ERP pomocí XML-RPC\nslug: komunikace-s-erp-pomoci-xml-rpc"},{"attributes":{"id":"773516e7-b186-4441-9de4-0ce12bdc37b3","timestamp":1406926545000,"title":"Za hranicí ORM","slug":"za-hranici-orm"},"body":"Již mnohokrát jsem slyšel, že je ORM [antipattern](http://www.zdrojak.cz/clanky/orm-je-antipattern/). Já si to nemyslím. Je to hloupý a uspěchaný názor. V dnešním článku však nechci rozebírat co je a co není antipattern. To je jen zbytečnou ztrátou času. Rád bych ukázal použití jednoho ORM systému, který mě naprosto uchvátil.\n\n# Když jsou potřeba firemní procesy\n\nZejména začínající firmy mají na svém startu náročný úkol. Je zapotřebí vytvořit vnitrofiremní procesy, které striktně řídí běh různých akcí jako je například výroba, reklamace, nebo třeba koloběh dokumentů. Ve firmě [taková řešení nabízíme](http://www.orgis.cz/sluzby/in-house) a je o ně velký zájem. Má to svůj smysl. Není žádným tajemstvím, že používáme ERP systém [Odoo](https://www.odoo.com/), protože je to velmi silný nástroj. I přes neuvěřitelnou modifikovatelnost této aplikace je občas zapotřebí sáhnout k daleko více sofistikovanému řešení. Proč? Občas jsou totiž vnitropodnikové procesy velmi složité a navíc jich je velké množství. V takovém případě, je téměř jedinou možností napsat si pro tento ERP systém rozšíření, které tento těžký úkol zvládne.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/393212dc-381f-4b3a-a06c-fb5d33d6dc29/workflow.png) *Ukázka struktury klasického firemního workflow*\n\nNechci však psát návod na to, jak si takový modul naprogramovat. O tom třeba někdy příště. Pojďme se raději podívat na to, jak téměř celé Odoo funguje, protože je to skutečně pozoruhodné. Bez kódů to však nepůjde.\n\n# Záplava tabulek\n\nAbych byl upřímný, tak jsem se ještě nikdy nesetkal s tím, aby byl **každý** objekt v projektu skutečně realizován tabulkou v databázi. Nebo o tom alespoň nevím. Je to v podstatě jako když máte entity a ty jsou pak skutečně v databázi. Rozdíl je však v tom, že zde je v \"entitě\" i celá potřebná logika (které většinou moc není) a hlavně žádné jiné objekty nejsou potřeba.\n\nV nejprostším tvaru může tedy třída modulu vypadat skutečně pouze jako entita:\n\n```python\nclass project_wkf_activity(osv.osv):\n    _name = 'project.wkf.activity'\n    _columns = {\n        'sequence': fields.integer('Sequence'),\n        'name': fields.char('Workflow Activity Name', required=True, size=64, translate=True),\n        'type': fields.many2one('project.wkf.type', 'Workflow Type'),\n        'fold': fields.boolean('Folded in Kanban View'),\n    }\n    # ...\n    def jumptoseq(self, cr, uid, ids, sequence, context=None):\n    \t#...\n```\n\nPři programování modulů toto vede k extrémní explozi tabulek v databázi. 500 tabulek uděláte v databázi jako nic. Stačí nainstalovat pár modulů. A to už mi přijde dost netradiční. Kromě modulových tabulek je v základní instalaci asi 100 tabulek, které v sobě drží vše možné, mimo jiné také informace o workflow. A právě definice workflow je to nejzajímavější. Veškerá sranda se totiž odehrává v XML souborech. Ve výsledku stačí pro napsání složitého workflow včetně veškeré logiky pouze XML...\n\n# XML programování (-:\n\nKdyž jsem toto poprvé viděl, párkrát jsem se zastavil a přemýšlel jsem, jak to vlastně může fungovat. Je to však velmi jednoduché. V inicializačním souboru modulu si stačí nadefinovat jaké XML soubory se mají načítat. Následuje definice workflow. Žádné psaní okolo. Prostě to hned funguje. Začátek takového workflow může vypadat například takto:\n\n```html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    \t<record id=\"wkf1\" model=\"workflow\">\n            <field name=\"name\">project.wkf1</field>\n            <field name=\"osv\">project.project</field>\n            <field name=\"on_create\">True</field>\n        </record>\n\t</data>\n</openerp>\n```\n\nTím je workflow založeno a při spuštění převedeno do databáze. Jádro má pak za úkol se těchto tabulek chytit a pracovat s nimi. Jsou jasně daná pravidla, takže s tím není žádný problém. Následuje definice akcí (to jsou ty bubliny na obrázku):\n\n```html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    \t<!-- viz definice workflow -->\n        \n        <record id=\"a_1_0\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_start\">True</field>\n            <field name=\"name\">start-wkf1</field>\n            <field name=\"kind\">dummy</field>\n        </record>\n\n        <record id=\"a_1_10\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"name\">nazev-activity</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">jumptoseq(10)</field>\n        </record>\n        \n        <record id=\"a_1_500\" model=\"workflow.activity\">\n            <field name=\"wkf_id\" ref=\"wkf1\"/>\n            <field name=\"flow_stop\">True</field>\n            <field name=\"name\">end</field>\n            <field name=\"kind\">function</field>\n            <field name=\"action\">orgis_close()</field>\n        </record>\n\t</data>\n</openerp>\n```\n\nA následuje definice transitions (spojení na obrázku):\n\n```html\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<openerp>\n    <data noupdate=\"0\">\n    \t<!-- viz definice workflow -->\n        <!-- viz definice aktivit -->\n        \n        <record id=\"t_1_9\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_40\"/>\n            <field name=\"act_to\" ref=\"a_1_50\"/>\n            <field name=\"signal\">a_1_40toa_1_50</field>\n        </record>\n        <record id=\"c_1_7\" model=\"workflow.transition\">\n            <field name=\"act_from\" ref=\"a_1_36\"/>\n            <field name=\"act_to\" ref=\"a_1_500\"/>\n            <field name=\"signal\">close_wkf</field>\n        </record>\n\t</data>\n</openerp>\n```\n\nUkázky jsou nekompletní, protože by se to sem všechno ani náhodou nevešlo. Výsledný XML soubor vlastně stačí k tomu, aby celé workflow fungovalo. Stačí nadefinovat funkce v příslušných třídách viz například volání `jumptoseq`.\n\nDost často je také zapotřebí definovat tlačítka pro view, což se dělá také pomocí XML kde je opět originálně vyřešeno přepisování defaultní šablony. Tlačítka mají vždy nějakou akci, která zajistí, že se posuneme ve workflow dále. Na takové workflow lze pověsit úplně všechno. Poslání emailů, vygenerování faktur, založení akce v kalendáři atd. Pokud se jedná o vyloženě automatické kroky, akce se na tlačítku nemusí definovat a pak systém celé workflow proskáče a spustí všechny akce popořadě sám. Zajímavé je však to, že se po spuštění všechno nahrne do databáze a jádro Odoo se strará pouze o to, aby tento interně složitý systém fungoval správně. Všem lidem, kteří nadávají na ORM bych tedy položil následující otázku. Jak uděláte takto sofistikovaný systém bez ORM? Nebo že toto snad není ORM? A uvědomte si, jak jsem se strašně rychle dokázal dostat z ORM až na celý komplexní systém workflow. Je to proto, že jsem vůbec neuvažoval něco jako je ActiveRow... (-: I když z velké části je to spíše plnění tabulek.\n\nV tomto reálně fungujícím řešení je velmi hluboká myšlenka. A udivuje mě, že v jiných systémech toto funguje úplně obráceně. Všichni se snaží programovat spíše to jádro. Ukazuje se však, že využít kvalitní jádro, které se stará o všechno je daleko přínosnější. Vzpomeňte si na tento článek, až budete ťukat do klávesnice entity, mappery, repository, DAO objekty a další a to pouze kvůli tomu, aby bylo možné udělat nějaké takové workflow, jako jsem zde teď popsal. Už zase...\n\nPoužíváte také nějakou netradiční implementaci ORM?","frontmatter":"id: 773516e7-b186-4441-9de4-0ce12bdc37b3\ntimestamp: 1406926545000\ntitle: Za hranicí ORM\nslug: za-hranici-orm"},{"attributes":{"id":"54e244cd-2b74-4532-b36c-74a7827aa231","timestamp":1405627130000,"title":"SračkoAPI","slug":"srackoapi"},"body":"Následující řádky budou čistý hate na několik tvůrců API, který má posloužit budoucím tvůrcům API. Sám totiž musím obsluhovat několik služeb a získávat z nich data. A ačkoliv se nebráním složitostem, některé věci jsou tak absurdní, že až rozum zůstává stát...\n\nNo to si ze mě děláte...\n------------------------\nPrvní místo na žebříčku debility získává API pro obsluhu a registraci domén od Web4U. Jedná se o klasické SOAP API, které mě však místy přivádí k šílenství. Začnu pěkně od začátku. Aby bylo vůbec možné API volat, musíte nejdříve získat identifikátor služby. Kde jej sehnat? Napadá vás někde v aministraci? Kde jinde také, že? Omyl! Identifikátor služby se získává tak, že zavoláte jakoukoliv funkci z jejich API špatně a identifikátor najdete ve vrácené exception. A to si nedělám prdel. To fakt mají napsané v dokumentaci. A aby toho nebylo málo, tak vrácené ID je ve formátu `IDxxxxxxx, ...`. Koho by však napadlo, že ID je tich prvních 9 znaků, tak je na omylu. ID je totiž to ID bez úvodního ID, tedy `xxxxxxx`. Takto je to možná jasné, ale když k tomu poprvé sednete, tak nad tím sedíte půl dne. Následně lze funkci opět volat s vráceným ID. A právě volání je další sranda.\n\nV dokumentaci je totiž jasně napsáno co jsou povinné vstupní hodnoty, volitelné hodnoty a občas i co to vrací. Takže je to jasné, prostě tam pošlu pole hodnot key-value a je to. Hahaha. Ne. Do tohoto API se totiž posílá pole polí s tím, že je zapotřebí dodržovat přesně stanovený formát a to takovýto:\n\n```php\narray(\n\tarray('name' => 'key', 'data' => 'value'),\n\t//...\n)\n```\n\nJe to jedna z věcí, která je prostě hloupá. Pokaždé se musím sám sebe ptát, proč to tak je? Nerozumím tomu, nemá to žádnou přidanou hodnotu. Jdeme dál. Řekněme, že potřebujete pomocí API zjistit nějakou informaci o doméně, například kdy skutečně expiruje. Na to se stačí jednou týdně zeptat a aktualizovat si informace v databázi. To pro případ, že byla doména prodloužena u třetí strany. No, nebudeme to rozebírat dále. Přes API nelze tuto funkci zavolat. Proč? Vyžaduje totiž captchu. Jo, ta funkce v API se fakt volá přes obrázkovou captchu. Jako jediná. Chápu jak to použít, ale prakticky všechny své projekty dělám plně automatizované, takže jediné řešení je zde najmout [armádu Indů](http://www.root.cz/clanky/potrebujete-obejit-captcha-zaplatte-si-armadu-indu/) a captchy louskat ručně.\n\nA takových perel je tam nespočet. Potřebujete vědět, jestli proběhla funkce v pořádku? Nope. Výstupem z funkce je totiž číslo požadavku. Chybu si totiž musíte poměrně nepěkně vydlabat z exception. Další věc je čistě logická. České domény lze registrovat pouze s NSSETem. Jinak to nejde. U jiných domén se zadávají jednotlivé NS servery. U CZ domény se musí nejdříve vytvořit identifikátor držitele kontaktu. U jiných domén se vytváří při registraci domény. To se všechno může zdát jako maličkosti, ale takové věci vše zbytečně komplikují a použití takového API je spíš otrava. Přitom si myslím, že největší příliv např. domén musí být právě strojově přes API.\n\n...ale už fakt prdel!\n---------------------\nRychlá otázka k zamyšlení. Jak uděláte API, aby bylo možné jej snadno testovat? Změníte například přístupové údaje na testovací, nebo budete posílat nějaký testovací token? OK. Myšlenka je jasná. Kdykoliv se to dá snadno přehodit např. změnou jednoho hesla do ostrého režimu. Jenom v debilním API se metody pro testování jmenují jinak, než metody pro ostré použití. Kurva! To je další věc, která to celé nepříjemně zkomplikuje.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/d10561e0-aeec-4dae-a21e-17eb7c4ca36d/gif.gif)\nDobře, poslední příklad. Nedávno jsem zase něco nevyčetl z dokumentace. Napsal jsem tedy na technickou podporu ať mi poradí, že to tam nemají napsané. Konkrétně se jednalo o povolené vstupní hodnoty do jedné funkce. Na odpověď jsem čekal dva dny, což by ani tak nevadilo, ale hodně jsem se nasmál u odpovědi, která přišla v tomto formátu (původně zapsáno pod sebou):\n\n```\n'cs', 'sk', 'bg', 'hr', 'da', 'nl', 'en', 'et', 'fi', 'fr', 'de', 'el', 'hu', 'ga', 'it', 'lv', 'lt', 'mt', 'pl', 'pt', 'ro', 'sl', 'es', 'sv'\n```\n\nWhat? Takže podpora také nevěděla a tak mi poslala kus vykopírovaného zdrojového PHP kódu z aplikace? V tuto chvíli už mi začíná být všechno jedno... \n\nJde to i jinak?\n---------------\nVím, že ano, ale stále častěji mě někdo přesvědčuje o opaku. Druhé ukázkové API jsem zvolil pro porovnání také typu SOAP. V tomto API je již většina věcí na které jsem do této chvíle nadával vyřešena. Dokonce jsem potěšen z toho, že se jedná o API poměrně inteligentní a tak se mohu dotazovat hodně podobně jako v Doctrine 2. Paráda.\n\nJenže pak přijde, jak říká kolega, další jobovka. API je totiž totálně bez dokumentace, takže téměř jediné místo, kde lze získat informace o vstupních a výstupních hodnotách je prohlédnout si celý dump dané funkce. Dobře, to není problém. Vidím datum ve známém formátu jako string. Posílám tedy také datum ve stejném formátu jako string. Nic. Dobře, poslím ho jako DateTime. Nic. Až po hodně dlouhé době a nahlášeném bugu jsem dostat fuck off odpověď, že to datum zadávám špatně a musí to být v následujícím formátu:\n\n```php\n//...\narray(\n\t'year' => ...->format('Y'),\n\t'month' => ...->format('m'),\n\t'day' => ...->format('d'),\n\t'hour' => ...->format('H'),\n\t'minute' => ...->format('i'),\n)\n//...\n```\n\nA dost vole, seru na to. Na to nemám nervy. Zase ta samá otázka. Proč? Vždyť... Ale nic. Už raději nic.\n\nProsím všechny programátory, **snažte se víc**. Cílem by mělo být **usnadnit používání**, nikoliv však sobě, ale **uživatelům**. Prosím...\n\nHowgh.","frontmatter":"id: 54e244cd-2b74-4532-b36c-74a7827aa231\ntimestamp: 1405627130000\ntitle: SračkoAPI\nslug: srackoapi"},{"attributes":{"id":"d0b9d1c4-61c7-49d1-9f10-e645525a5726","timestamp":1405252851000,"title":"Novinky na blogu a extension RFC","slug":"novinky-na-blogu-a-extension-rfc"},"body":"Kdo pravidelně sleduje [můj twitter](https://twitter.com/mrtnzlml), tak už to ví. A je to skvělé! Včera jsem totiž [mergnul](https://github.com/mrtnzlml/zlml.cz/commit/b21775df522271e81302d2987ff44d5285b245eb) důležitou část tohoto blogu a tím vydal verzi 1.1 snad stable... (-: Jedná se o celkem významný krok, ale stále je to nic oproti tomu co mám v plánu. V dnešním článku bych se rád podělil o většinu zajímavých novinek a v druhé části bych rád požádat o pomoc s rozvinutím jednoho zajímavého nápadu.\n\n# Novinky v release 1.1\n\nA hned první novinka je ta nejzajímavější. Zastávám názor, že by si měl programátor za svým kódem stát a to v každé situaci. Proto jsem se rozhodl, že pustím kohokoliv do své administrace. Ostatně proč ne. Je to výzva. Rád bych však napřed požádal kohokoliv kdo najde nějakou chybu, aby mi to dal vědět na základě nepsané programátorské etikety a nesnažil se celý blog hned zničit. Zálohu mám... :-) Administraci najdete na adrese zlml.cz/admin a přístupové údaje jsou `demo / demo`. Enjoy.\n\nAčkoliv je první představená novinka asi nejzajímavější pro kohokoliv jiného, pro mě osobně je nejzajímavější nový systém vkládání obrázků. To je něco co mi na blogu dlouho chybělo. Představoval jsem si to tak, že bych obrázky jednoduše a rychle nahrál a stejně jednoduše bych je vložil do aktuálně psaného článku. A přesně to teď můžu udělat. Použil jsem [fineuploader](http://fineuploader.com/), protože je to skvělý program. Můžu AJAXově nahrávat souběžně několik obrázků s velikostí klidně až za PHP limitem `upload_max_filesize` a nebo navázat na přerušené nahrávání. To vše vlastně díky chunk uploadu. Umí toto váš blog? Zkuste si na sdíleném hostingu nahrát soubor o velikosti třeba 50MB...\n\nToto jsou dvě nejdůležitější změny, na kterých jsem v desetinkové verzi pracoval. Správa uživatelů a cool image uploader. Dále jsem udělal opět několik designových změn a fixů, ale už se nejedná o nic tak důležitého aby to stálo za řeč.\n\n# Další kroky a žádost o pomoc\n\nSvůj blog mám rád. A mám ho rád až tak, že bych byl rád, aby ho časem používal i někdo jiný. To ještě nějakou chvíli potrvá, ale už nějaký čas mi leží v hlavě nápad, jak se k tomuto požadavku přiblížit. Rád bych totiž blog přepsal do Nette extensions. Včera jsem popré [nakousl](https://github.com/mrtnzlml/zlml.cz/commit/1ffc33bc5dddbadfc1b6ce7d30dccb09938800cb) svojí myšlenku. Princip je jednoduchý. Přepíšu například funkcionalitu obrázků (nebo čehokoliv jiného) do extension a když bude někdo budovat nový blog, tak si jen v konfigu zvolí jaké moduly chce (to se dá snadno generovat):\n\n```neon\nextensions:\n\t- ImageExtension\n    - SearchExtension\n    - ...\n```\n\nSamotné extension má potom za úkol se samo spustit (`afterCompile`) a přidat nějaké funkcionality do stacku (v metodě `initialize`). V prvním nakousnutí například přidávám položku do menu a skutečně to funguje tak jak píšu. Jakmile nějakou funkci nechci, prostě ji z konfigu zruším. Výhodné na tom je to, že můžu prošpikovat blog místy, kam lze nové feature zaregistrovat a dají se velmi jednoduše provázat přes composer. **Ale.** Má to háček.\n\nKdyž jsem si s touto myšlenkou hrál jen v hlavě, tak to bylo super, protože vše fungovalo perfektně. Bohužel jsem narazil na to, že nevím jak pěkně vyřešit šablony a routování na ně. Šablony jsou totiž jedna z dalších věcí které bych zde chtěl vyřešit. Bylo by fajn, kdyby mohl mít každý možnost si třeba šablony podědit a změnit si kompletně celý design. To zase takový problém není. Ale jak vyřešit to, když chci v extension např. přidat novou stránku? Kam umístit šablonu a jak ji naroutovat? Nějak jsem to dneska v noci už nedokázal vymyslet. Máte někdo prosím nějaký zajímavý nápad? Díky...\n\nNo a naposledy už snad jenom: [Give me a star, please](https://github.com/mrtnzlml/zlml.cz)...","frontmatter":"id: d0b9d1c4-61c7-49d1-9f10-e645525a5726\ntimestamp: 1405252851000\ntitle: Novinky na blogu a extension RFC\nslug: novinky-na-blogu-a-extension-rfc"},{"attributes":{"id":"f9727676-c2eb-4ee0-b86d-8126663f007d","timestamp":1402842853000,"title":"Čteme Data Matrix bez čtečky","slug":"cteme-data-matrix-bez-ctecky"},"body":"![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/1fc11f25-abc2-453e-abb4-adb31d0ccf17/datamatrix.png)\n\nDnešním článkem navazuji na dřívější článek [Čteme QR kódy bez čtečky](cteme-qr-kody-bez-ctecky), ve kterém jsem řešil čtení QR kódu bez použití jakéhokoliv čtecího zařízení. A dnes budu řešit téměř to samé, ale s jiným kódem. Data Matrix není tolik známý, ale myslím si, že patří, hned po QR kódech, mezi nejpoužívanější kódy vůbec. Po tomto článku si jich zajisté začnete všímat více. Naposledy jsem jej viděl na balíčku od jahod... (-: Opět platí, že hlavním cílem je kód přečíst, nikoliv mu úplně porozumět, takže nebudu rozebírat velké detaily.\n\nLevý obrázek je kód o kterém bude celou dobu řeč.\n\n# Trocha nezbytné teorie\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/0dd271b6-21ea-4c3c-a447-723b76257b50/datamatrix-key.png)\n\nTento kód je oproti QR kódu velmi jednoduchý, takže i teorie bude stručná. Veškerá data a korekce chyb je ukryta uvnitř rámu, který je z části plný. To umožňuje čtečkám poznat kde všude je ještě kód a jak je natočen. Z pohledu \"ručního\" čtení je tato část nezajímavá. Modře jsou zvýrazněny 4 bity, které k ničemu neslouží a zaplňují jen prázdné místo. Ne vždy je tento úkaz vidět. Bohužel tentokrát nemám k dispozici originální specifikaci, takže nevím jakým přesným pravidlům to podléhá.\n\nNejpodstatnější jsou však červeně zarámované oblasti. Všechny mají takovýto tvar a vždy mají přesně dané umístění. Toto umístění je vlastně dáno první oblastí s číslem 2. Nicméně z hlediska umístění dat je nejdůležitější pátý bit v prvním sloupci od kterého vše startuje. Pokud obrazec přesahuje to timing zón, tedy do nažloutlého rámu, tak pokračuje na druhé straně, tedy dole, nebo na pravé straně.\n\nData se v kódu čtou podle čísel, tedy podél takové diagonální vlnovky a to až do obrazce s číslem 5. Tento obrazec určuje konec zprávy. V našem případě se tedy jedná o zprávu, která má 4 znaky. A jak už to tak bývá, tak jsou všechny znaky přenášeny v binárním formátu. Zbytek kódu, který není nijak zvýrazněn je klasicky Reed–Solomon korekce chyb. Možná bych o tomto mechanismu také mohl někdy napsat článek. Nicméně napovažuji to za úplně jednoduchá záležitost, takže si to zatím nechám v zásobě.\n\n# Hrajeme si na čtečku\n\n\nPřečíst zprávu v takto teoreticky rozebraném kódu už je otázka chvilky. Najdříve si vytáhneme všechny potřebné části. V tomto případě je zbytečné řešit pátý člen, jelikož se jedná o poslední ukončovací. Jeho hodnota je 129 v desítkové soustavě. Získané útvary jsou vidět na obrázku níže.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/76028c59-4e5f-42f4-a411-3452844a30d2/last.png)\n\nČísla určují pozici bitů v binárním čísle. Po přepsání do binární podoby mají znaky následující hodnoty:\n\n```\n01100010 01101001 01110000 01101011\n```\n\nV desítkové podobě jsou to tedy čísla:\n\n```\n98 105 112 107\n```\n\nNásledně je zapotřebí od těchto čísel odečíst jednotku. Abych řekl pravdu, tak jsem po dlouhém uvažování nedokázal přijít s rozumným vysvětlením proč se to tak dělá. Původně mě napadadlo, že je to kvůli lepšímu rozložení bitů ve výsledném obrazci. Stejně tak jako se u QR kódů bity ještě maskují. To ale nedává smysl. Je to jen posunutí o jedna. Nic víc... Nicméně je zřejmé, že spousta věcí je v takovýchto kódech minimálně na zamyšlení. Ale zpět k poslednímu kroku. Z předchozího článku již všichni vědí, že číslo 97 je v ASCII tabulce hodnota znaku **a**, takže po odečtení jednotky a přepsání do čitelné podoby získáváme řešení:\n\n```\n97 104 111 106\na  h   o   j\n```\n\nTento kód je pro čtení bez čtečky daleko snadnější, komplikuje to jen nezvyklé uspořádání bitů. Jaký další kód bych měl dostat pod drobnohled? Snad to půjde. Mám zde totiž rozpracovaný ještě jiný a nemohu k němu sehnat normu pro nahlédnutí, takže jsem se zatím zasekl... (-:","frontmatter":"id: f9727676-c2eb-4ee0-b86d-8126663f007d\ntimestamp: 1402842853000\ntitle: Čteme Data Matrix bez čtečky\nslug: cteme-data-matrix-bez-ctecky"},{"attributes":{"id":"76a53072-7779-478d-9557-c9f855ebce4d","timestamp":1402601786000,"title":"Disqus lazy loading","slug":"disqus-lazy-loading"},"body":"Tento článek ve skutečnosti odstartovalo zdánlivě nesouvisející vlákno na [Nette fóru .{target:_blank}](http://forum.nette.org/cs/19397-ako-sa-zbavit-fid-v-url-ak-sa-nemylim). V tomto vláknu se řeší parametr *_fid* v URL adrese, který tam Nette framework přikládá kvůli flash messages. Tato vlastnost někoho skutečně hodně štve, mě zase až tak moc ne. Jenže když jsem nad tím vláknem chvíli seděl, tak jsem si uvědomil, že mám komentářový systém Disqus implementovaný špatně. Čtěte dál a vyhněte se stejné chybě... (-:\n\n# Univerzální kód\n\nDisqus poskytuje \"by default\" univerzální kód, který prakticky pouze zkopírujete na svůj web na požadované místo a je hotovo. Tento kód vypadá zhruba takto:\n\n```html\n<div id=\"disqus_thread\"></div>\n<script type=\"text/javascript\">\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n    var disqus_shortname = ''; // required: replace it with your forum shortname\n\n    /* * * DON'T EDIT BELOW THIS LINE * * */\n    (function() {\n        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n    })();\n</script>\n<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n```\n\nJe to pohodlné, ale je to úplně blbě. Nejenom pro Nette aplikace, ale myslím si, že tak nějak celkově pro všechny aplikace. Fungovat to sice bude, to ano. Ale jen tak zdánlivě. Problém je totiž v tom, že toto nastavení bere jako identifikátor diskuse URL adresu a pokud se jen drobně změní, tak se založí nová diskuse. Přehled těchto diskusí je pak vidět v Disqus administraci. To s sebou nese celou řadu problémů. Diskuse nejde pořádně zamknout a už to, že k jedné stránce může být více diskusí je problém. Každá diskuse totiž musí mít unikátní identifikátor [disqus_identifier .{target:_blank}](https://help.disqus.com/customer/portal/articles/472098-javascript-configuration-variables) nezávisle na parametrech (pokud ovšem tyto parametry nejsou žádoucí).\n\n# Lazy loading\n\nJá jsem sice nepoužil defaultní konfiguraci, ale udělal jsem prakticky tu samou chybu. Teď ale konečně k lazy loadingu. Na svém blogu to již používám dlouhou dobu a myslím si, že se to již osvědčilo. Inspirací k mé implementaci je [tento gist .{target:_blank}](https://gist.github.com/omgmog/2310982).\n\nStačí umístit následující kód do nějakého souboru *main.js*, který se spouští po načtení stránky:\n\n```javascript\nvar disqus_div = $(\"#disqus_thread\");\nif (disqus_div.size() > 0) {\n    var ds_loaded = false,\n    top = $('.load_disqus').offset().top, //upravit podle potřeby\n    disqus_data = disqus_div.data(),\n    check = function () {\n        if (!ds_loaded && $(window).scrollTop() + $(window).height() > top) {\n            ds_loaded = true;\n            for (var key in disqus_data) {\n                if (key.substr(0, 6) == 'disqus') {\n                    window['disqus_' + key.replace('disqus', '').toLowerCase()] = disqus_data[key];\n                }\n            }\n            var dsq = document.createElement('script');\n            dsq.type = 'text/javascript';\n            dsq.async = true;\n            dsq.src = 'http://' + window.disqus_shortname + '.disqus.com/embed.js';\n            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n        }\n    };\n    $(window).scroll(check);\n    check();\n}\n```\n\nTím to však nekončí. Je samozřejmě nutné určit kde se Disqus bude zobrazovat:\n\n```html\n<div class=\"hidden-print\">\n\t<div id=\"disqus_thread\" data-disqus-shortname=\"mrtnzlml\" data-disqus-url=\"{link //this}\"></div>\n\t<noscript>Please enable JavaScript to view the <a href=\"http://disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n\t<a href=\"http://disqus.com\" class=\"dsq-brlink\">comments powered by <span class=\"logo-disqus\">Disqus</span></a>\n</div>\n```\n\nKlíčový je zde právě data atribut *disqus-url*. No a aby byl kod kompletní, tak je zapotřebí někam umístit CSS trídu *.load_disqus*. Tu doporučuji umístit někam nad diskusi a tím myslím třeba o celou viditelnou stránku. Disqus se tak začne načítat o něco dříve, než k němu čtenář doscrolluje, takže se stihne načíst a nebude to rušit. Ve výsledku se tedy Disqus nenačítá po otevření stránky, takže je načtení svižné, ale po např. přečtení článku je již načtený...\n\nA co vy? Máte Disqus na svém webu implementovaný správně? (-:","frontmatter":"id: 76a53072-7779-478d-9557-c9f855ebce4d\ntimestamp: 1402601786000\ntitle: Disqus lazy loading\nslug: disqus-lazy-loading"},{"attributes":{"id":"167331c6-491d-45bd-8c29-02877a349cb3","timestamp":1400490051000,"title":"Stáhněte si lepší blog","slug":"stahnete-si-lepsi-blog"},"body":"Čas od času se na Nette fóru najde někdo, kdo hledá vzorový projekt do kterého by se mohl podívat. Vlastně se většinou hledá cokoliv, jakákoliv inspirace. Bohužel se zřejmě všichni bojí toho, že o svůj projekt přijdou, protože v něm někdo najde bezpečnostní chybu. Já se toho také bojím, ale lepší než před tím utíkat je se tomu postavit čelem. A tak je to tady.\n\n# Kdokoliv cokoliv\n\nK dispozici je pro nahlédnutí tento blog. A nejen k nahlédnutí, ale také k [volnému používání](develop).\nNa pozadí běží hned několik technologií, které si můžete prakticky osahat:\n\n+ Nette Framework ([nette.org .{target:_blank}](http://nette.org/))\n+ Nette Tester ([tester.nette.org .{target:_blank}](http://tester.nette.org/))\n+ Texy *(je sexy)* ([texy.info .{target:_blank}](http://texy.info/))\n+ FSHL ([fshl.kukulich.cz .{target:_blank}](http://fshl.kukulich.cz/))\n+ Webloader ([addons.nette.org .{target:_blank}](http://addons.nette.org/janmarek/webloader))\n+ Kdyby\\Doctrine 2 ([GitHub](https://github.com/Kdyby/Doctrine))\n\nK dispozici je i databáze, protože si myslím, že bych se i s únikem databáze neměl nijak ohrozit... :-) Účelem tohoto nápadu a následně rozhodnutí je poskytnout pokud možno funkční a aktivní projekt, který staví právě na těchto technologiích. Důvodem je pak moje zkušenost s tvrdým začátkem. Mám příležitost občas pracovat s někým kdo se přesně toto chce naučit, bohužel pár lidí už to prostě vzdalo, protože je toho *moc* a není mnoho lidí kteří skutečně pomohou (rozhodně ne na fóru). Snažím se tedy zaplnit toto prázdné místo a nabídnout tento blog jako jeden z možných začátků. Mimochodem neříkám, že moje řešení je nejlepší, nebo správné. Je jedno z možných a funkčních. Stáhnout si jej můžete ze své oblíbené verzovací služby:\n\n```html\n<div class=\"row\" style=\"margin-top:50px;margin-bottom:50px\">\n\t<div class=\"col-lg-6 col-md-6 col-sm-6 text-right\">\n\t\t<a class=\"btn btn-default\" href=\"https://bitbucket.org/mrtnzlml/zlml.cz\" target=\"_blank\">\n\t\t\t<img src=\"/img/loga/bitbucket.png\">\n\t\t</a>\n\t</div>\n\t<div class=\"col-lg-6 col-md-6 col-sm-6\">\n\t\t<a class=\"btn btn-default\" href=\"https://github.com/mrtnzlml/zlml.cz\" target=\"_blank\">\n\t\t\t<img src=\"/img/loga/github.png\">\n\t\t</a>\n\t</div>\n</div>\n```\n\nPodrobnější popis najdete na [samostatné stránce](develop) věnované tomuto projektu. Byl bych moc rád, kdybych touto cestou pouze nenabídl něco chybějícího, ale také získal zpětnou vazbu. Nestojím o pochvaly. Ty samozřejmě potěší, ale mnohem přínosnější jsou praktické poznámky k implementaci, nebo funkcím. Nad takovou věcí se vždy rád zamyslím...","frontmatter":"id: 167331c6-491d-45bd-8c29-02877a349cb3\ntimestamp: 1400490051000\ntitle: Stáhněte si lepší blog\nslug: stahnete-si-lepsi-blog"},{"attributes":{"id":"34ecd347-57b2-4e4f-9a99-b77edbec7df1","timestamp":1399974862000,"title":"Znovupoužitelný formulář","slug":"znovupouzitelny-formular"},"body":"Každý kdo nějakou chvíli pracuje s Nette Frameworkem již jistě narazil na prvky, které lze použít v aplikaci opakovaně. Říkejme jim znovupoužitelné komponenty, nebo prostě jen komponenty. Následující text má za úkol ukázat opět maximálně prakticky a uceleně jedno z možných řešení jak k tomuto problému přistupovat a co se mi na tomto řešení líbí, nebo naopak nelíbí.\n\n# Motivace\n\nProč vůbec přemýšlet o komponentách? Na tuto věc má pravděpodobně dost lidí zcela jiný názor. Pro mě je havní motivací to, že si vyčistím presentery. Chci toho mít v presenterech skutečně tak akorát. Vždyť podle MVP struktury bych v presenterech neměl mít nic složitého. A pak je zde ta znovupoužitelnost. Co když se rozhodnu, že potřebuji použít stejný formulář na více místech? Přece ho nebudu kopírovat. A že takový požadavek je sice často někdo zmíní, ale prakticky není moc reálný? Ale kdepak. Zrovna nedávno jsem vytvářel mnoho stránek a na každé jsem chtěl mít právě kontaktní formulář. To je požadavek na komponentu jako dělaný...\n\n# Presenter\n\nVždy když programuji něco takového, tak se nedívám na to, jak je to správně z hlediska OOP a bůh ví čeho všeho ještě. Pro mě je v současné chvíli klíčové to, jak se dané řešení bude používat. Přesenter by tedy mohl vypadat třeba takto:\n\n```php\n<?php\n\nclass AdminPresenter extends BasePresenter {\n\n\t/** @var \\ActualityFactory @inject */\n\tpublic $actualityFactory;\n\n\tprivate $id;\n\n\tpublic function actionAktualita($id = NULL) {\n\t\t$this->id = $id;\n\t}\n\n\tprotected function createComponentForm() {\n\t\t$control = $this->actualityFactory->create($this->id);\n\t\t$control['form']->onSuccess[] = function () {\n\t\t\t$this->redirect('default');\n\t\t};\n\t\treturn $control;\n\t}\n\n}\n```\n\nMám tedy presenter, který je například pro administraci a jednu podstránku, která bude sloužit jak pro editaci aktuality, tak i pro přidání nové aktuality. Proto je parametrem *action* právě `id = NULL`. Tim totiž říkám, že může přijít jako parametr *ID* aktuality (v tom případě ji budu chtít upravovat), nebo toto *ID* nebude předáno a v tom případě bude hodnota *NULL* a budu s tím později patřičně nakládat.\n\nV poslední metodě si daný formulář vytvořím. Teoreticky by stačila pouze první řádka. Přidávám však ještě další chování do pole `onSuccess[]`, protože chci komponentu používat na více místech, ale pokaždé po úspěchu přesměrovat na jinou stránku. Zde je jedna z věcí které se mi nelíbí. A to je právě to volání `$control['form']->onSuccess[] = ...`. Musím totiž vědět jak je pojmenovaný formulář uvnitř komponenty, což mě ale je skutečnosti vůbec nezajímá. Mnohem raději bych byl třeba za zápis `$control->onSuccess[] = ...`. Chápu, že se nemusí použít komponenta pouze na fomulář, ale přesto. **Neznáte někdo lepší řešení?**\n\nA teď přijde záludná otázka. Co je to ta factory a proč jí vlastně používám?\n\n# Factory\n\nProtože v komponentách velmi často potřebuji nějaké závislosti, musím je tam nějak dostat. K tomu slouží například generované továrničky. Jedná se vlastně pouze o interface:\n\n```php\n<?php\n\ninterface IActualityFactory {\n\n\t/** @return \\Cntrl\\Actuality */\n\tpublic function create();\n\n}\n```\n\nNette se této továrničky chytí a vytvoří zhruba tento kód:\n\n```php\n<?php\n\nfinal class SystemContainer_IActualityFactoryImpl_58_IActualityFactory implements IActualityFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Nette\\DI\\Container $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create() {\n\t\t$service = new Cntrl\\Actuality;\n\t\treturn $service;\n\t}\n\n}\n```\n\nZde je tedy (když bude potřeba) možné vytvořit nějaké závislosti a v metodě `create()` je komponentě předat. To vše lze udělat automaticky a Nette se o to postará. Dokonce lze předávat i parametry z konfiguračního souboru. Je to nesmírně elegantní řešení. Kdybych továrničky nepoužil, musel bych vytvářet ručně komponentu, to by ale znamenalo, že bych také musel předávat všechny závislosti ručně a jen bych si tím přidělal práci. Zkuste si vytvořit komponentu bez použití factory. Je nesmysl tahat si v presenteru nepotřebné závislosti přes presenter... Jak však předat parametry z presenteru? Netuším, jestli to lze nějak generovanou továrničku naučit, nic nám však nebrání napsat si vlastní factory:\n\n```php\n<?php\n\nclass ActualityFactory extends Nette\\Object {\n\n\tprivate $actualities;\n\n\tpublic function __construct(App\\Actualities $actualities) {\n\t\t$this->actualities = $actualities;\n\t}\n\n\tpublic function create($id) {\n\t\treturn new \\Cntrl\\Actuality($this->actualities, $id);\n\t}\n\n}\n```\n\nJe jasně vidět, že tato ručně napsaná factory vypadá velmi podobně jako automaticky vygenerovaná, ale navíc teď můžu předat metodě `create($id)` parametr, což je přesně to co potřebuji viz presenter. Chci si předat číslo aktuality a nevidím důvod proč bych to měl dělat až v komponentě. Komponenta potřebuje *ID* aktuality, ale kde ho vezme nemusí řešit. Je otázka, jestli bych si už rovnou neměl vytáhnout data z databáze v presenteru. Takto se mi to ale zatím líbí víc...\n\nRučně vytvořenou factory musíme ještě zaregistrovat v konfiguračním souboru:\n\n```neon\nservices:\n\t- ActualityFactory\n```\n\nTo je vše. Už jsme pouze krůček od funkčního formuláře.\n\n# Samotná komponenta\n\nSamotný kód komponenty už není téměř ničím zvláštní, nebo nějak nepochopitelný:\n\n```php\n<?php\n\nnamespace Cntrl;\n\nuse App;\nuse Entity;\nuse Nette\\Application\\UI;\nuse Nette;\n\nclass Actuality extends UI\\Control {\n\n\tprivate $actualities;\n\tprivate $actuality;\n\n\tpublic function __construct(App\\Actualities $actualities, $id) {\n\t\tparent::__construct();\n\t\t$this->actualities = $actualities;\n\t\t$this->actuality = $this->actualities->findOneBy(['id' => $id]);\n\t}\n\n\tpublic function render() {\n\t\t$this->template->setFile(__DIR__ . '/Actuality.latte');\n\t\t$this->template->render();\n\t}\n\n\tprotected function createComponentForm() {\n\t\t$form = new UI\\Form;\n\t\t$form->addText('headline', 'Titulek:');\n\t\t$form->addTextArea('text', 'Text:');\n\t\t$form->addSubmit('send', 'Uložit');\n\t\tif($this->actuality) { //výchozí hodnoty jen pokud aktualita již existuje\n\t\t\t$form->setDefaults(array(\n\t\t\t\t'headline' => $this->actuality->headline,\n\t\t\t\t'text' => $this->actuality->text,\n\t\t\t));\n\t\t}\n\t\t$form->onSuccess[] = $this->actualityFormSucceeded;\n\t\treturn $form;\n\t}\n\n\tpublic function actualityFormSucceeded(UI\\Form $form) {\n\t\t$values = $form->getValues();\n\t\ttry {\n\t\t\tif(!$this->actuality) { //pokud ještě neexistuje vytvořím novou entitu\n\t\t\t\t$this->actuality = new Entity\\Actuality();\n\t\t\t}\n\t\t\t$this->actuality->headline = $values->headline;\n\t\t\t$this->actuality->text = $values->text;\n\t\t\t$this->actuality->date = new \\DateTime();\n\t\t\t$this->actualities->save($this->actuality);\n\t\t\t$this->presenter->flashMessage('Aktualita byla úspěšně uložena.', 'success');\n\t\t} catch (\\Exception $exc) {\n\t\t\t$this->presenter->flashMessage($exc->getMessage(), 'danger');\n\t\t}\n\t\t//žádný redirect, až v presenteru!\n\t}\n\n}\n```\n\nV konstruktoru jednak získám nějakou modelovou třídu pro práci s databází (o to se krom factory  vůbec nestarám) a také *ID*, které přišlo z presenteru. A rovnou toto *ID* použiju k vytáhnutí si dat z databáze, protože konstruktor se spustí vždy a já také vím, že tyto data budu vždy potřebovat. V `render()` metodě pouze předám šablonu komponenty, která ve své nejprimitivnější podobě může vypada pouze takto:\n\n```\n{control form}\n```\n\nOstatně stejný kód mohu použít pro šablonu do které předávám komponentu z presenteru. Výsledkem celého snažení je tedy poměrně jednoduchý přesenter a jedna stránka na které je formulář, který zvládne jak editaci, tak vytváření nového záznamu v databázi.\n\nPoužíváte nějaké lepší (jiné) řešení? Podělte se o něj... :-)","frontmatter":"id: 34ecd347-57b2-4e4f-9a99-b77edbec7df1\ntimestamp: 1399974862000\ntitle: Znovupoužitelný formulář\nslug: znovupouzitelny-formular"},{"attributes":{"id":"b4aa1f09-6047-4f30-a609-5ffbf61fc6c0","timestamp":1397388682000,"title":"Plzeňský Barcamp - láska na první pohled","slug":"plzensky-barcamp-laska-na-prvni-pohled"},"body":"Ačkoliv jsem z dřívějších barcampů sledoval záznamy, tak jsem byl fakticky na barcampu úplně poprvé a rovnou jsem měl tu čest přednášet. Než se však dostanu k samotné přednášce, rád bych zde napsal nějaký feedback. Celkově jsem z Plzeňského Barcampu skutečně nadšen. Skvělá atmosféra, fajn lidi, spoustu jídla, alkoholu možná až moc... :-))\n\nNa druhou stranu došlo i k pár přešlapům. Některé mě mrzí více, jiné ani tak ne, každopádně... Skutečně mě mrzí to, že nebyla nahrávána na video každá přednáška.\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p><a href=\"https://twitter.com/eshopkonzultant\">@eshopkonzultant</a> Honzo, máme to v plánu. Pokud nám ho nic nenaruší, chtěli bychom určitě záznamy dodat nejdéle do měsíce po skončení akce.</p>&mdash; Plzeňský Barcamp (@PlzenskyBarcamp) <a href=\"https://twitter.com/PlzenskyBarcamp/statuses/454275681665687552\">April 10, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nTo se moc nepovedlo. Mrzí mě to ze dvou důvodů. Jednak jsem tak nějak slíbil, že má přednáška bude potom na netu, to však není ten závažnější problém. Daleko více mě mrzí fakt, že se teď nemohu podívat na přednášky ostatních protože jsem byl jinde. Na barcampu bylo totiž spoustu zajímavých témat.\n\nDalší už jen krátce abych nezněl moc negativně, protože se mi na barcampu opravdu líbilo a zase tak moc mě tyto věci neštvou. Přístup k netu jen pro přednášející. Měl jsem možnost toho využít, nevyužil jsem, takže o nic nejde, jen bych veřejnou wifi na takových akcích čekal. Další jsou samolepky se jménem při registraci. No já nevím jak ostatním, mě prostě vůbec nedržela a než jsem došel do prvního patra, tak jsem měl na zádech jmenovku se jménem Martina. Bohužel bez čísla. Zdravím Martinu! :-) Poslední věc, která mě mohla dost uzemnit byla ztracená prezentace. Svojí prezentaci jsem na barcamp odeslal předem jak stálo v emailu, ale když jsem se po ní ptal, tak nebyla k nalezení. Naštěstí jsem měl plán B. Uff...\n\n# Přednášky\n\nPostupně jsem se snažil projít ty nejzajímavější přednášky. Zde je jejich přehled:\n\n*Machine learning, aneb od našeptávače k porozumění řeči ([Jan Švec .{target:_blank}](https://twitter.com/honza_svec)*) - přednáška o strojovém učení, porozumění řeči a chápání významu psaného i mluveného textu. Některým lidem tato přednáška přišla obsahově zajímavá a skutečně byla, každopádně tyto informace jsem z velké většiny již znal, protože jsem je slyšel již dříve a zase tolik se toho v tomto oboru nemění.\n\n*Procesory letajici, tikajici, hrajici a komunikujici ([Radek Voltr .{target:_blank}](https://twitter.com/crawlerdev)*) - to je zase opak toho prvního. Některým lidem to nepřišlo moc zajímavé, protože tyto věci znají. Já je tolik neznám a i z důvodu svých budoucích prací do školy pro mě byla tato přednáška přínosným přehledem toho jak lze nacpat slušný výpočetní výkon na malou mršku.\n\n*Virtualizace a cloudy v dnešním IT ([Milan Brych .{target:_blank}](http://www.orgis.cz/cs/)*) - nejvíce debatované a kontroverzní téma. Každopádně Milan se toho ujal dobře a ačkoliv tam bylo spoustu lidí z oboru, tak i v publiku došlo k debatám lidí s naprosto odlišným názorem. A zpětně musím dodat, že jednoznačně souhlasím s tím, že cloud jako takový je cloudem teprve tehdy, pokud je geograficky rozložen a má dostatečnou redundanci strojů. Někdo na přednášce zmiňoval cloud funkci u NAS serverů. V tu chvíli jsem se musel pousmát...\n\n*Věrnostní program a jeho odvrácená tvář ([Marek Mencl .{target:_blank}](https://twitter.com/mmencl)*) - asi nejlepší přenáška. Zpětný pohled za projektem, který sice nějak dopadl, ale jeho průběh nebyl úplně hladký. Přednáška byla plná reálných problémů z praxe. Super. Prostě super. Jestli bude záznam, tak doporučuji!\n\n*Pracujte v trenýrkách z kavárny. Nebo ne? ([David Šmehlík .{target:_blank}](https://twitter.com/davidsmehlik)*) - abych byl upřímný, tak na tuto přednášku jsem šel jen proto, že jsem neměl kam jinam a vybral jsem tak nejmenší zlo. Každopádně rychle jsem zjistil, že jsem udělal dobře, protože celé povídání bylo velmi zajímavé a motivující. I přes původní nedůvěru považuji tuto přednášku za druhou nejlepší. Sorry, Marek byl lepší... :-))\n\n*O e-shopech, o automatickém výpočtu nabídek za prokliky na Heurece a o tom, kde je problém doopravdy ([Michal Janík .{target:_blank}](https://twitter.com/michaljanik)*) - zde to bylo celkem jednoduché. Jít na populární blbost (dle zpětných názorů ostatních), nebo na SEO (jak slyším SEO, tak utíkám), nebo na prezentaci neúspěšného portálu? Vybral jsem si tedy přednášku o e-shopech. Nejsem eshopista, takže to pro mě nemělo takovou přidanou hodnotu a myslím si, že kdokoliv nad problémy obchodu přemýšlí, tak dokonverguje ke stejným závěrům jako jsou v prezentaci. Každopádně říct, že to bylo nezajímavé by bylo nejen nefér, ale ani by to nebyla pravda.\n\nOpět musím zopakovat, že mě mrzí absence kamer u ostatních přednášek.\n\n# Od Caesara ke QR kódům\n\nA konečně k mé přednášce. :-))\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Přednáška o kódování a Thomasu Youngovi na <a href=\"https://twitter.com/search?q=%23barcampcz&amp;src=hash\">#barcampcz</a> je kulervoucí.</p>&mdash; Pavel Pajkrt (@PavelAbbePajkrt) <a href=\"https://twitter.com/PavelAbbePajkrt/statuses/455008230444638208\">April 12, 2014</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nA zde je:\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/33460846\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe>\n\nDěkuji všem posluchačům. Byl jsem skutečně nadšen, když za mnou pak někdo v průběhu dne přišel a děkoval. To bylo kouzelné. Nesmírně si toho vážím. Každopádně abych se jen nevychvaloval, tak cítím určitý dluh vůči posluchačům, protože ačkoliv se mi s tím Luboš Majner i Milan Brych snažili pomoct (díky!), tak jsem nedokázal závěrečnou problematiku úplně objasnit. A vzhledem k tomu, že jsem se pak ještě o těchto věcech několikrát bavil, tak přibližně tuším v čem byly problémy.\n\nTak prvně padl dotaz z kterého bylo jasné, že jsem něco řekl fakt špatně. Proč to šifrovat tak složitě? Proč neposlat rovnou surovou zprávu, když to nejde odposlechnout? To je velice jednoduché. Je sice pravda, že (alespoň v současné době) kvantový signál nelze odposlechnout, nic však nebrání Evě zastřelit Boba a zprávu si jednoduše přečíst. To se u šifrovaného signálu nemůže stát.\n\nA jak je tedy možné že ten signál nelze odposlechnout? Jde o to, že přenášená zpráva není ve formě informace, ale přenáší se pomocí nějakého fyzikálního principu. Takže se nelze připojit na optický kabel aniž by to nebylo zjistitelné. Každopádně jsem rád za závěrečnou diskusi, jelikož byla velmi přínosná a uvědomil jsem si věci, které jsem předtím neřešil. Například komunikaci po veřejném kanálu a ověření, že Alice skutečně mluví s Bobem a ne s Evou. Přečtěte si článek tento [http://aldebaran.cz/bulletin/2005_14_kry.php .{target:_blank}](http://aldebaran.cz/bulletin/2005_14_kry.php). Konkrétně poslední část o spolehlivosti metody. Již rozumím padlým dotazům a dávám posluchačům za pravdu. Beru to jako poučení a příští rok už budu tento problém schopen podat ještě líp. Doufám... :-)\n\nJo a přišel si to poslechnout i David Grudl. Yaaay! :-D","frontmatter":"id: b4aa1f09-6047-4f30-a609-5ffbf61fc6c0\ntimestamp: 1397388682000\ntitle: Plzeňský Barcamp - láska na první pohled\nslug: plzensky-barcamp-laska-na-prvni-pohled"},{"attributes":{"id":"73daaba4-4b37-440f-b4e7-375de01a03c8","timestamp":1394985629000,"title":"Orion login stojí za prd","slug":"orion-login-stoji-za-prd"},"body":"Když jsem dříve připravoval [prezentaci o Nette Frameworku](prednaska-z-nette-na-zcu), hledal jsem nějaký vhodný příklad, na kterém bych demonstroval zranitelnost webových aplikací. Úspešně jsem vyzkoušel pár eshopů a jednu stránku, která slouží ke školním účelům, ale není nijak oficiálně vedená pod univerzitou. Právě zde mě napadlo vyzkoušet také univerzitní systémy. A nestačil jsem se divit.\n\n# Pozadí univerzitního přihlašování\n\nVeškeré ověřování práv a identit putuje přes WebKDC server. Tento server komunikuje s Kerberosem a dohromady tvoří systém, který umožní přihlášení pomocí univerzitních loginů. Celkově proti tomuto systému nemám vůbec nic. Mám však hodně výhrad k jeho konkrétní implementaci. Konkrétní web servery (tam kde jsou umístěny aplikace vyžadující přihlášení) komunikují se vzdáleným WebKDC serverem. Tento server zajistí korektní ověření uživatele (spolupráce s Kerberos) a vráti informaci o úspěšném ověření. Paráda. Vnitřně velmi sofistikovaný systém funguje a umožňuje SSO (Single Sign-On) napříč celou infrastrukturou. Platí to tedy i pro aplikace mimo univerzitní doménu. Zjednodušeně popsáno, ale tématem tohoto článku není ta část, která [spolehlivě funguje](http://webauth.stanford.edu/), ale ta část, která nefunguje.\n\n```\n WEBKDC <----------> KERBEROS\n   |||\n   |||\n WEBAUTH (server s aplikací vyžadující přihlášení)\n    |\n    |\n STUDENT\n```\n\nJako poměrně zásadní fakt vidím to, že dokud student neklikne na \"LOGIN\", tak ho tento systém nepřihlásí (většinou). Nachází se tedy na úrovni \"WEBAUTH\", ale vidí jen omezenou stránku. Jakmile se chce přihlásit, aplikace jej přesměruje na WebKDC login-server, kde může vyplnit své přihlašovací informace, nebo je již přihlášen někdy z dřívější doby a v obou případech je přesměrován zpět na server s webovou aplikací. Už vidíte ten problém? :-)\n\n# XSS\" onclick=\"alert(document.cookie); //:-)\n\nPrávě komunikace mezi WEBAUTH a WEBKDC je pro ověření naprosto zásadní, ale díky tomu, že zřejmě není nastavena žádná implementační laťka, tzn. že kdokoliv chce přihlašovat pomocí tohoto systému tak si to prostě nějak naprogramuje, vznikají bezpečnostní bublinky. Pravděpodobně neexistuje žádná konvence jak tento systém implementovat, takže neexistují ani takové funkce, jako je třeba ověřování již aktivního přihlášení atd. Může se tedy stát, že budu přihlášen (ověřen) ve webové aplikaci, ale na WEBKDC jsem odhlášen, protože WEBAUTH už se o to v tuto chvíli nestará (ten je přihlášen).\n\nDíky tomuto poznatku mohu velmi jednoduše vše co jsem teď napsal zapomenout, protože se dá celé složité schéma zjednodušit na toto:\n\n```\n WEBAUTH                   WEB-APP\n    |          resp.          |\n    |                         |\n STUDENT                   STUDENT\n```\n\nTak moment. Není to úplně normální přihlášení tak jako je na jakékoliv jiné úplně obyčejné stránce? Uživatel (student, profesor, administrátor) je přihlášen a teď už je to pouze nudná otrocká práce. Myslím, že mohu prozradit, že je stránka (čti univerzitní projekty) náchylná na session hijacking, na to přijde každý blbec, který o tom četl na wiki. A asi nemá smysl tajit, že XSS je naprosto reálná (a vyzkoušená) hrozba. Nebudu však říkat kde. A vzhledem k tomu, že tento systém webových portálů (IBM Web-Sphere Portal) není žádná domácí výroba, tak předpokládám, že stejný problém budou mít i další univerzity.\n\n```\n WEB-APP1     WEB-APP2\n    |            |\n    |----------EVA\n STUDENT\n```\n\nOd první chvíle, kdy jsem na tento problém upozorňoval poprvé jsou některé věci v současné době na serverech pozměněny, ale to zásadní zůstává pořád stejné. Nezáleží na tom co je v pozadí, když je řetěz tak silný, jak je silný jeho nejslabší článek a zvlášť, když ten silný zbytek řetězu skoro ani není potřeba...","frontmatter":"id: 73daaba4-4b37-440f-b4e7-375de01a03c8\ntimestamp: 1394985629000\ntitle: Orion login stojí za prd\nslug: orion-login-stoji-za-prd"},{"attributes":{"id":"6f2ba373-daf2-4569-bbd7-09e437f18975","timestamp":1394562840000,"title":"Sbohem NDBT, vítej Doctrine","slug":"sbohem-ndbt-vitej-doctrine"},"body":"Byl jsem požádán, abych napsal nejenom důvod přechodu z Nette Database na Doctrine, ale obecně co mě k tomu vedlo a jak takový přechod vlastně učinit. Na úvod bych však chtěl zdůraznit, že nejsem žádný extra programátor, vlastně to ani nestuduji, takže vše co budu ukazovat a vysvětlovat je tedy z mého pohledu a lecjakého OOP znalce by tento text mohl pobouřit... (-:\n\nNásledující text používá [Kdyby\\Doctrine](https://github.com/Kdyby/Doctrine), nevidím důvod proč ve spojení s Nette používat něco jiného. Je to dobrá knihovna.\n\n# Sbohem NDBT\n\nNette Database Table a obecně celé Nette Database je úžasná část frameworku a spokojeně jsem ji používal po velmi dlouhou dobu. Nikdy jsem neholdoval pokřikům, že je NDBT zabugované (jako někteří) a i když jsem vyzkoušel i jiné alternativy, vždy jsem se spokojeně vracel právě k NDBT. Použití je velice intuitivní a dobře se s tím zachází:\n\nModel:\n```php\nclass Posts extends Nette\\Object {\n\n\t/** @var \\Nette\\Database\\Context */\n\tprivate $database;\n\n\tpublic function __construct(Nette\\Database\\Context $context) {\n\t\t$this->database = $context;\n\t}\n\n\tpublic function getAllPosts() {\n\t\treturn $this->database->table('posts')->where('release_date < NOW()');\n\t}\n\n}\n```\n\nPresenter:\n```php\nclass HomepagePresenter extends BasePresenter {\n\n\t/** @var \\Posts @inject */\n\tpublic $posts;\n\n\tpublic function renderDefault() {\n\t\t$this->template->posts = $this->posts->getAllPosts();\n\t}\n\n}\n```\n\nJe to jednoduché a jasné. Takové věci mám prostě rád. V modelové třídě mám jak select metody, tak insert metody, takže bych tomu správně neměl říkat repository, ale abych byl upřímný, tak je mi toto názvosloví celkem volné. Do takové objektu si prostě dám to co chci (tak jak mi to dává smysl). Nepřijde mi to vůbec podstatné. Tahání dat z databáze má však ještě jednu vrstvu a tou je vykreslování.\n\n```html\n{foreach $posts as $post}\n\t<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n\t<p>\n\t\t{foreach $post->related('posts_tags')->order('tag_id ASC') as $post_tag}\n\t\t\t<a n:href=\"Tag:default, $post_tag->tag->name\">\n\t\t\t\t<span style=\"background: #{$post_tag->tag->color}\">{$post_tag->tag->name}</span>\n\t\t\t</a>\n\t\t{/foreach}\n\t\t{$post->body|truncate:450}\n\t</p>\n{/foreach}\n```\n\nA to je věc, která mě dlouhou dobu trápila. Dá se čekat, že když v databázi existuje jakási vazba mezi příspěvkem a tagem, tak že tuto vazbu budu chtít nějak využít. A to pokud možno co nejvíce pohodlně. A co nejvíce pohodlně znamená, že v okamžik, kdy budu pracovat s příspěvkem a vzpomenu si, že potřebuji také tagy, tak tyto tagy také dostanu. Bohužel musím znát také spojovací tabulku, která nemá (minimálně v tomto případě) žádný faktický smysl a celkově práce s takto \"dopřivázanou\" tabulkou není vůbec pohodlná a už vůbec ne intuitivní. Dává to smysl a asi to tak být musí, takže proti NDBT žádná, ale tak nějak vnitřně jsem hledal něco lepšího (čti více vyhovujícího mým požadavkům).\n\n# Vítej Doctrine\n\nSchválně se snažím vše popisovat podle mých myšlenkových pochodů, proto i nadále budu řešit úplně ten samý problém, jen s použitím Doctrine. Nutno ještě dodat, že Doctrine rozhodně nebyla jasná volba. Opět mi dlouho trvalo, než jsem obecně ORM přišel na chuť. Ještě před Doctrine jsem nějakou dobu experimentoval s [Lean Mapperem](http://www.leanmapper.com/) od Vojtěcha Kohouta (Tharos). Malou nevýhodou je, že téměř veškerá dokumentace je v brutálně dlouhém vláknu na Nette fóru, které má v tuto chvíli **1023 příspěvků**, takže je to občas dřina, ale myslím si, že je to skutečně povedená knihovna. Vojtěch Kohout má skutečně dobré myšlenky. Nicméně jsem prostě chtěl přijít Doctrine na chuť, takže jsem i Lean Mapper opustil. Občas dělám radikální změny, pokud by však někdo vyloženě potřeboval důvod k tomu začít s Doctrine (alespoň dočasně), pak tedy jeden mohu nabídnout. A bude velmi krátký. Vidíte někdy jako požadavek na zaměstnance znalost Lean Mapperu, nebo ActiveRow? Pokud ne, tak začněte s tím co se tam ukazuje často. Doctrine.\n\nAle zpět k tématu. Pojďme si ukázat modelovou část podle mě:\n```php\nclass Posts extends Nette\\Object {\n\n\t/** @var \\Kdyby\\Doctrine\\EntityDao */\n\tprivate $dao;\n\n\tpublic function __construct(Kdyby\\Doctrine\\EntityDao $dao) {\n\t\t$this->dao = $dao;\n\t}\n\n\tpublic function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null) {\n\t\treturn $this->dao->findBy($criteria, $orderBy, $limit, $offset);\n\t}\n\n}\n```\n\nVelmi podobné jako u předchozího modelu. Asi by šlo si napsat nějakou `__call` metodu, protože se dost často volá to co už je v DAO objektu (viz níže), ale kdo si to jak poslepuje, tak to bude mít... A co prezentační vrstva?\n```php\nclass HomepagePresenter extends BasePresenter {\n\n\t/** @var \\Posts @inject */\n\tpublic $posts;\n\n\tpublic function renderDefault() {\n\t\t$posts = $this->posts->findBy(array());\n\t}\n\n}\n```\n\nTo je také dost podobné. Pole kritérií potom slouží k dodatečnému filtrování ve tvaru např. `['id' => 21]`, tedy předává se to, co se má použít i v SQL WHERE klauzuli. Tento zápis je mi poměrně blízký, protože jsem ho používal při komunikaci s jedním SOAP serverem. Ok, co na to šablona?\n\n```html\n{foreach $posts as $post}\n\t<h3><a n:href=\":Single:article $post->slug\">{$post->title|vlna}</a></h3>\n\t<p>\n\t\t{foreach $post->tags as $tag}\n\t\t\t<a n:href=\"Search:default, $tag->name\">\n\t\t\t\t<span style=\"background: #{$tag->color}\">{$tag->name}</span>\n\t\t\t</a>\n\t\t{/foreach}\n\t\t{$post->body|truncate:450}\n\t</p>\n{/foreach}\n```\n\nTak to je podle mě úplně super výsledek. Maximálně intuitivní a nic víc splňuje to má očekávání. Je však asi zřejmé, že jsem úplně vypustil jakoukoliv informaci o spojovací tabulce. A také jsem ještě neřekl, co je to `EntityDao`, se kterým se pracuje v modelu. Vlastně je to úplně jednoduché. V konfiguračním souboru definuji, že chci pracovat s jakýmsi DAO objektem, tedy objektem, který oproti repository umožňuje data nejen číst, ale také ukládat (opět pouze OOP slovíčkaření).\n\n```neon\nservices:\n\t- App\\Pictures(@doctrine.dao(Entity\\Picture))\n\t- App\\Posts(@doctrine.dao(Entity\\Post))\n\t- App\\Tags(@doctrine.dao(Entity\\Tag))\n\t- App\\Users(@doctrine.dao(Entity\\User))\n```\n\nFajn, teď mám tedy v každé modelové třídě DAO objekt. Ten obsahuje několik metod, které výrazně usnadňují práci s Doctrine ([source](https://github.com/Kdyby/Doctrine/blob/master/src/Kdyby/Doctrine/EntityDao.php)). Do tohoto objektu předávám jakousi entitu. To je objekt, který reprezentuje strukturu databázové tabulky. To možná není napsáno úplně šťastně, ale prakticky to tak skutečně většinou je. Taková entita může vypadat například takto:\n\n```php\nnamespace Entity;\n\n/**\n * @ORM\\Entity\n * @ORM\\Table(name=\"posts\")\n */\nclass Post extends Doctrine\\Entities\\BaseEntity {\n\n\t/**\n\t * @ORM\\ManyToMany(targetEntity=\"Tag\", inversedBy=\"posts\", cascade={\"persist\"})\n\t * @ORM\\JoinTable(name=\"posts_tags\")\n\t * @ORM\\OrderBy({\"name\" = \"ASC\"})\n\t */\n\tprotected $tags;\n\n\t/**\n\t * @ORM\\Id\n\t * @ORM\\Column(type=\"integer\")\n\t * @ORM\\GeneratedValue\n\t */\n\tprotected $id;\n\n\t/** @ORM\\Column(type=\"text\") */\n\tprotected $title;\n\n\t/** @ORM\\Column(type=\"text\") */\n\tprotected $slug;\n\n\t/** @ORM\\Column(type=\"text\") */\n\tprotected $body;\n\n\t/** @ORM\\Column(type=\"datetime\") */\n\tprotected $date;\n\n}\n```\n\nZde je právě důležité to, že rovnou ukazuji, kde je entita reprezentující tagy (která vypadá podobně jako tato), jak se k ní dostanu a dokonce jak se má řadit. Tedy všechny tyto informace jsem ze šablony odstranil. Pro mě je to tedy úžasný pokrok, protože jsem dosáhl toho co jsem chtěl. Aby se mi s databází pracovalo dobře.\n\n# No dobře, ale...\n\nA teď je právě čas na některé dotazy, které vznikly při přípravě tohoto článku. Tak například co když chceš položit vlastní dotaz, v Nette Database je to přeci snadné. V Doctrine [také](https://bitbucket.org/mrtnzlml/www.zeminem.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/Posts.php?at=master&fileviewer=file-view-default#Posts.php-128). V tom by ORM nemělo nijak zásadně bránit...\n\nDalší věc je, že v presenteru stále zůstává jistá závislost na struktuře tabulek. Konkrétně opět mluvím o poli kritérií. Jak se úplně zbavit této závislosti a mít pokud možno vše tak, aby když změním strukturu, tak to změním jen někde a ne všude? K tomu se dají použít třeba query objekty, které v sobě drží podobu potřebného SQL dotazu, takže místo toho, abych stále ťukal ten samý dotaz, jen jinde, tak jej schovám do třídy a právě tu pak používám. Budoucí změna se pak pravděpodobně bude týkat právě pouze toho objektu a případně entit. Ono toto asi nejde úplně odstínit (nebo spíš nevím jak), protože vždy je potřeba data i nahrávat a tedy stanovit určitou hranici mezi tím co je závislé na databázi a co už není. Nicméně uvážím-li, že budu měnit strukturu tabulky třeba kvůli tomu, že chci přidat nová data, stejně budu do kódu muset jít a někde ty data vzít a někam je dát. Proto je toto možná úplně zbytečné řešit, protože tato závislost nikdy nepůjde úplně odstranit.\n\nDalší věc je trošku záludná. Týká se tříd pro vazební tabulky. Pokud tedy ukládám M:N vazbu jako v předchozím textu, tím myslím, že mi jde pouze o to, že chci uložit do této tabulky cizí klíče, tak se o nic nemusím starat a stačí mi pouze onen dokumentační komentář v entitě `Post` nad proměnnou `protected $tags`, kde je definováno vše potřebné. Problémové je, když chci uložit data i do vazební tabulky. Zde bych rád citoval jeden příspěvek ze StackOverflow, protože si myslím, že tam je vše řečeno naprosto přesně.\n\n> A Many-To-Many association with additional values is not a Many-To-Many, but is indeed a new entity, since it now has an identifier (the two relations to the connected entities) and values.\n\nA přesně takto je s tím tedy potřeba zacházet. Už se nebavíme o vazební tabulce. Už se bavíme o normální tabulce, která vyžaduje svoji entitu a pouze obsahuje dva cizí klíče místo běžného jednoho.\n\nDoufám, že se mi v tomto článku svojí délkou limitně blížící se k nekonečnu podařilo zodpovědět všechny dotazy a objasnit všechny pochybnosti. Pokud ne, můžete se na celou problematiku podívat pod drobnohledem ještě [zde](https://bitbucket.org/mrtnzlml/zlml.cz/src/05dc03f0781fac574de26e128b6509d870b7b789/app/model/?at=master). Máte na celou problematiku jiný názor, nebo to jak to dělám já je kompletně špatně? Sem s tím... (-:","frontmatter":"id: 6f2ba373-daf2-4569-bbd7-09e437f18975\ntimestamp: 1394562840000\ntitle: Sbohem NDBT, vítej Doctrine\nslug: sbohem-ndbt-vitej-doctrine"},{"attributes":{"id":"372c259c-4339-437d-b5e5-af02fe0d9dae","timestamp":1393877713000,"title":"AJAX upload souborů v Nette pomocí Fine Uploaderu","slug":"ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2"},"body":"[Dříve](ajax-upload-souboru-v-nette-pomoci-fine-uploaderu) jsem psal o tom, jak použít Fine Uploader jakožto nástroj pro AJAXové nahrávání souborů na server. Původní článek však platí pouze pro verzi `3.*`, která je dnes již zastaralá. Pojďme si dnes ukázat v podstatě to samé, ale pro novější verzi `4.3+`, která se v učitých směrech poměrně zásadně liší od svého předchůdce. Tentokrát se to však pokusím vyřešit co nejjednodušeji.\n\nZačátek je vlastně úplně stejný. Musíme nalinkovat javascriptové soubory:\n\n```html\n<!-- jQuery -->\n<script src=\"{$basePath}/js/jquery.fineuploader-4.3.1.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n```\n\nPoužití je úplně jednoduché, ve zjednodušené formě:\n\n```html\n<div id=\"image-uploader\"></div>\n```\n\nSnažím se ukázat opravdu jen kritické minimum, protože ty základní věci jsou stejné, případně dohledatelné v dokumentaci, takže se dají oba dva návody z velké části doplnit. Minule jsem však zatáhl do ukázek i poměrně hodně balastu, takže ten u staré verze nechám, ale bude následovat opravdu jen to nejnutnější.\n\nStejně tedy jako v předchozí verzi následuje javascriptový spouštěcí kód. Zde již vznikají určité odlišnosti:\n\n```javascript\n$(function () {\n\t$('#image-uploader').fineUploader({\n\t\tdebug: true, //hodí se pro lazení\n\t\trequest: {\n\t\t\tendpoint: 'pictures?do=uploadPicture'\n\t\t},\n\t\tretry: {\n\t\t\tenableAuto: true\n\t\t}\n\t});\n});\n```\n\nPoužití je tedy téměř stejné, až na to, že jsem úplně vypustil překlad textů. V této nové verzi jsou totiž novinkou šablony (ostatně proto také nové číslo verze). Uživatel-programátor má tak více pod kontrolou výsledný vzhled uploaderu:\n\n```html\n<script type=\"text/template\" id=\"qq-template\">\n\t<div class=\"qq-uploader-selector qq-uploader\">\n\t\t<div class=\"qq-upload-drop-area-selector qq-upload-drop-area\" qq-hide-dropzone>\n\t\t\t<span>Přetáhněte soubory sem</span>\n\t\t</div>\n\t\t<div class=\"qq-upload-button-selector qq-upload-button\">\n\t\t\t<div>Klikněte, nebo přetáhněte obrázky</div>\n\t\t</div>\n        <span class=\"qq-drop-processing-selector qq-drop-processing\">\n           <span>Zpracovávám přetažené soubory...</span>\n           <span class=\"qq-drop-processing-spinner-selector qq-drop-processing-spinner\"></span>\n        </span>\n\t\t<ul class=\"qq-upload-list-selector qq-upload-list\">\n\t\t\t<li>\n\t\t\t\t<div class=\"qq-progress-bar-container-selector\">\n\t\t\t\t\t<div class=\"qq-progress-bar-selector qq-progress-bar\"></div>\n\t\t\t\t</div>\n\t\t\t\t<span class=\"qq-upload-spinner-selector qq-upload-spinner\"></span>\n\t\t\t\t<img class=\"qq-thumbnail-selector\" qq-max-size=\"100\" qq-server-scale>\n\t\t\t\t<span class=\"qq-edit-filename-icon-selector qq-edit-filename-icon\"></span>\n\t\t\t\t<span class=\"qq-upload-file-selector qq-upload-file\"></span>\n\t\t\t\t<input class=\"qq-edit-filename-selector qq-edit-filename\" tabindex=\"0\" type=\"text\">\n\t\t\t\t<span class=\"qq-upload-size-selector qq-upload-size\"></span>\n\t\t\t\t<a class=\"qq-upload-cancel-selector qq-upload-cancel\" href=\"#\">Zrušit</a>\n\t\t\t\t<a class=\"qq-upload-retry-selector qq-upload-retry\" href=\"#\">Opakovat</a>\n\t\t\t\t<a class=\"qq-upload-delete-selector qq-upload-delete\" href=\"#\">Smazat</a>\n\t\t\t\t<span class=\"qq-upload-status-text-selector qq-upload-status-text\"></span>\n\t\t\t</li>\n\t\t</ul>\n\t</div>\n</script>\n```\n\nA opět následuje zpracování v handleru:\n\n```php\npublic function handleUploadPicture() {\n\t$uploader = new \\UploadHandler();\n\t$uploader->allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\");\n\t$result = $uploader->handleUpload(__DIR__ . '/../../www/uploads');\n\t$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse($result));\n}\n```\n\nZde celkem není co pokazit, ale pokud by bylo potřeba vrátit chybu, provede se to opět pomocí `JsonResponse`:\n\n```php\n$this->sendResponse(new Nette\\Application\\Responses\\JsonResponse(array(\n\t\t'error' => $exc->getMessage(),\n)));\n```\n\nSamotná třída `UploadHandler` je pak opět k nalezení na [GitHubu](https://github.com/Widen/fine-uploader-server/blob/master/php/traditional/handler.php). Tento návod tedy mohu zakončit vlastní citací:\n\n> A to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například podle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit. To konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.","frontmatter":"id: 372c259c-4339-437d-b5e5-af02fe0d9dae\ntimestamp: 1393877713000\ntitle: AJAX upload souborů v Nette pomocí Fine Uploaderu #2\nslug: ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2"},{"attributes":{"id":"ef0027e0-1814-4c1f-9fcd-395b68cfcb85","timestamp":1393588145000,"title":"Čteme QR kódy bez čtečky","slug":"cteme-qr-kody-bez-ctecky"},"body":"![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/2139a61c-efc4-4e3c-b630-5c3cbf9258df/qrcode-ahoj.png)\n\nPatříte mezi lidi, kteří se nespokojí pouze se čtečkou QR kódů, ale chcete vědět jak fungují? Nebo co víc jak je přečíst bez použité takové čtečky? Tak to jste na správné adrese. Dnes budu řešit zejména právě čtení QR kódu bez použití čtečky. Celou dobu budu řešit tento QR kód na levé straně, takže doporučuji nepoužívat telefon a počkat až na konec, kde se jeho obsah dozvíte. Zároveň se nebudu nijak opírat o korekci chyb a další jinak důležité věci, ale budu se co nejvíce soustředit právě na přečtení kódu bez použití jakéhokoliv přístroje. Pojďme na to...\n\n# Trocha nezbytné teorie\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/312d5904-ab94-4877-9743-8ec902fbc50a/qrcode-parts.png)\n\nQR kód asi viděl každý. Stejně tak předpokládám, že spoustu lidí tuší, že QR kód dodržuji určitá pravidla, aby jej šlo přečíst strojově. Jedná se zejména o \"finder pattern\", tedy ty velké čtverce, které slouží k zaměření čtečky a určení orientace kódu. Díky tomu, že jsou tři, tak lze QR kód přečíst i pokud je vzhůru nohama. Dalším významným prvkem jsou separátory, které obklopují právě tyto čtverce a slouží k oddělení zaměřovačů od zbytku kódu. Žlutě jsem zvýraznil tzv. \"timing patterns\". Ty se táhnout z rohu do rohu zaměřovacích čtverců, kdy se celou dobu střídá černá a bílá barva a slouží opět pro čtečky například k určení velikosti celého kódu. Na takto malém kódu nejsou žádní informace i verzi, ani korekční body.\n\nNejdůležitější jsou však červené a zelené části. Zde jsou uloženy informace i formátu, které následně také využijeme. Je zajímavé, že se jak červená část, tak zelená část na kódu vždy dvakrát opakuje. Informace je očíslována čísly 1-15 s tím, že kolem levého horního zaměřovače je informace celá a ta samá informace je ještě rozdělena a umístěna kolem zbylých dvou zaměřovačů. Je zde ještě jedna zajímavost. V levém dolním rohu nad číslem 9 je černé místo, tzv. \"dark module\". Toto místo by mělo být na všech kódech černé. Jedná se přebytečné místo, které vzniká při zdvojování informace o formátu. Podle specifikace by to tak mělo být, ale ne vždy to platí. Pro nás je však zajímavá jediná část z celé 15 bitů dlouhé informace a to konkrétně bity umístněné na pozici 11, 12 a 13, tedy v zelené části. Právě ty si nesou tu nejdůležitější informaci o masce. Všechny ostatní části informace slouží ke korekci chyb. Celkově se ve výsledku ukáže, že kromě samotné informace je v QR kódu sloustu \"zbytečných\" věcí, které informaci nenesou. V mašem případě je tedy maska `111` (černé místo je 1 a bílé 0). Tuto informaci je však ještě potřeba dekódovat pomocí XOR součtu přičtením hodnoty `101`, tedy:\n\n```\n111\n101 /XOR\n---\n010\n```\n\nCelá dekódovací maska je `101010000010010`, ale pro naší potřebu je potřeba pouze část `101`. Ještě než vysvětlím co to maska je, uvedu zde všechny hodnoty jaké může maska mít:\n\n<table class=\"table table-bordered\">\n  <thead>\n    <tr><td>Hodnota masky</td><td>Podmínka masky</td></tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>000</td>\n      <td>(i + j) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>001</td>\n      <td>i mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>**010**</td>\n      <td>**j mod 3 = 0**</td>\n    </tr>\n    <tr>\n      <td>011</td>\n      <td>(i + j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>100</td>\n      <td>((i div 2) + (j div 3)) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>101</td>\n      <td>(i j) mod 2 + (i j) mod 3 = 0</td>\n    </tr>\n    <tr>\n      <td>110</td>\n      <td>((i j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n    <tr>\n      <td>111</td>\n      <td>((i+j) mod 2 + (i j) mod 3) mod 2 = 0</td>\n    </tr>\n  </tbody>\n</table>\n\nTo může vypadat děsivě, ale hned vysvětlím. Podle toho jakou má kód masku vezmeme vzorec a dosadíme za **j** číslo sloupce. V našem případě se tedy bavíme o prvním a pak každém třetím sloupci. Pro tyto sloupce platí, že na nich musíme provést negaci, tedy otočit barvy. Tím QR kód odmaskujeme. Toto však platí pouze pro částí kde je opravdu nějaká informace, nikoliv pro zaměřovače, nebo například části nesoucí formátovací informaci. Toto maskování slouží k zamíchání barevných polí. Nestane se tak, že by byl kód nejednoznačný. Při kódování se totiž porovnávají jednotlivé masky, každá maska má nějaké skóré jednoznačnosti a ve výsledku se vybere ta nejjednoznačnější. Celé odmaskování je znázorněno na obrázku níže. Pravý černý QR kód je již odmaskovaný a nic nebrání jej přečíst. V tuto chvíli však již pouze bez použití čtečky.\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/63e85abb-b86a-4877-9640-fb70b4cd2542/qrcode-important.png)\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/3951a3ea-5f53-4af9-9c01-a45fd71dd5b0/qrcode-unmasked.png)\n\n# Hrajeme si na čtečku\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/0ed74ba7-ddec-40da-ab12-4e6b8d82103c/qrcode-decode.png)\n\nPředchozí část byla možná trošku složitější, ale když se na to podíváte zpětně je to vlastně velice jednoduché. Stačí přečíst 3 bity z celého kódu, provést jednoduchý XOR a jak se ukáže dále, tak stačí invertovat pouze jeden sloupec, protože více jich není potřeba.\n\nPodívejte se nyní na levý obrázek. Ten ukazuje, jak budeme číst uloženou informaci. Barevně znázorněná část je kompletní informace. Zbytek kódu je pro nás v tuto chvíli jen odpad. Barevně zvýrazněná část se ještě dělí na tři podčásti. Červená oblast obsahuje informaci o módu. Bity čteme vždy podle čísel a šipek. Tento QR kód je tedy v módu `0100` což je mód \"BYTE\". Data tedy budeme rozdělovat tak, aby měla každý část 1 byte, tedy 8 bitů. Tyto módy a další informace jsou velmi podrobně popsány v oficiální dokumentaci. Modrá část nám ještě prozrazuje informaci o délce, binárně tedy `00000100` což je v desítkové soustavě číslo 4. Takže informace v tomto QR kódu má délku 4 znaky. Opíšeme si tedy řadu bitů:\n\n```\n01100001 01101000 01101111 01101010\n```\n\nZde by mohl být trošku zádrhel pro lidi, co neumí ASCII tabulku. Prozradím tedy malý fígl. Pokud binární čásla prevedeme do decimální soustavy, což je velmi jednoduché, získáme následující zápis:\n\n```\n97 104 111 106\n```\n\nA teď už je to jen posunutá abeceda, protože číslo 97 je malé **a**. Výsledkem je tedy po chvilce abecedování:\n\n```\na h o j\n```\n\nTo nebylo tak těžké, že? Je to sice absurdní a pravděpodobně nikdy nikoho neuvidím s tužkou a papírem před QR kódem, ale i tak si myslím, že je dobré tyto věci vědět, když už se QR kód používá tak často. Doporučuji všem přečíst si dokument *ISO/IEC 18004:2006*, který řeší právě QR kódy. Je to nesmírně zajímavý dokument plný obrázků a úplných popisků, ačkoliv je i v tomto dokumentu pár drobných chyb.","frontmatter":"id: ef0027e0-1814-4c1f-9fcd-395b68cfcb85\ntimestamp: 1393588145000\ntitle: Čteme QR kódy bez čtečky\nslug: cteme-qr-kody-bez-ctecky"},{"attributes":{"id":"2f77a602-c2d5-4dd1-baee-d033fedad75e","timestamp":1393074151000,"title":"Omyly hashování hesel","slug":"omyly-hashovani-hesel"},"body":"Někdy minulý rok jsem si četl prezentaci [Michala Špačka .{target:_blank}](http://www.michalspacek.cz/) o [hashování hesel .{target:_blank}](http://www.slideshare.net/spaze/hashe-hesla-develcz-2013) a byl jsem z toho poněkud zklamán. Naprosto souhlasím se vším co tam je, přesto však nemám rád, když se dojde k závěrům, které sice na první pohled dávají smysl a fakt dobře se tak dá argumentovat, ale ve výsledku jsou podle mého názoru některé opravdu chybné. Nedávno kolem mě tato prezentace proplula znova a protože již mám celkem setříděné myšlenky, rozhodl jsem se je sepsat.\n\nTímto článkem nehodlám hatit již zmíněnou prezentaci. Naopak se chci opřít do všech prezentací a výstupů, které něco tvrdí a není to tak docela pravda. Zároveň je také nutno říct, že nebudu řešit funkce typu MD5, protože doufám, že všichni v dnešní době vědí, že funkce MD5 prostě není určena na hashování hesel. Přesto si neodpustím několik vět i o konkrétních implementačních problémech.\n\n# Omyl první\n\nKdyž jsem se opět dožadoval matematického důkazu o problému cyklického hashování, byl jsem dokázán na [stackoverflow .{target:_blank}](http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/17396367#17396367), což mě mělo uspokojit. Četl jsem to pozdě v noci, takže jsem to nechal na ráno a ani tak jsem s tím nesouhlasil.\n\nV podstatě se jedná o popsání preimage útoku, který se snaží najít stejný hash jako je hash známý a tím získat původní (nebo jinou fungující) hodnotu hesla, tedy v tuto chvíli jediný zajímavý způsob. Celý důkaz toho, že cyklické hashování není dobrý nápad je prováděn na vlastní funkci a směšně malé množině vstupů. To je první divná věc. Mnohem divnější však je závěr pokusu, který tvrdí, že nekonečný vstup lze namapovat na konečnou množinu. Jedná se tedy o surjektivní zobrazení první množiny na druhou, kdy se každý prvek z první množiny namapuje na všechny prvky menší výstupní podmnožiny. A právě v tomto kroku vidím celou teoretickou úvahu jako chybnou. Žádná hashovací funkce totiž nepočítá s libovolným, nebo dokonce s nekonečným vstupem. Když to rozvedu i na konkrétní funkci MD5, pak nekonečný počet vstupů mapuji na 2^128 výstupů. Reálně (což je to co nás primárně zajímá) však mapuji 2^64 vstupů na 2^128 výstupů (čti bitů). V tu chvíli se však bavíme o injektivním zobrazení, což bylo v původním textu odsouzeno. Jak jsem k tomumo názoru došel? Vycházím z [RFC 1321 - The MD5 Message-Digest Algorithm .{target:_blank}](http://www.faqs.org/rfcs/rfc1321.html)\n\n> A 64-bit representation of b (the length of the message before the\n> padding bits were added) is appended to the result of the previous\n> step. In the unlikely event that b is greater than 2^64, then only\n> the low-order 64 bits of b are used. (These bits are appended as two\n> 32-bit words and appended low-order word first in accordance with the\n> previous conventions.)\n\nPak už je jen malý krůček k tomu uvědomit si, že 2^64 bitové heslo je jinak řečeno něco kolem 2 exabajtů, což je tak trošku hodně i na uložení, natož na zapamatování. A i kdybych to spočetl blbě - jakože doufám, že ne - několik řádů sem tam je úplně jedno, protože množina na kterou se to mapuje je daleko větší. Stejně tak mi přijde naprosto komická tato ukázka:\n\n```\n$output = md5($input); // 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n$output = md5($output); // < 2^128 possibilities\n```\n\nPřepíšu to jinak:\n\n```\n$output = md5($input); // 340282366920938463463374607431768211456 possibilities\n$output = md5($output); // 340282366920938463463374607431768211455 possibilities\n$output = md5($output); // 340282366920938463463374607431768211454 possibilities\n$output = md5($output); // 340282366920938463463374607431768211453 possibilities\n$output = md5($output); // 340282366920938463463374607431768211452 possibilities\n```\n\nVycházíme tedy z 340 undecilionů 282 decilionů 366 nonilionů 920 octilionů 938 septilionů 463 sextilionů 463 quintilionů 374 quadrilionů 607 trilionů 431 bilionů 768 milionů 211 tisíc 456 možností. Jasné? Tuto teorii tedy považuji za čistě teoretickou. Klidně si to heslo zašifrujte undecilionkrát... Ostatně stejný problém byl při šifrování vždy. Klidně se mohlo stát, že klíč od zprávy zašifrované v Enigmě (nebo kdekoliv jinde) uhodnou. Ale nedělalo se to, protože je to prostě jen papírový nesmysl. Ostatně i když se to stane, tak je to prostě debilní smůla, jenže věří snad ještě někdo tomu, že se to stane u celé databáze?\n\n# Omyl druhý\n\nNyní budu předpokládat, že bude nyní mým cílem zjistit skutečně takové heslo, jaké bylo před zahashováním. Úplně tím tedy odbourám fakt, že dva různé texty budou mít stejný hash. To se může stát, druhá možnost však bude svým charakterem tak úplně jinde, že ji stejně nepůjde např. při přihlašování použít. Pokud tedy chci zjistit heslo z hashe u kterého vím, že bylo několikrát hashováno, nezbývá mi, než jít postupně z hashe až k heslu:\n\n```\n7eaefb28c9c3fe4be6997cc5b7fb599f // původní hash\n92b7db0f6d7348d91e90651d31ff9e71\n651a9c9c86f3116a53e2bb6e80bfdf69\n1b929b62a2c822c4a59e688fde2a3a0b\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n```\n\nJenže jaké teď skutečné heslo? Je to \"heslo\"? Pokud bych byl chytrý a uměl si zapamatovat 32 znaků, moje heslo by určitě bylo \"1b929b62a2c822c4a59e688fde2a3a0b\" a jen bych zmátl všechny okolo. A potom je celkem sranda to, když se vrátíme k čistě teoretickému uvažování a řekněme, že se může stát, že dva hashe budou totožné:\n\n```\n1b929b62a2c822c4a59e688fde2a3a0b // původní hash   <-\n... // dlouhá série hashů vedoucích k opakování     |\n651a9c9c86f3116a53e2bb6e80bfdf69                    |-- stejné hashe\n1b929b62a2c822c4a59e688fde2a3a0b   <-----------------\n955db0b81ef1989b4a4dfeae8061a9a6\nheslo // konec hledání, toto již není MD5\n```\n\nVěřte, že mé heslo je teď \"651a9c9c86f3116a53e2bb6e80bfdf69\". Při pokusu o zjištění původu hashe mám dvě možnosti. Mohu najít takový hash, který je před tím prvním, ale jiný než \"955db0b81ef1989b4a4dfeae8061a9a6\", nebo právě \"955db0b81ef1989b4a4dfeae8061a9a6\". V prvním případě je to stejné jako předchozí případ. V druhém však naleznu nejdříve jinou shodu a nejen že dojdu k jinému heslu, ale také úplně přeskočím to správné heslo. Takže v určitém případě může být opakované hashování dokonce ještě bezpečnější! Opět je to pouze teorie, ale chci tím ukázat, že některé argumenty mohou být sice silné, mají však vždy i obrácenou stranu, která není o nic slabší...\n\nChtěl jsem tedy vyvrátit několik zažitých předpokladů, což se mi doufám podařilo. Musím však dodat nesmírně důležitou věc. Neobhajuji zde použití MD5 ani jiné podobné funkce (která tak jako MD5 není k hashování hesel určena). Používejte spíše funkce, které mají složitou výpočetní náročnost a jejich výstup je pro dva stejné vstupy různý. Takovou dobrou funkcí je pro PHP funcke `password_hash`, která byla vytvořena právě kvůli tomu, že v tom programátoři dělají neskutečný bordel. Použití je úplně jednoduché:\n\n```php\n<?php\necho password_hash('heslo', PASSWORD_DEFAULT);\n```\n\nTato funkce momentálně používá bcrypt, do budoucna je možné použít konstantu PASSWORD_BCRYPT, protože defaultní konstanta může způsob šifrování změnit na nějaký lepší. Stejně jednoduché je i ověření hesla:\n\n```php\nif (password_verify('heslo', '$2y$10$2YOiYB9vFd11vTRBtqqKE.TnrT1ydXuCGsSHXbAKRvUgnpE9VaoES')) {\n    echo 'Password is valid!';\n} else {\n    echo 'Invalid password.';\n}\n```\n\nTyto funkce, stejně tak jako dobře použitý kompatibilní `crypt` považuji za naprosto dostatečná řešení a víc se o tom není třeba již <s>nikdy</s> bavit. Tečka.\n\n<span style=\"color:green\">A pod tečkou ještě něco. Čím musím napravit nešťastně volená slova v předchozí větě. Tím že se o tom není již třeba nikdy bavit je myšleno to o čem se ve větě píše, tedy že bcrypt funkce považuji za naprosto dostatečné (v současné době i blízké budoucnosti) a za tím si stojím. Neznamená to však, že teď házím za hlavu celou tuto problematiku. Pokud bych měl tedy předchozí větu opravit, napsal bych asi, že tyto funkce považuji za naprosto dostatečné, nicméně stále má smysl tuto problematiku řešit, protože věřím, že v zřejmě ne malém horizontu let bude i tato funkce nedostatečná. Teď ale není.</span>","frontmatter":"id: 2f77a602-c2d5-4dd1-baee-d033fedad75e\ntimestamp: 1393074151000\ntitle: Omyly hashování hesel\nslug: omyly-hashovani-hesel"},{"attributes":{"id":"3d580b09-b622-4a72-a912-a2205994b051","timestamp":1392999129000,"title":"Jaký email je nejvíce využívaný?","slug":"jaky-email-je-nejvice-vyuzivany"},"body":"Včera jsem psal o bezpečnostní chybě, která umožňuje získat podle mého názoru nezanedbatelně velký vzorek emailových adres. Krom toho, že bych byl rád, aby byla tato chyba opravena, nemám co jiného s touto kolekcí adres dělat. Tak jsem se rozhodl vytvořit nějakou statistiku. Svým způsobem se totiž jedná o dosti specifické uživatele, protože se pravděpodobně jedná z naprosté většiny pouze o ČR a SK uživatele, takže kdo čeká, že bude např. gmail umístěn nějak dobře, možná bude překvapen.\n\nA protože po diskusích krouží mnoho rádoby matematiků, rád bych teď přesně definoval všechny vstupní a výstupní hodnoty včetně jejich chyb, čímž doufám minimalizuji to, že výsledky někdo špatně pochopí. Všechny data jsou brány z kolekce čítající **384 392 unikátních** emailových adres s tím, že uvažuji zejména u rozložení poskytovatelů emailových schránek chybu 1%. Je to dáno tím, že vstupní data nejsou úplně korektní a ukazuje se, že se dost často vyskytují emaily jako `@seznam.czsms`, `@seznam.cztel`, `@seznam.czwww`, `@seznam.czweb`, `@senam.cz` atd. Většinu takových prohřešků jsem se snažil eliminovat, každopádně není to dokonalé. Osobně bych chybu odhadoval na desetiny, možná ani ne setiny procenta, ale raději ji nechávám větší. Tato chyba je v prvním grafu také graficky znázorněna. Zajímavé je také to, že někteří lidé evidentně chápu input pro zadání emailu jako deník, takže jsou schopni napsat do tohoto řádku všechny své emailové adresy. Stojí za zamyšlení jak správně navrhovat formuláře... Dále jsou pak z výpočtů zastoupení četnosti znaků prvních písmen emailových adres vypuštěny čísla, takže tato dílčí statistika počítá s o něco menší vstupní kolekcí 382 338 emailových adres.\n\n# Rozložení poskytovatelů emailových schránek\n\nNásledující graf ukazuje počet emailových adres příslušejících ke konkrétní doméně. Konkrétně je zobrazeno prvních 20 největších poskytovatelů a i tak již mají poslední méně než jedno procento velikosti prvního, tedy Seznamu. Ten je v českém zastoupení naprosto bezkonkurenční. Všímejte si prosím takových věcí. Většina programátorů se totiž potkává pouze s lidma \"od gmailu\", ale to je na českém trhu pouze minoritní složka. A je to tak u všeho. Je až překvapivě obrovský nepoměr mezi tím co si většina lidí myslí a skutečností. A tento vzorek již považuji za dostatečnou skutečnost.\n\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=744207493\" seamless frameborder=0 scrolling=no></iframe>\n\nKolikrát jsem slyšel, že jsou Centrum a Atlas mrtvé projekty. To už ani nemá smysl počítat, ale reálně se ukazuje, že tomu tak vůbec není a těmto číslům momentálně věřím, protože už je zde přehazuji několik desítek hodin... (-: Bohužel nemám představu o tom, kolik existuje emailových adres v ČR, ale veřím, že se tvarově graf moc nepohne. Pouze se bude měnit počet na svislé ose.\n\n# Další zajímavá data\n\nDalší graf ukazuje skutečně velkou hloupost. Ani nevím proč jsem jí vlastně dělal. Jde o početné zastoupení prvních znaků emailových adres. To jsou ty modré pruhy. Červené pruhy jsou pak předpokládaná četnost znaků pro českou abecedu podle [Jana Králíka .{target:_blank}](http://www.czech-language.cz/alphabet/alph-prehled.html). Není to poprvé co tuto tabulku četností používám a dá se říci, že s ní souhlasím. Každopádně mám v plánu tyto četnosti ověřit a zaktualizovat, takže se možná tento graf časem malinko pozmění.\n\n<iframe height=371 width=600 src=\"//docs.google.com/spreadsheets/d/1nWEt95Hd8CFxrwylUJr8uUFtceN6QiGMLL3JilW3ETQ/gviz/chartiframe?oid=1555577201\" seamless frameborder=0 scrolling=no></iframe>\n\nDalší informací, která již však nemá pevně uchopitelný základ je počet TLD. Lze tedy pouze říci, že ze vzorku zkoumaných dat, tedy ze vzorku emailových adres českých uživatelů mají největší zastoupení koncovky `.cz` (290311), poté `.sk` (88764) a další v pořadí je `.com` (5183), která se však svojí četností již poněkud mimo hru. Zajímavé teké je, že většinu překlepů dělají češi. To může být tím, že jsme prostě nepozorní, nebo jsou programátoři lajdáci. Tato informace je založena na počtu korekcí doménových názvů.\n\nPoslední již nikterak využitelnou informací je délka adres. Nejdelší adresy jsou `butovice.zlicine.tel.728222069.pouzite.kalhotky@...`, `www.malirstvi.tym.czemail.malirstvi.hruby@...` a `martin.59kenvelo400500600300700800900201@...` Zakrývám alespoň domény, aby někdo neprskal, když už proti tomu tak zbrojím. Naopak nejkratší je adresa, která má se vším všudy 8 znaků: `in@.....`.\n\nZajímá vás ještě nějaká informace, která se dá z této kolekce emailových adres získat?","frontmatter":"id: 3d580b09-b622-4a72-a912-a2205994b051\ntimestamp: 1392999129000\ntitle: Jaký email je nejvíce využívaný?\nslug: jaky-email-je-nejvice-vyuzivany"},{"attributes":{"id":"52dfa065-130b-4c37-81aa-289bd6ceee9e","timestamp":1392936502000,"title":"Kde se berou spamy?","slug":"kde-se-berou-spamy"},"body":"<div class=\"alert alert-info\">Tento článek navazuje na článek [Stáhněte si zdarma 897457 emailových adres](stahnete-si-zdarma-897457-emailovych-adres) z ledna tohoto roku. Přečtěte si jej prosím, ať víte o co jde.</div>\n\nRád bych tímto všechny čtenáře poprosil o pomoc. Ačkoliv na internetu vystupuji veřejně a nemám s tím problém, jsem velmi háklivý na to, když někdo neoprávněně zneužívá mé osobní informace. Někteří přijmou moji žádost a problém odstraní - viz nedávno zrušená kopie tohoto blogu. Někteří však dělají všechno proto, abych pokračoval v rituálním podpalování válečné sekery a proto jsem neskončil tam kde jsem v minulém článku přestal psát.\n\n# Trnitá cesta plná překážek\n\nJe již známá věc, že jistý web má nemalou zásluhu na šíření reklamních emailů křížem krážem. Vzhledem k tomu, že takové email dorazil i ke mě a vzhledem k tomu, že upoutal moji pozornost, začal jsem zbrojit. Při prvních pokusech jsem oťukával jejich systém abych zjistil o co jde. Zde jsem mimo jiné udělal mylný myšlenkový pochod a vše jsem svedl na někoho kdo s tím nemá nic společného. Každopádně po několika minutách jsem měl celkem jasno a udělal jsem velkou chybu. Popsal jsem bezpečnostní chybu reklamního systému na G+, na což někdo velmi rychle zareagoval a já jsem dostal na tento reklamní server ban. Doufám, že to byla jen náhoda...\n\nToto řešení mi přišlo poněkud směšné, a tak jsem do tohoto systému přes IP anonymizér šťoural stále více. V tuto chvíli jsem to prakticky zabalil, protože chyba byla tak nějak opravena. Systém již při odhlašování nezobrazoval emailovou adresu, takže již nešlo použít něco jako:\n\n```php\npreg_match('#<b>(.+)</b>#', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n```\n\nNa necelý měsíc jsem to pustil z hlavy až včera jsem si na tento web opět vzpomněl. Také jsem byl již na jiné IP adrese což se mi stává celkem často, takže jsem opět vyzkoušel to co před měsícem a světe div se, bezpečností chyba opět funguje. To mě rozproudilo ještě víc, takže jsem opět usedl k editoru a začal jsem psát program, abych si ověřil, že jsem nekecal:\n\n```php\n<?php\ntry {\n    $db = new PDO('mysql:dbname=emails;host=127.0.0.1', 'root', '');\n    $stmt = $db->prepare(\"INSERT INTO emails (url_id, email) VALUES (:url_id, :email)\n\t\t\t\t\t\t\tON DUPLICATE KEY UPDATE url_id= :url_id, email= :email\");\n\t$stmt->bindParam(':url_id', $url_id);\n\t$stmt->bindParam(':email', $email);\n\n\t//1300486 - 2197943\n\tfor ($i=2197943; $i > 1300486; $i--) {\n\t\tpreg_match('#<b>(.+)</b>#', file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\"), $match);\n\t\tif (preg_match(\"#@#\", $match[1])) {\n\t\t\t$url_id = $i;\n\t\t    $email = $match[1];\n\t\t    echo $i . ': ' . $email . \"\n\";\n\t\t\t$stmt->execute();\n\t\t}\n\t}\n\n} catch (PDOException $e) {\n    echo 'Connection failed: ' . $e->getMessage();\n}\n```\n\nNejsem žádný extra programátor, ale na takovou věc ani být nemusím. Je asi zřejmé, že by tento program trval poměrně dlouhou dobu. Nemá však smysl řešit nějaké paralelní zpracování, když se o to server při vhodně zvoleném programu postará sám. Napsal jsem tedy celkem tři velmi podobné programy. Jeden bral URL adresy od nízkého čísla, druhý od vysokého a třetí na obě strany od středu číselného intervalu. Právě je 17:00, dávám si něco k jídlu a vyrážím do města na hokej...\n\n# Jak to bylo dál?\n\nPo tom co hokej nedopadl moc dobře, strávil jsem nějaký čas u piva a vrátil jsem se domů. Bylo pozdě a program pořád běžel. Šel jsem spát a ráno do školy. Program stále běžel. V tuto chvíli již 16 hodin. Odhadem až někdy po 20ti hodinách dolování emailových adres z tohoto serveru jsem opět dostal IP ban. V tu chvíli jsem měl však získáno více než čtvrt milionu unikátních emailových adres. Ono to funguje! **Zde bych měl říct, že jsem tyto emailové adresy nedoloval kvůli nějakému zneužití, maximálně z nich udělám nějakou statistiku**... (-: Chtěl jsem také napsat na email který mají vystavený na webu, to bohužel nefungovalo, protože tento email byl pravděpodobně zrušen.\n\nV tuto chvíli adresy stále zpracovávám, protože celý systém psal někdo moc \"šikovný\" a tak občas systém vrátil místo emailu *Invalid key!* a jindy zase mix náhodných speciálních znaků s čímž jsem nepočítal. Také já jsem byl šikovný, takže jsem sice v programu počítal s unique klíčem, ale v DB jsem ho neudělal a v reklamním systému je jich cca 10% duplicitních.\n\nŽádám tedy o pomoc. Víte komu patří emailová adresa `b2bdm@email.cz`? Komu patří `m-letter.eu`? Kdo zneužívá tak obrovské množství emailových adres? A kde je vůbec bere? Skutečně mě to zajímá, protože takto je to těžko představitelné, ale několik set tisíc adres je skutečně obrovské množství a já stále nevím, kde jsem se tam vzal...","frontmatter":"id: 52dfa065-130b-4c37-81aa-289bd6ceee9e\ntimestamp: 1392936502000\ntitle: Kde se berou spamy?\nslug: kde-se-berou-spamy"},{"attributes":{"id":"f920c5cc-780f-4fee-b9a6-88d39d4cd2ac","timestamp":1391460655000,"title":"Udržujete dokumentaci stále aktuální?","slug":"udrzujete-dokumentaci-stale-aktualni"},"body":"Již dlouho si v hlavě pohrávám s jednou myšlenkou, kterou stále nemohu dovést do zdárného konce. Již na samém začátku jsem již však věděl, že se zajisté nezalíbí velké skupině programátorů. Přesto si myslím, že má něco do sebe. Jen jsem ji ještě nedomyslel tak, aby jsem s ním byl spokojen. Třeba bude mít někdo nějaký geniální nápad.\n\n# Na začátku byl problém\n\nA každý problém by se měl řešit. Mluvím teď o jednom konkrétním. *Jak udržet dokumentaci projektu aktuální?* To je problém, který některé projekty dokáží bez větších problémů. Obdivuji člověka, který napíše kus kódu a k němu napíše přehlednou a užitečnou dokumentaci. Ještě více však obdivuji toho, kdo aktualizuje kus kódu a opět se pustí na přepisování dokumentace. V praxi je toto však bolístka, která trápí většinu projektů, které používá menší než obrovské množství...\n\nMyslím si, že tento postup je částečně zcestný. Není problém napsat dokumentaci, ale problém je se pak vracet k napsaným textům a číst je znova a znova a stále je upravovat. Má tento problém vůbec nějaké řešení? Možná ano. Pokud zůstanu u myšlenky, že jednou napsat dokumentace a dost, může se leckomu zdát, že při tomto postupu není možné dokumentaci aktualizovat. Definjme tedy alespoň rámcově tyto pojmy. Pod dokumentací si představuji webovou stránku s případnou obsahovou strukturou, která obsahuje jak veškeré naučné texty, tak ukázky kódů. Praktické ukázky. Tak jak to ve skutečnosti funguje.\n\nBěžné zadání dokumentace, že? Nikde jsem však nenapsal, že tato dokumentace musí obsahovat přímo napsané povídání. Musí tento text ve výsledku obsahovat, ale nemusí být součástí!\n\n# Co prosím?\n\nMyslím to přesně tak jak jsem napsal. Dokumentace musí na výstupu obsahovat veškeré texty a prostě všechno, ale nemusí je při tvorbě obsahovat. To zní možná trošku divně. Není ta věta v rozporu sama se sebou? Ne nutně. Dokumentaci bych si opravdu představoval jako soubor pravidel obsahující nadpis, několik programových direktiv a to by bylo v podstatě všechno. Mohlo by to vypadat například takto pro nějaký tutoriál:\n\n```\nToto je nadpis stránky v dokumentaci\n\nindex.php\nbootstrap.php\nHomepagePresenter.php:renderDefault\n```\n\nSchválně jsem zvolil všem tolik známý sandbox z Nette Frameworku. V souboru bych tedy jen definoval jen (omáčku okolo), nadpis, soubory odkud se má dokumentace generovat, popř. nějaký výběr. Zde je nutné říct, že by byl projekt po programové stránce poněkud zvláštní a nejsem si jist, jestli je to úplně OK. usel by totiž obsahovat onu dokumentaci viz např. *index.php*:\n\n```php\n<?php\n\n/**\n ** Zde je umístněna dokumentace.\n ** Obsahuje kompletní poučný text, který se pak vyfiltruje do dokumentace včetně\n ** řádků, popř. metod ke kterám se vztahuje. Pro lepší použití by bylo potřeba\n ** definovat několik zřejmě anotací jako např:\n **\n ** @doc-lines 12-14\n ** @doc-highlight 14\n **/\n$container = require __DIR__ . '/../app/bootstrap.php'; ///>label\n\n$container->application->run();\n```\n\nTakovýto soubor je pak jednoduché vzít, rozebrat, naservírovat text, aplikovat funkci entit a vykreslit i kód ke kterému se tento komentář vztahuje. Možná by šlo vytvořit i nějaká návěští pro odkazování se do kódu, protože číslo řádky není úplně nejvhodnější (<code>///>label</code>).\n\n# Pro et Contra\n\nJednoznačně by tento postup vedl k tomu, aby programátor kromě psaní kódu udržoval i komentář, který by byl běžně velmi blízko. Jednalo by se tak vlastně o jednu práci. Netřeba otevírat celou dokumentaci, stačí změnit pouze malou část, která se s pushnutím zobrazí i v dokumentaci. Na druhou stranu, nedovedu si tento postup představit v kombinaci s klasickým PHPDOC. Nenapadá mě jiné řešení, než udržovat klasický projekt a vedle projekt, který by sloužil pouze pro dokumentaci. Například onen sandbox z NetteFW. Při takovém postupu mi to však dává docela dobrý smysl. Dokumentace by byla doslova stejně aktuální jako zdrojové kódy a to včetně ukázek! Co je u takových projektů důležitější?\n\nMimochodem. PHP k tomuto má velmi blízko. Minimálně podle jejich dokumentačních \"slohokomentářů\". S tímto problémem také lehce souvisí verzování projektů o kterém bych se chtěl rozepsat jindy.\n\nTeď však zpět k myšlence. Jak moc je to hloupý nápad? Co je jeho překážkou? Proč by ho nešlo prakticky použít?","frontmatter":"id: f920c5cc-780f-4fee-b9a6-88d39d4cd2ac\ntimestamp: 1391460655000\ntitle: Udržujete dokumentaci stále aktuální?\nslug: udrzujete-dokumentaci-stale-aktualni"},{"attributes":{"id":"bd6cef8f-9b0a-48ff-a700-2aa32d89a32b","timestamp":1391334426000,"title":"Použití Texy s FSHL","slug":"pouziti-texy-s-fshl"},"body":"Někdy (hodně dávno) jsem kdesi našel poměrně hezký a jednoduchý postup jak implementovat [Texy .{target:_blank}](http://texy.info/) s použitím [FSHL .{target:_blank}](http://fshl.kukulich.cz/) na webu. Rád bych se zde podělil o postup, který používám již na řadě projektů, které potřebují zvýrazňování syntaxe.\n\n# Použití samotného Texy\n\nBěžně by se Texy zaregistrovalo do šablony jako helper:\n\n```php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n\t$template = parent::createTemplate($class);\n\t$texy = new \\Texy();\n\t$template->registerHelper('texy', callback($texy, 'process'));\n\treturn $template;\n}\n```\n\nTento helper lze i nadále používat. Hodě se například pokud je potřeba Texy prvky naopak escapovat:\n\n```\n{$post->body|texy|striptags}\n```\n\n# Použití Texy s FSHL\n\nSamotné texy je sice geniální nástroj. Pro samotné zpracování se zvýrazněním se však hodí funkcionalitu Texy rozšířit, jelikož je potřeba zpracovat vstupující text a ty správná místa prohnat také tím správným lexxerem ve FSHL. K tomu dobře poslouží následující třída, která dědí právě od Texy:\n\n```php\n<?php\n\nclass fshlTexy extends Texy {\n\n\tpublic function blockHandler($invocation, $blocktype, $content, $lang, $modifier) {\n\t\tif ($blocktype !== 'block/code') {\n\t\t\treturn $invocation->proceed(); //vstup se nebude zpracovavat\n\t\t}\n\n\t\t$highlighter = new \\FSHL\\Highlighter(\n\t\t\tnew \\FSHL\\Output\\Html(),\n\t\t\t\\FSHL\\Highlighter::OPTION_TAB_INDENT | \\FSHL\\Highlighter::OPTION_LINE_COUNTER\n\t\t);\n\n\t\t$texy = $invocation->getTexy();\n\t\t$content = Texy::outdent($content);\n\n\t\t//Set correct lexer:\n\t\tswitch(strtoupper($lang)) {\n\t\t\tcase 'CPP': $lexer = new \\FSHL\\Lexer\\Cpp(); break;\n\t\t\tcase 'CSS': $lexer = new \\FSHL\\Lexer\\Css(); break;\n\t\t\tcase 'HTML': $lexer = new \\FSHL\\Lexer\\Html(); break;\n\t\t\tcase 'JAVA': $lexer = new \\FSHL\\Lexer\\Java(); break;\n\t\t\tcase 'JAVASCRIPT': $lexer = new \\FSHL\\Lexer\\Javascript(); break;\n\t\t\tcase 'NEON': $lexer = new \\FSHL\\Lexer\\Neon(); break;\n\t\t\tcase 'PHP': $lexer = new \\FSHL\\Lexer\\Php(); break;\n\t\t\tcase 'PYTHON': $lexer = new \\FSHL\\Lexer\\Python(); break;\n\t\t\tcase 'SQL': $lexer = new \\FSHL\\Lexer\\Sql(); break;\n\t\t\tcase 'TEX': $lexer = new \\FSHL\\Lexer\\Tex(); break; //WARNING: vlastní výroba!\n\t\t\tcase 'TEXY': $lexer = new \\FSHL\\Lexer\\Texy(); break;\n\t\t\tdefault: $lexer = new \\FSHL\\Lexer\\Minimal();\n\t\t}\n\n\t\t$content = $highlighter->highlight($content, $lexer);\n\t\t$content = $texy->protect($content, Texy::CONTENT_BLOCK);\n\n\t\t$elPre = TexyHtml::el('pre');\n\t\tif ($modifier) {\n\t\t\t$modifier->decorate($texy, $elPre);\n\t\t}\n\t\t$elPre->attrs['class'] = strtolower($lang);\n\n\t\t$elCode = $elPre->create('code', $content);\n\n\t\treturn $elPre;\n\t}\n\n}\n```\n\nTato třída při správném použití zajistí, že se použije ten správný lexer a ještě na úrovni PHP zajistí změnu výstupu. Konkrétně obalí určitá klíčová slova (v závislosti na kontextu) tagem <code>&lt;span&gt;</code> se zvláštní třídou. Toho se následně lze chytit v CSS a HTML výstup obarvit. Použití této třídy například v metodě <code>render*()</code>:\n\n```php\n$texy = new \\fshlTexy();\n//registrace handleru z nové třídy:\n$texy->addHandler('block', array($texy, 'blockHandler'));\n//dále stejně jako klasické použití Texy:\n$texy->tabWidth = 4;\n$texy->headingModule->top = 3; //start at H3\n$this->template->body = $texy->process($post->body);\n```\n\nVýstup lze pak v Latte lehce podchytit a zobrazit:\n\n```\n{$body|noescape}\n```\n\n# Barvy, barvy, barvičky\n\nProgramově je sice tělo dokumentu vypsáno s tagy <code>&lt;span&gt;</code> s příslušnou třídou. To se však nijak viditelně neprojeví. Celou krásu udělá teprve CSS. Lze použít výchozí hodoty FSHL a vložit je do vlastního souboru stylů:\n\n```css\n/* Common */\n.xlang { color: #ff0000; font-weight: bold; }\n.line { color: #888888; background-color: #ffffff; }\n\n/* CSS */\n.css-at-rule { color: #004a80; font-weight: bold; }\n.css-tag { color: #004a80; }\n.css-id { color: #7da7d9; font-weight: bold; }\n.css-class { color: #004a80; }\n.css-pseudo { color: #004a80; }\n.css-property { color: #003663; font-weight: bold; }\n.css-value { color: #448ccb; }\n.css-func { color: #448ccb; font-weight: bold; }\n.css-color { color: #0076a3; }\n.css-comment { background-color: #e5f8ff; color: #999999; }\n\n/* CPP */\n.cpp-keywords1 {color: #0000ff; font-weight: bold;}\n.cpp-num {color: #ff0000;}\n.cpp-quote {color: #a52a2a; font-weight: bold;}\n.cpp-comment {color: #00ff00;}\n.cpp-preproc {color: #c0c0c0;}\n\n/* HTML */\n.html-tag {color: #598527; font-weight: bold;}\n.html-tagin {color: #89a315}\n.html-quote {color: #598527; font-weight: bold;}\n.html-comment {color: #999999; background-color: #f1fae4;}\n.html-entity {color: #89a315;}\n\n/* Java */\n.java-keywords1 {color: #0000ff; font-weight: bold;}\n.java-num {color: #ff0000;}\n.java-quote {color: #a52a2a; font-weight: bold;}\n.java-comment {color: #009900;}\n.java-preproc {color: #c0c0c0;}\n\n/* Javascript */\n.js-out {color: #898993;}\n.js-keywords1 {color: #575757; font-weight: bold;}\n.js-num {color: #575757;}\n.js-quote {color: #575757; font-weight: bold;}\n.js-comment {color: #898993; background-color: #f4f4f4;}\n\n/* Neon */\n.neon-section {color: #598527;}\n.neon-sep {color: #ff0000;}\n.neon-key {color: #0000ff;}\n.neon-comment {color: #999999;}\n.neon-value {color: #000000;}\n.neon-quote {color: #884433;}\n.neon-num {color: #448ccb;}\n.neon-var {color: #ffaa00;}\n.neon-ref {color: #884433;}\n\n/* PHP */\n.php-keyword1 {color: #dd2244; font-weight: bold;}\n.php-keyword2 {color: #dd2244;}\n.php-var {color: #ffaa00; font-weight: bold;}\n.php-num {color: #ff0000;}\n.php-quote {color: #884433; font-weight: bold;}\n.php-comment {color: #999999; background-color: #ffffee;}\n\n/* Python */\n.py-keyword1 {color: #0033cc; font-weight: bold;}\n.py-keyword2 {color: #ce3333; font-weight: bold;}\n.py-keyword3 {color: #660066; font-weight: bold;}\n.py-num {color: #993300;}\n.py-docstring {color: #e86a18;}\n.py-quote {color: #878787; font-weight: bold;}\n.py-comment {color: #009900; font-style: italic;}\n\n/* SQL */\n.sql-keyword1 {color: #dd0000; font-weight: bold;}\n.sql-keyword2 {color: #dd2222;}\n.sql-keyword3 {color: #0000ff; font-weight: bold;}\n.sql-value {color: #5674b9;}\n.sql-comment {color: #ffaa00;}\n.sql-num {color: #ff0000;}\n.sql-option {color: #004a80; font-weight: bold;}\n\n/* Tex */\n.tex-func {color: #ffaa00; font-weight: bold;}\n.tex-comment {color: #999999; background-color: #ffffee;}\n.tex-attr1 {color: #dd2222;}\n.tex-attr2 {color: #0000ff; font-weight: bold;}\n.tex-math {color: #00AA00; font-weight: bold;}\n\n/* Texy */\n.texy-hlead {color: #4444bb; font-weight: bold;}\n.texy-hbody {background-color: #eeeeff; color: #4444bb;}\n.texy-hr {color: #bb4444;}\n.texy-code {color: #666666;}\n.texy-html {color: #66aa66;}\n.texy-text {color: #6666aa;}\n.texy-err {background-color: #ff0000; color: #ffffff;}\n```\n\nCelá krása tohoto řešení spočívá v tom, že nepoužívám žádné javascriptové knihovny, ale vše se provede pěkně na úrovni PHP a bude to tedy fungovat vždy, stejně tak jako Texy... (-:","frontmatter":"id: bd6cef8f-9b0a-48ff-a700-2aa32d89a32b\ntimestamp: 1391334426000\ntitle: Použití Texy s FSHL\nslug: pouziti-texy-s-fshl"},{"attributes":{"id":"2abb97d9-9844-4467-b7cb-56844462425b","timestamp":1391288978000,"title":"Vlna na webu","slug":"vlna-na-webu"},"body":"Vlna je program [Petra Olšáka .{target:_blank}](http://ftp.linux.cz/pub/tex/local/cstug/olsak/vlna/), který slouží k umístění nezalomitelné místo na místo v textu, kde by nemělo dojít k samovolnému zalomení řádku. Tento program slouží k dodatečné úpravě textů napsaných v LaTeXu. V tomto prostředí se nezalomitelná mezera nahrazuje znakem vlnovkou - tildou (~). U webového výstupu se používá zástupná entita <code>&amp;nbsp;</code>.\n\n# Kde by měla být nedělitelná mezera\n\nV základu program Vlna umístí tildu za znaky <code>KkSsVvZzOoUuAI</code>. Více toho pokud vím nedělá. Podle Ústavu pro jazyk český AV ČR by však toto pravidlo mělo platit mimo jiné pro znaky <code>KkSsVvZzAaIiOoUu</code>. Neuvažuji další pravidla, která určují další nevhodné výrazy na konci řádku. Mezi tyto pravidla patří například mezery uvnitř číslic, mezery mezi číslicí a značkou, atd. Některá pravidla jsou totiž natolik specifická, že by je bylo náročné (nebo nepraktické) podchytit programově.\n\n# Implementace\n\nO samotné nahrazování se stará následující regulární výraz:\n```php\npreg_replace('<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n```\nTento výraz říká, že nestojí-li bezprostředně před sadou znaků <code>KkSsVvZzAaIiOoUu</code> jiný alfanumerický znak a stojí-li za touto sadou jakýkoliv alfanumerický znak oddělený bílým znakem bude tento znak nahrazen entitou <code>&amp;nbsp;</code>. V konkrétní implementaci lze zaregistrovat Vlnu jako helper pro Latte šablony například takto (obsahuje i registraci Texy helperu):\n\n```php\n/**\n * @param null $class\n * @return Nette\\Templating\\ITemplate\n */\nprotected function createTemplate($class = NULL) {\n\t$template = parent::createTemplate($class);\n\t$texy = new \\Texy();\n\t$template->registerHelper('texy', callback($texy, 'process'));\n\t$template->registerHelper('vlna', function ($string) {\n\t\t$string = preg_replace('<([^a-zA-Z0-9])([ksvzaiou])\\s([a-zA-Z0-9]{1,})>i', \"$1$2\\xc2\\xa0$3\", $string); //&nbsp; === \\xc2\\xa0\n\t\treturn $string;\n\t});\n\treturn $template;\n}\n```\n\nVlna se pak v Latte šablonách používá jako jakýkoliv jiný helper:\n\n```\n{$post->title|vlna}\n```\n\nJeště by možná stálo za to vrátit se k tomu, jaké problémy by způsobovala implementace i dalších pravidel a jak by to bylo náročné. Ještě nad tím budu přemýšlet, každopádně již teď mě napadají určité problémy. Například u čísel. Jak přesně identifikovat, kdy se má použít nedělitelná mezera a kdy ne? Možná je toto právě ten důvod, proč takové rozšířené chování program Vlna nepodporuje...","frontmatter":"id: 2abb97d9-9844-4467-b7cb-56844462425b\ntimestamp: 1391288978000\ntitle: Vlna na webu\nslug: vlna-na-webu"},{"attributes":{"id":"a2fb86da-448c-407d-98a7-b5a7b172042e","timestamp":1390929034000,"title":"Představení projektu Vacuum - STATIC","slug":"predstaveni-projektu-vacuum-static"},"body":"Vzhledem k tomu, že vzrostl zájem o Vacuum projekty, rozhodl jsem se zde uveřejnit postup jak pracovat s projektem **Vacuum - STATIC** (https://bitbucket.org/mrtnzlml/vacuum-static). Věřím, že je daleko lepší projekt ukázat a lehce popsat, než popsat a lehce ukázat, jak si Nette komunita občas myslí...\n\n# Co to vlastně je\n\nVacuum - STATIC je projekt, který vznikl z úplně základního Nette skeletonu, který jsem používal pro jednoduché statické firemní prezentace jako je například http://www.businessservice.cz/. Postupem času jsem dodával vylepšení a když už tento projekt dosáhl svého maxima, rozhodl jsem se do něj napsat jednoduchou administraci. V současné době tedy Vacuum - STATIC vlastně vůbec není statická prezentace. Obsahuje vestavenou SQLite databázi, díky které není potřeba nějaké MySQL databáze. Web prostě funguje zdánlivě bez databáze. Toto je velmi zásadní. Vacuum - STATIC pravděpodobně nikdy nebude mít externí databázi, takže se bude stále tvářit jako jednoduchá webová prezentace, která má však navíc jednoduchou administraci.\n\n# Stažení, instalace, spuštění\n\nCelý projekt se dá stáhnout různě, asi nejjednodušší je využít funkcionalit GITu:\n\n```\n>> git clone https://mrtnzlml@bitbucket.org/mrtnzlml/vacuum-static.git folder\nCloning into 'folder'...\nremote: Counting objects: 433, done.\nremote: Compressing objects: 100% (401/401), done.\nremote: Total 433 (delta 201), reused 0 (delta 0)\nReceiving objects:  92% (399/433), 636.00 KiB | 192 KiB/s\nReceiving objects: 100% (433/433), 664.47 KiB | 192 KiB/s, done.\nResolving deltas: 100% (201/201), done.\n```\n\nTím vytvoříte složku `folder`, která bude obsahovat aktuální verzi projektu Vacuum - STATIC. Pokud v tuto chvíli projekt sputíte, vrátí chybu, že nemůže najít soubor `autoload.php`. Je to proto, že projekt ještě neobsahuje žádné knihovny (například Nette). Ty totiž nemá smysl udržovat v repozitáři. Veškeré potřebné knihovny lze doinstalovat jednoduše pomocí Composeru:\n\n```\n>> composer update\nLoading composer repositories with package information\nUpdating dependencies (including require-dev)\n  - Installing nette/tester (dev-master a60c379)\n    Cloning a60c379836617422c8df9d9846fea4efa2ca9d1d\n\n  - Installing nette/nette (dev-master a748c3d)\n    Cloning a748c3d344767ed1f0cc9ee40019f6a6f81afa97\n\n  - Installing janmarek/webloader (dev-master 3d44d30)\n    Cloning 3d44d306d59591dc94f6fdcb98f55c0990d98326\n\n  - Installing texy/texy (dev-release-2.x 79d0e15)\n    Cloning 79d0e1517363ab32edf2db8ec515e3dc84f50f0a\n\nnette/nette suggests installing ext-fileinfo (*)\njanmarek/webloader suggests installing leafo/lessphp (Lessphp is a composer for LESS written in PHP.)\nWriting lock file\nGenerating autoload files\n```\n\nV tuto chvíli je projekt připraven k použití. V některých systémech však bude potřeba ještě nastavit práva k zápisu složkám `temp` a `log`. Dokonce není potřeba ani nějakého XAMPP serveru. Stačí v té samé složce využít integrovaného PHP serveru v příkazové řádce:\n\n```\nphp -S localhost:8888 -t www\n```\n\nFunkční Vacuum - STATIC pak naleznete na adrese http://localhost:8888/. Trapně jednoduché a překvapivě funkční. (-: Vzhledem k tomu, že již vidíte funkční stránku, můžete se přihlásit do administrace (link v patičce). Přihlašovací údaje jsou *demo*/*demo*.\n\n# Update projektu\n\nNa tomto projektu stále pracuji a čas od času v něm něco doplním nebo upravím. Vzhledem k tomu, že doporučuji použít ke stažení GIT, je update projektu velmi jednoduchý. Stejně jako jsem nedávno zapomněl přidat nahrát dva soubory:\n\n```\n>> git pull\nUpdating ead4a56..2439d5f\nFast-forward\n www/js/codemirror.js | 5516 ++++++++++++++++++++++++++++++++++++++++++++++++++\n www/js/xml.js        |  338 ++++\n 2 files changed, 5854 insertions(+)\n create mode 100644 www/js/codemirror.js\n create mode 100644 www/js/xml.js\n```\n\nTo je asi tak vše co se k tomu dá teď napsat. Nic na tom není, jen je třeba vědět jak na to. Přeji hodně úspěchů při používání tohoto projektu ať už je to ke studijním účelům, nebo k reálné webové prezentaci. Zpětnou vazbu samozřejmě rád uvítám.","frontmatter":"id: a2fb86da-448c-407d-98a7-b5a7b172042e\ntimestamp: 1390929034000\ntitle: Představení projektu Vacuum - STATIC\nslug: predstaveni-projektu-vacuum-static"},{"attributes":{"id":"b18ce753-bbfc-4de4-9c2e-3c71c379d25a","timestamp":1390822437000,"title":"Stáhněte si zdarma 897457 emailových adres","slug":"stahnete-si-zdarma-897457-emailovych-adres"},"body":"V následujícím článku bych rád nastínil problematiku newsletterů nejen z programátorského hlediska <s>a také bych se rád opřel do bezpečnosti společnosti Wedos, které mnoho lidí tolik věří</s>... (-:\n\n<span style=\"color:green\">Tento projekt pravděpodobně nemá se společností Wedos nic společného jak jsem si zřejmě mylně myslel.</span>\n\n# Na začátku byl email\n\nJednoho dne mi přišel email, který byl automaticky filtrován jako spam. Vzhledem k tomu, že když mě něco štve, tak to řeším, spam jsem otevřel a hledal odkaz na odhlášení. Ten byl dobře umístěn, stačilo kliknout a hotovo. Každý přece ví, že to takto má být. Když je odhlášení delší, než kliknutí na spam v email klientovi, je to problém. Bohužel tento odkaz vedlo na doménu <code>m-letter.eu</code>. Mě samozřejmě zajímá jak jsem se dostal do takového spam listu a jelikož jsem byl odkázán na mě neznámou doménu, byl jsem velmi rozezlen.\n\n<s>Zde je nutné říct, že jsem dříve jednal, než pátral. Nakonec se ukázalo, že jsem byl možná v tomto listu oprávněně, jelikož se jedná o doménu, ze které zřejmě Wedos odesílá podobné reklamní emaily, takže je dost pravděpodobné, že jsem s tím dříve souhlasil.</s>\n\n<span style=\"color:green\">Při hlubším pátrání jsem zjistil, že jsem stále nic nezjistil. Chybně jsem tento problém svedl na někoho jiného, což mě odvedlo na špatnou kolej. Stále tedy nevím, kde jsem se na tomto spam listu vzal a opět to beru osobně. Není mi to jedno...</span>\n\n# Neštvi programátora\n\nCelý reklamní systém je udělán dosti nešťastně, takže než abych pátral jak jsem se tam dostal, soustředil jsem se na něco jiného, co pro mě z pohledu programátora webových aplikací bylo dost zajímavé. URL adresa. Celá adresa pro odhlášení je v následujícím formátu:\n\n```\nhttp://www.m-letter.eu/odh.html?c=XXXXXXX&s=53&q=51\n```\n\nKde **XXXXXXX** je číslo zhruba od 1300486 do 2197943. To mě zaujalo a tak jsem toto číslo začal měnit. A ukázalo se, že jsem odhlašoval další lidi. V té době ještě tato stránka vypsala informaci o úspěšném odhlášení včetně emailu, který byl odhlášen. Vzhledem k tomu, že stránka je velmi jednoduchá, lze programově stejně jednoduše získat onu emailovou adresu.\n\nJen si představte program, který iteruje tuto URL adresu a jen sbírá emaily. 897457. To je počet emailů které takto získáte. **897457**. Navíc tímto celý systém znehodnotíte, protože všechny odhlásíte. A pro takový počet emailů to již není zanedbatelné.\n\n# To má být jako oprava?\n\nNejde mi zrovna o to znehodnotit celý čupr dupr systém na spamování, ale proč ne. Tato informace se poměrně rychle rozšířila a o pár minut později mi byl odepřen přístup na tento server. Navíc výpis byl pozměněn tak, aby již nešlo stáhnout téměř 900 000 emailových adres. Nicméně celý systém zřejmě stále funguje stejně, takže můžete jednoduše iterovat URL adresy a tím celý systém znehodnotit:\n\n```php\n<?php\nfor ($i=2197943; $i > 1300486; $i--) {\n    file_get_contents(\"http://www.m-letter.eu/odh.html?c=$i&s=53&q=51\");\n}\n```\n\nDoporučuji spustit v příkazové řádce, kde není nastaven pro PHP timeout. Iterace je schválně pozpátku, protože se dá předpokládat, že ty nejnovější záznamy mají větší číslo a ty s malým číslem už dost možná nebudou aktuální. Celý program jsem měl daleko složitější, vzhledem k tomu, že jsem byl připraven na stáhnutí všech emailů. Po změně výpisu již většina programu není potřeba a stačí tedy tři řádky pro znehodnocení celého nezanedbatelně velkého systému.\n\n<s>Dejme tedy někomu z Wedos čas na opravu a pak hurá na hromadný lynč.</s> <span style=\"color:green\">Opět stejný problém jako předtím. Doufám, že mám tentokrát pravdu...</span> Sice jde jen o emailové adresy, ale vzpomeňte si na to až zase budete nadávat na spam, nebo souhlasit s tím, že vaše emailová adresa nebude nikde uveřejněna.","frontmatter":"id: b18ce753-bbfc-4de4-9c2e-3c71c379d25a\ntimestamp: 1390822437000\ntitle: Stáhněte si zdarma 897457 emailových adres\nslug: stahnete-si-zdarma-897457-emailovych-adres"},{"attributes":{"id":"e0783b28-8a1a-400c-b91b-547b4c372fbe","timestamp":1387710504000,"title":"Veřejná distribuce klíčů","slug":"verejna-distribuce-klicu"},"body":"<blockquote>\n  Inspirací a zdrojem informací pro tento článek byla kniha <strong>Simona Singha</strong> - Kniha kódu a šifer.\n  <small>Utajování od starého Egypta po kvantovou kryptografii</small>\n</blockquote>\n\nTímto článkem bych rád navázal na článek o asymetrickém šifrování http://zlml.cz/asymetricka-sifra-s-verejnym-klicem a vyřešil tak několik restů. Zejména potom onu osudnou veřejnou distribuci klíčů o které jsem sice již dříve psal, ale článek již není k dispozici. Proto tento text budu brát jako revizi původního. Také bych na začátek chtěl říct, že tento problém je již dávno vyřešen a proto bude následující text ohlédnutím za vznikem této myšlenky s tím, že je však použití stále aktuální a reálně se používá (např.: http://nodejs.org/api/crypto.html#crypto_class_diffiehellman).\n\n# Distribuce klíčů? Vždyť je to tak snadné...\n\nPokud si chtějí dvě osoby vyměnit zašifrované zprávy, je jasné, že musejí znát i klíče, které jim umožní tyto zprávy dešifrovat. Jenže jak si vyměnit tyto klíče? Mohou se tyto osoby někdy potkat a klíč si povědět. To však není vždy možné. Navíc klíče je dobé frekventovaně měnit, takže je v dnešní době toto řešení naprosto nesmyslné.\n\n<blockquote>\n  Dříve, než dva lidé mohou sdílet tajemství, musí již jedno tajemství sdílet.\n  <small>Dříve než dva lidé mohou sdílet šifrovanou zprávu, musí již sdílet klíč.</small>\n</blockquote>\n\nAčkoliv je osobní výměna bezpečná, jedná se tedy o metodu nereálnou a je třeba navrhnout jiné postupy. Co třeba najmou kurýra? Je to sice méně bezpečné, ale eliminují se některé předchozí problémy. Bohužel kurýr je až příliš nebezpečný způsob, protože pak lze klíč rovnou nějakým kanálem poslat a dostáváme se opět na začátek. Je tedy vůbec možné si vyměnit klíč bez nutnosti potkat se? Je tedy vůbec nutné si klíč vyměnit?\n\n# Možná to jde i jinak\n\nExistuje skvělá hádanka, která na první pohled daný problém řeší. Představte si poštovní službu, která však všechny zásilky otevírá a čte si je. Nicméně Alice potřebuje poslat tajný balík Bobovi. Lze využít tuto poštu tak, aniž by balík otevřela?\n\nPřistupím rovnou k řešení, které je opravdu jednoduché. Alice pošle balík (schránku), který opatří vlastním zámkem a klíč od tohoto zámku si ponechá. V tom případě není pošta schopna balík otevřít. Bohužel ani Bob balík neumí otevřít, protože nemá k dispozici správný klíč. Proto Bob vezme vlastní zámek a schránku zamkne ještě vlastním zámkem. Klíč si opět ponechá. To může vyznít zvláštně, ale hned to začne být jasné. Bob balík opět odešle, Alice sundá vlastní zámek (protože od něj má klíč) a balík pošle opět Bobovi. Nyní je na balíku pouze Bobovo zámek a ten ho může jednoduše odemknout. Zdá se tedy, že lze cokoliv poslat zabezpečeně a výměna klíčů není potřeba! Toto je nesmírně důležitá myšlenka.\n\nMá to však háček. Ačkoliv se zdá být předchozí problém naprosto zřejmý a funkční, po převedení do světa kódů a šifer, celá myšlenka padá. Důvod je jednoduchý. Bylo velmi snadné na schránku umístit zámek **A**, poté zámek **B**, poté odstranit zámek **A** a nakonec odstranit zámek **B**. Takže posloupnost  šifrování byla +A => +B => -A => -B. Použijete-li však tento postup pomocí doposud známých šifer, zjistíte, že záleží na pořadí šifrování, resp. dešifrování. Zkrátka nelze toto pořadí zaměnit, jinak je výsledek zamíchaný a nepoužitelný.\n\n# Tak to je problém...\n\nAčkoliv byla myšlenka posílání balíku téměř ideální, ve světě šifer již nefunguje. Co teď? Na scénu přichází matematika. Konkrétně jednosměrné funkce a s nimi modulární aritmetika. Nemyslím si, že má smysl řešit co je to jednosměrná funkce, ale zkráceně jednosměrná funkce je taková funkce, která se nedá (nebo velmi těžce) zvrátit. Jeko velmi dobrý příklad takové funkce je například smíchání dvou barev (nelze získat zpět původní barvy). Obdobně pro matematické funkce. Zkrátky vždy je o to nalézt takovou funkci, kterou je velmi jednoduché použít a spočítat, ale již velmi složité invertovat výsledek. Právě pro tyto úlohy se perfektně hodí modulární aritmetika. Tam kde se běžná aritmetika chová předvídatelně a na základě pokusů lze konvergovat k výsledku, v modulární takováto chování neexistují.\n\n# Řešení\n\nNásledující algoritmus je zhruba použit v šifrách DES (pro velká čísla). Budu však používat malá, aby bylo vše lépe pochopitelné. Alice a Bob se <strong>veřejně</strong> dohodnou na funkci *Y<sup>x</sup>(mod P)*, kdy si číla např. Y=5 a P=8 vymění (a útočník je může odposlechnout).\n\nTeď tedy zná příjemnce, odesílatel i útočník danou funkci. Odesílatel a příjemnce si nyní zvolí jiné číslo <strong>které uchovají v tajnosti</strong>, toto číslo vloží do matematické funkce *Y<sup>x</sup>(mod P)* a výsledek odešlou. Například Bob zvolil x=4, tedy *5<sup>4</sup>(mod 8)=1*. Alice volí x=3, tedy *5<sup>3</sup>(mod 8)=5*. Tyto výsledky si vymění.\n\nZ pohledu útočníka lze říci, že zná funkci a zná také výsledky, konkrétně 1 a 5. S touto znalostí by šlo možná privátní číslo **x** dopočítat. Jenže vyzkoušejte si to. Pro malá čísla možná, ale pro velká je to téměř nemožné. A že se používají velká čísla...\n\nNyní vezme Alice výsledek od Boba a spočte *vysledek<sup>x</sup>(mod P)*, tedy *1<sup>3</sup>(mod 8)=1*. Nezapomeňte, že číslo **x** je stále privátní a zná ho jen Alice. Stejně teď postupuje i Bob, ale s vlastním privátním číslem a výsledkem od Alice: *5<sup>4</sup>(mod 8)=1*. A zde je vidět k čemu došlo. Výsledek obou výpočtů vyšel stejně a k přenosu priváního čísla **x** nikdy nedošlo. Vyzkoušejte si to na papír a nejlépe pro větší čísla. Pro útočníka nastává velký problém, protože nezná privátní číslo a je pro něj tedy nemožné provést tyto výpočty, nicméně Alice i Bob mají k dispozici jeden výsledek, tedy jeden klíč, který mohou používat.\n\n# Závěr\n\nJeště zopakuji k čemu tedy došlo. Bylo zapotřebí dohodnout se mezi odesílatelem a příjemcem na společném klíči, podle kterého bude posílaná zpráva šifrována. To se pomocí vhodných matematických metod povedlo a navíc (což je to njdůležitější) není téměř možné tento přenos odposlechnout, jelikož se jedná o jednosměrné operace.\n\nAnalogicky lze použít opět míchání barev. Alice a Bob mají nádobu s litrem červené barvy. Stejnou nádobu má i útočník. Alice i Bob nyní nalijí vlastní privátní barvu do nádoby a tyto nádoby si vymění. Útočník je může vidět, ale nedokáže z nich odhadnout jaká je privátní barva. Nakonec Alice i Bob nalijí zbytek své tajné barvy do nádoby (již je mají vyměněné), čímž vznikne Alici i Bobovi stejná barva. Ani Alice, ani Bob, ani útočník neví co bylo přidáno za barvy od toho druhého, ale se znalostí vlastního privátního klíče se dostanou ke stejnému výsledku. útočník tyto klíče nezná a je nahraný.\n\nTak a zde by měl začínat článek http://zlml.cz/asymetricka-sifra-s-verejnym-klicem.\n\nTento a daleko více inspirativních nápadů a příběhů naleznete v knize https://www.kosmas.cz/knihy/146743/kniha-kodu-a-sifer/.","frontmatter":"id: e0783b28-8a1a-400c-b91b-547b4c372fbe\ntimestamp: 1387710504000\ntitle: Veřejná distribuce klíčů\nslug: verejna-distribuce-klicu"},{"attributes":{"id":"2894e1f9-8a47-48b9-bcea-40bf4fdb3724","timestamp":1387385662000,"title":"Přednáška z Nette na ZČU","slug":"prednaska-z-nette-na-zcu"},"body":"Dnes jsem měl tu čest přednášet na ZČU studentům předmětu KIV/WEB - Webové aplikace.\nPřednášku a i celé povídání jsem se snažil chopit velmi realisticky, prakticky a pro studenty, \nkteří s tvorbou webových aplikací teprve začínají. Doufám, ze bylo mé povídání\ninspirativní, srozumitelné a pochopitelné. Ostatně sami si prezentaci můžete přečíst:\n<br><br>\n\n<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29326870\" width=\"752\" height=\"460\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe>\n\n<br>\nVěřím, že Nette bude používat zase o něco více začátečníků a že še jim podaří psát kvalitní\nwebové aplikace. Rád bych ještě jednou popřál všem studentům úspěšné složení zkoušky z předmětu KIV/WEB\na snad se ještě někdy potkáme... (-:","frontmatter":"id: 2894e1f9-8a47-48b9-bcea-40bf4fdb3724\ntimestamp: 1387385662000\ntitle: Přednáška z Nette na ZČU\nslug: prednaska-z-nette-na-zcu"},{"attributes":{"id":"58e7368b-0db4-498f-8184-fc4877ba32ba","timestamp":1387113023000,"title":"Nette 2.2-dev","slug":"nette-2-2-dev"},"body":"Nedávno byla změněna vývojová verze Nette Frameworku na 2.2-dev (https://github.com/nette/nette/commit/3a426255084163ec1a2f324ea0d3e9b3139adccc).\nTato změna s sebou přinesla explozi změn. Na následujících řádcích bych rád přiblížil\nněkteré zásadní změny, které se odehrály a je zapotřebí je upravit, aby bylo možné z verze 2.1-dev\npřejít právě na verzi 2.2-dev.\n\n# Nutné úpravy\n\nPrvě se změnilo umístění konfigurátoru. Tato změna se samozřejmě týká souboru `bootstrap.php`.\nNově je konfigurátor v novém umístění:\n\n```php\n//$configurator = new Nette\\Config\\Configurator;\n$configurator = new \\Nette\\Configurator;\n```\n\nDále jsem si zvykl používat automatické injektování závislostí pomocí anotace `@inject`.\nPro opětovné použití je nutné zapnout `nette.container.accessors`, což ostatně napoví chybová hláška,\njelikož je tato volba v nové developměnt verzi Nette ve výchozím stavu zakázána. Config.neon:\n\n```neon\nnette:\n\tcontainer:\n    \taccessors: TRUE\n```\n\nNyní již bude možné anotace `@inject` používat. Další změna, které mě osobně moc nepotěšila\na nevím co jí předcházelo je zrušení podpory krátkého zápisu bloků:\n\n```html\n<!-- Předtím: -->\n{#content}\n\t...\n{/#}\n<!-- Nyní: -->\n{block content}\n\t...\n{/block}\n```\n\nTato změna se mi moc nelíbí, protože například stále funguje `{include #parent}`, což je prostě\nzvláštní... Za zmínku také stojí změna třídy pro práci s databází. Zatímco se ve verzi 2.0.13\nnormálně používá `Nette\\Database\\Connection`, ve verzi 2.1-dev se přešlo na `Nette\\Database\\SelectionFactory`, \nnicméně ve verzi 2.1.0RC2 se již pracuje s `Nette\\Database\\Context` a SelectionFactory již neexistuje. \nToto  platí i pro verzi 2.2-dev. Tato změna mi bude zřejmě dlouho trvat, než ji vstřebám.\nMyslím si, že obyčejné `Nette\\Database` by bylo v modelu daleko více vypovídající než nějaký Context, \nale budiž.\n\nTolik k podle mého zásadním změnám, které zabrání například spuštění projektu z quickstartu. Nyní\nbych rád poukázal na několik málo změn z celé té exploze, které mě zaujaly.\n\n# Další změny\n\nByla odstraněna celá řada zastaralých věcí. Nemá smysl je rozebírat. Je jich hodně a zastaralé jsou\nuž od 2.1. Každopádně například makro `n:input` se stalo zastaralé a k dispozici je nové makro\n`{inputError}`, které ošéfuje vykreslení chybové hlášky u příslušného políčka. Jééj! :-)\n\nLehce odlišně se také přistupuje k checkboxům a vůbec, formuláře jsou zase o něco lepší, což\npředpokládám souvisí s:\n\n<blockquote class=\"twitter-tweet\" lang=\"en\"><p>Chtěl jsem v rychlosti udělat příklad, jak v <a href=\"https://twitter.com/search?q=%23netteFw&amp;src=hash\">#netteFw</a> renderovat formuláře s Twitter Bootstrapem.&#10;&#10;Zabitej den a překopaný Nette…</p>&mdash; geekovo (@geekovo) <a href=\"https://twitter.com/geekovo/statuses/409064701369516032\">December 6, 2013</a></blockquote>\n<script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n# Konečně!\n\nSvětlo světa spatřil nový [quickstart](http://doc.nette.org/cs/2.1/quickstart) v češtině pro dnes již téměř nekatuální verzi 2.0.13.\nVěřím tomu, že se jedná o daleko přínosnější věc, než psaní pokročilých návodů v angličtině\n(navazujících na quickstart) a doufám, že tento počin pomůže pár lidí popostrčit dál...\n\nJaká změna vás zaujala nejvíce?","frontmatter":"id: 58e7368b-0db4-498f-8184-fc4877ba32ba\ntimestamp: 1387113023000\ntitle: Nette 2.2-dev\nslug: nette-2-2-dev"},{"attributes":{"id":"dbf85219-5173-4c7b-924a-636e86172b93","timestamp":1382905620000,"title":"Změna URL struktury","slug":"zmena-url-struktury"},"body":"Rád bych tímto upozornil na změny URL adres na tomto webu. A zároveň k technické povaze tohoto webu\nprozradím i bližší informace ze zákulisí.\n\nPřed úpravou URL struktury jsem definoval několik důležitých bodů, kterých jsem se držel:\n1. Musí zůstat maximální (úplná) zpětná kompatibilita\n2. Výsledné URL musí být maximálně jednoduché a cool\n\n# Předtím a potom\n\nDůležité je, aby stará URL adresa nekončila chybou 404, ale aby přesměrovala na novou URL.\nRSS je nyní na adrese http://zlml.cz/rss. Původně bylo na adrese http://zlml.cz/homepage/rss.\nObě dvě adresy fungují stále, rozdíl je v tom, že homepage/rss nyní přesměrovává pomocí 301 na */rss.\nToho se dalo docílit velice jednoduše:\n\n```php\n$router[] = new Route('rss', 'Homepage:rss'); //nová routa\n$router[] = new Route('<presenter>/<action>[/<id>]', 'Homepage:default'); //původní\n//záleží na pořadí!\n```\n\nAčkoliv je teď druhá routa zbytečná, nechal jsem jí pro případ, že bych měl nějakou URL nezachycenou.\nV tom případě ji zachytí tato obecná.\n\n# Zpětná kompatibilita\n\nStejně tak jako změna adresy RSS, tak si i ostatní adresy musí zachovat stejné vlastnosti viz první bod.\nA vzhledem k tomu, že jsem se rozhodl změnit adresu vyhledávání a tagů, nezbývalo, než další\ndvě routy přidat. Opět záleží na pořadí:\n\n```php\n$router[] = new Route('s[/<search>]', 'Search:default'); //nová\n$router[] = new Route('t[/<search>]', 'Tag:default'); //nová\n\n//tyto routy (až uznám za vhodné) mohu smazat:\n$router[] = new Route('search[/<search>]', 'Search:default', Route::ONE_WAY); //původní\n$router[] = new Route('tag[/<search>]', 'Tag:default', Route::ONE_WAY); //původní\n```\n\nOpět platí, že funguje jak stará adresa http://zlml.cz/search/nette s přesměrováním 301, tak i nová \nhttp://zlml.cz/s/nette. Obdobně je tomu u tagů.\n\n# Čarodějnictví!\n\nNejvětší sranda však začíná u druhého požadavku. Už dlouho jsem si pohrával s myšlenkou,\nže chci názvy článků a adresy jednotlivých stránek v menu hned za lomítkem jako v kořenovém\nadresáři. Tedy aby článek měl adresu http://zlml.cz/lovec-matematik a stránka http://zlml.cz/about.\nZde jsem se však vždy dostával do velkého problému. Jak rozlišit a nabídnout z databáze článek a \njak poznat, kdy naopak nabídnout stránku například s referencemi?\n\nNo, tak nejdříve je zapotřebí routa pro články:\n```php\n$router[] = new Route('<slug>', 'Single:article');\n```\nKdy v presenteru tahám články z databáze podle slugu:\n```php\npublic function renderArticle($slug) {\n\t$post = $this->posts->getBySlug($slug)->fetch(); //načetní článku podle slugu\n\tif (!$post) { //článek neexistuje (db vrací FALSE)\n\t\t$this->forward($slug); //nabídni statickou šablonu\n\t} else { // zobrazení článku\n    \t//...\n    }\n}\n```\nCož je podle mého dostatečně elegantní řešení. Jednoduše se pokusím o načtení stránky podle slugu\nz databáze a když se to nepodaří, nabídnu nějaký latte soubor, pokud existuje. Pokud neexistuje, \ntak ErrorPresenter již obstará vrácení 404, což je správně, protože není co nabídnout...\n\nJeště je zapotřebí vytvořit jednu routu:\n```php\n$router[] = new Route('<action>', 'Single:article');\n```\nBez této routy by to také fungovalo, ale latte ony latte soubory (action) bych našel na dvou URL\nadresách, což nechci. Takže se z původního http://zlml.cz/single/about dostanu na http://zlml.cz/about, \ncož je cool a splňuji tak druhý požadavek.\n\nPoslední routa, která stojí za zmíňku pak zajišťuje stránkování. Pouze rozpoznává čísla podle\nregulárního výrazu a podle toho stránkuje:\n```php\n$regex = '1|2|3'; //zjednodušeně\n$router[] = new Route(\"[<paginator-page [$regex]>]\", array(\n\t'presenter' => 'Homepage',\n\t'action' => 'default',\n\t'paginator-page' => 1\n));\n```\n\nOstatně to jak mám v době psaní tohoto článku router vytvořený můžete zjistit na [bitbucketu](https://bitbucket.org/mrtnzlml/zlml.cz/src/0580e2e9f0e4edb162fe97ad563cfef766bea625/app/router/RouterFactory.php).\n","frontmatter":"id: dbf85219-5173-4c7b-924a-636e86172b93\ntimestamp: 1382905620000\ntitle: Změna URL struktury\nslug: zmena-url-struktury"},{"attributes":{"id":"2de31894-6830-48d7-a34f-9eaa72abc44b","timestamp":1382391734000,"title":"LaTeX šablona","slug":"latex-sablona"},"body":"Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\n\n```tex\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\n\\usepackage[czech]{babel}\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\n\n%%% PAGE DIMENSIONS\n\\usepackage{geometry} % to change the page dimensions\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\n\\geometry{a4paper}\n\n\\usepackage{graphicx} % support the \\includegraphics command and options\n\\usepackage{wrapfig} % support the wrapfigure section\n\n\\usepackage{hyperref} % links in \\tableofcontents\n\\hypersetup{\n\tcolorlinks,\n\tcitecolor=black,\n\tfilecolor=black,\n\tlinkcolor=black,\n\turlcolor=black\n}\n\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\n\n%%% PACKAGES\n\\usepackage{booktabs} % for much better looking tables\n\\usepackage{array} % for better arrays (eg matrices) in maths\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\n% These packages are all incorporated in the memoir class to one degree or another...\n\\usepackage{tikz} % graphs\n\\usepackage{pgfplots}\n\\usepackage{float}\n\n%%% HEADERS & FOOTERS\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\n\\pagestyle{fancy} % options: empty , plain , fancy\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\n\\lhead{}\\chead{}\\rhead{}\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\n\n%%% SECTION TITLE APPEARANCE\n\\usepackage{sectsty}\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\n% (This matches ConTeXt defaults)\n\n%%% ToC (table of contents) APPEARANCE\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\n\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\n\n%%% END Article customizations\n\n\\begin{document}\n\n\t...\n\n\\end{document}\n```\n\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?","frontmatter":"id: 2de31894-6830-48d7-a34f-9eaa72abc44b\ntimestamp: 1382391734000\ntitle: LaTeX šablona\nslug: latex-sablona"},{"attributes":{"id":"c8de8345-cdb5-4580-966a-96b1331479c3","timestamp":1382390436000,"title":"Důležitost titulku podruhé (a naposled)","slug":"dulezitost-titulku-podruhe-a-naposled"},"body":"Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://zlml.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\n\n# Jak málo stačí k umístění ve vyhledávači\n\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\n\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\n\n# Jenže není zobrazení jako zobrazení\n\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\n\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://zlml.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://zlml.cz/navrhovy-vzor-factory-method).\n\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.","frontmatter":"id: c8de8345-cdb5-4580-966a-96b1331479c3\ntimestamp: 1382390436000\ntitle: Důležitost titulku podruhé (a naposled)\nslug: dulezitost-titulku-podruhe-a-naposled"},{"attributes":{"id":"40b5dd33-13a2-447e-b352-256bc1afd9cd","timestamp":1377116084000,"title":"AJAX upload souborů v Nette pomocí Fine Uploaderu","slug":"ajax-upload-souboru-v-nette-pomoci-fine-uploaderu"},"body":"<div class=\"alert alert-danger\">Následující text řeší starší verzi FineUploaderu `3.*`, nikoliv nejnovější. Hledáte-li aktuálnější návod, přečtěte si prosím http://zlml.cz/ajax-upload-souboru-v-nette-pomoci-fine-uploaderu-2...</div>\n\nA je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\nnahrávání souborů v Nette pomocí [Fine Uploaderu .{target:_blank}](http://fineuploader.com/).\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\n\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\n\n```html\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\n<script src=\"{$basePath}/js/main.js\"></script>\n```\n\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\n\n```html\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\n<div id=\"triggerUpload\">Nahrát obrázky</div>\n```\n\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\n\n```javascript\n$(function () {\n\tif ($('#image-uploader').length != 0) { //test existence elementu\n\t\t$.nette.ext('uploader', {\n\t\t\tcomplete: function () { //zavěšení na konec ajaxového požadavku\n\t\t\t\tvar uploader = $('#image-uploader').fineUploader({\n\t\t\t\t\trequest: {\n\t\t\t\t\t\tendpoint: 'product/default/' + $('#image-uploader').data('id') + '?do=upload'\n\t\t\t\t\t},\n\t\t\t\t\ttext: {\n\t\t\t\t\t\tuploadButton: 'Klikněte, nebo přetáhněte obrázky',\n\t\t\t\t\t\tcancelButton: 'zrušit',\n\t\t\t\t\t\tfailUpload: 'Nahrání obrázku se nezdařilo',\n\t\t\t\t\t\tdragZone: 'Přetáhněte soubory sem',\n\t\t\t\t\t\tdropProcessing: 'Zpracovávám přetažené soubory...',\n\t\t\t\t\t\tformatProgress: '{percent}% z {total_size}',\n\t\t\t\t\t\twaitingForResponse: 'Zpracovávám...'\n\t\t\t\t\t},\n\t\t\t\t\tautoUpload: false,\n\t\t\t\t\tfailedUploadTextDisplay: {\n\t\t\t\t\t\tmode: 'custom',\n\t\t\t\t\t\tmaxChars: 70,\n\t\t\t\t\t\tresponseProperty: 'error',\n\t\t\t\t\t\tenableTooltip: true\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t$('#triggerUpload').click(function () {\n\t\t\t\t\tuploader.fineUploader('uploadStoredFiles');\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t$.nette.init(); //inicializace nette.ajax\n});\n```\n\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\nTen může vypadat například takto:\n\n```php\npublic function handleUpload($id) {\n\t$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\n\t$uploader = new \\qqFileUploader($allowedExtensions);\n\t//...\n\ttry {\n\t\t$result = $uploader->handleUpload(__DIR__ . '/../../../www/uploads/' . $id . '/default', NULL);\n\t\t$result['uploadName'] = $uploader->getUploadName();\n\t\t//...\n\t} catch (\\Exception $exc) {\n\t\t$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\n\t\t\t'error' => $exc->getMessage(),\n\t\t)));\n\t}\n\t$this->invalidateControl();\n\t$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\n}\n```\n\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\njako úspěšný upload.\n\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na [GitHubu .{target:_blank}](https://github.com/Widen/fine-uploader-server) a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\no webalize názvů souborů.\n\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použít.\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.","frontmatter":"id: 40b5dd33-13a2-447e-b352-256bc1afd9cd\ntimestamp: 1377116084000\ntitle: AJAX upload souborů v Nette pomocí Fine Uploaderu\nslug: ajax-upload-souboru-v-nette-pomoci-fine-uploaderu"},{"attributes":{"id":"71e8347e-9bdb-4d81-a323-203be472f0ad","timestamp":1376169022000,"title":"RSS a Sitemap jednoduše a rychle","slug":"rss-a-sitemap-jednoduse-a-rychle"},"body":"Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\n\nZačněme HomepagePresenterem (DEV Nette):\n\n```php\n<?php\n\nclass HomepagePresenter extends BasePresenter {\n\n\t/** @var \\Model\\Posts @inject */\n\tpublic $posts;\n\n\tpublic function renderRss() {\n\t\t$this->template->posts = $this->posts->getAllPosts()->order('date DESC')->limit(50);\n\t}\n\n\tpublic function renderSitemap() {\n\t\t$this->template->sitemap = $this->posts->getAllPosts();\n\t}\n\n}\n```\n\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\n\nPro úplnost ještě \\Model\\Posts:\n\n```php\n<?php\n\nnamespace Model;\n\nclass Posts extends \\Nette\\Object {\n\n\t/** @var \\Nette\\Database\\SelectionFactory @inject */\n\tpublic $sf;\n\n\t/**\n\t * @return Nette\\Database\\Table\\Selection\n\t */\n\tpublic function getAllPosts() {\n\t\treturn $this->sf->table('posts');\n\t}\n\n}\n```\n\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\n\n```html\n{contentType application/xml}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n\t{foreach $sitemap as $s}\n\t\t<url>\n\t\t\t<loc>{link //Single:article $s->id}</loc>\n\t\t</url>\n\t{/foreach}\n</urlset>\n```\n\nRss.latte:\n\n```html\n{contentType application/xml}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<rss version=\"2.0\">\n\t<channel>\n\t\t<title>Martin Zlámal [BLOG]</title>\n\t\t<link>{link //:Homepage:default}</link>\n\t\t<description>Nejnovější články na blogu.</description>\n\t\t<language>cs</language>\n\n\t\t<item n:foreach=\"$posts as $post\">\n\t\t\t<title>{$post->title}</title>\n\t\t\t<link>{link //:Single:article $post->id}</link>\n\t\t\t<description>{$post->body|texy|striptags}</description>\n\t\t</item>\n\t</channel>\n</rss>\n```\n\nA pro úplnou úplnost i router:\n\n```php\n<?php\n\nnamespace App;\nuse Nette;\nuse Nette\\Application\\Routers\\Route;\nuse Nette\\Application\\Routers\\RouteList;\nuse Nette\\Application\\Routers\\SimpleRouter;\n\nclass RouterFactory {\n\n\t/**\n\t * @return \\Nette\\Application\\IRouter\n\t */\n\tpublic function createRouter() {\n\t\t$router = new RouteList();\n\t\t$router[] = new Route('sitemap.xml', 'Homepage:sitemap');\n\t\t// na RSS se dá odkazovat normálně bez routeru, nebo:\n\t\t$router[] = new Route('rss.xml', 'Homepage:rss');\n\t\t//...\n\t\t$router[] = new Route('<presenter>/<action>[/<id>]', 'Homepage:default');\n\t\treturn $router;\n\t}\n\n}\n```\n\nJednoduché a na pár řádek. Jen vědět jak na to... (-:","frontmatter":"id: 71e8347e-9bdb-4d81-a323-203be472f0ad\ntimestamp: 1376169022000\ntitle: RSS a Sitemap jednoduše a rychle\nslug: rss-a-sitemap-jednoduse-a-rychle"},{"attributes":{"id":"16cdfe07-444b-48ee-ae7a-ff85893edba5","timestamp":1376166681000,"title":"Fluent interface a PCRE","slug":"fluent-interface-a-pcre"},"body":"Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu ([inspirace .{target:_blank}](https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php)), což je druhá věc o které bych se rád zmínil.\n\n# Regulární výrazy jsou peklo\n\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\n\n```\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\n```\n\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\n\n```php\n<?php\n\nclass Regexp {\n\n\tprivate $regexp = '';\n\n\tpublic function has($value) {\n\t\t$this->regexp .= \"(\" . preg_quote($value, '/') . \")\";\n\t\t//return $this;   -   potřebné pro fluent interface\n\t}\n\n\tpublic function maybe($value) {\n\t\t$this->regexp .= \"(\" . preg_quote($value, '/') . \")?\";\n\t\t//return $this;   -   potřebné pro fluent interface\n\t}\n\n\tpublic function anythingBut($value) {\n\t\t$this->regexp .= \"([^\" . preg_quote($value, '/') . \"]*)\";\n\t\t//return $this;   -   potřebné pro fluent interface\n\t}\n\n\tpublic function __toString() {\n\t\treturn \"/^$this->regexp$/\";\n\t}\n\n}\n```\n\nS tím, že její použití je prosté:\n\n```php\n$regexp = new Regexp();\n$regexp->then('http');\n$regexp->maybe('s');\n$regexp->then('://');\n$regexp->maybe('www.');\n$regexp->anythingBut(' ');\n$regexp->then('.');\n$regexp->anythingBut(' ');\n$regexp->maybe('/');\necho $regexp . '<br>';\necho preg_match($regexp, 'http://zlml.cz/') ? 'P' : 'F';\necho preg_match($regexp, 'https://zlml.cz/') ? 'P' : 'F';\n```\n\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\n\n# Fluent interfaces, regulární peklo chladne\n\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\n\n```php\n$regexp = new Regexp();\n$regexp->then('http')\n\t\t->maybe('s')\n\t\t->then('://')\n\t\t->maybe('www.')\n\t\t->anythingBut(' ')\n\t\t->then('.')\n\t\t->anythingBut(' ')\n\t\t->maybe('/');\necho $regexp . '<br>';\necho preg_match($regexp, 'http://zlml.cz/') ? 'P' : 'F';\necho preg_match($regexp, 'https://zlml.cz/') ? 'P' : 'F';\n```\n\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\n\n# Ne, peklo je opět peklem\n\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\n\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.","frontmatter":"id: 16cdfe07-444b-48ee-ae7a-ff85893edba5\ntimestamp: 1376166681000\ntitle: Fluent interface a PCRE\nslug: fluent-interface-a-pcre"},{"attributes":{"id":"314fff27-204c-449e-9975-572db54475a2","timestamp":1375611559000,"title":"Routování v Nette - prakticky","slug":"routovani-v-nette-prakticky"},"body":"<div class=\"alert alert-success\">Tento článek byl naposledy revidován, aktualizován a rozšířen <strong>27. června 2014</strong>...</div>\n\nV následujícím článku se budu opírat o teorii napsanou v [dokumentaci](http://doc.nette.org/cs/routing).\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\n\nZáklad všeho je porozumět tomu, jak se v Nette vytváří [odkazy](http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu).\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\n\n# První kroky\n\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu:\n\n```\napp/\n├─── config/\n├─── model/\n├─── presenters/\n│     └── HomepagePresenter.php\n│\n├─── router/\n├─── templates/\n│     ├── Homepage/\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\n│     │    └── ...\n│     └── @layout.latte\n│\n└─── bootstrap.php\n```\n\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\n\n```php\n$router[] = new Route('<presenter>/<action>[/<id>]', 'Homepage:default');\n```\n\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\n\n```\nhttp://zlml.cz/homepage/kontakt\n```\n\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibližně následující:\nBude-li se někdo odkazovat v obecném tvaru `Presenter:view`, pochop `Presenter` jako název presenteru (např. **Homepage**Presenter) a hledej tedy soubor `HomepagePresenter.php`\na `view` bude šablona presenteru, hledej ji tedy ve složce `Presenter/view.latte` a sestav URL která bude přesně v tomto tvaru.\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\n\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\n\n```php\n$router[] = new Route('<action>', 'Homepage:default');\n```\n\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\nse mění cílová šablona podle URL:\n\n```\nhttp://zlml.cz/kontakt\n```\n\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\n\n```php\npublic function createRouter() {\n\t$router = new RouteList();\n\t$router[] = new Route('<action>', 'Homepage:default');\n\t$router[] = new Route('<presenter>/<action>[/<id>]', 'Homepage:default');\n\treturn $router;\n}\n```\n\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře jako šablony, routa je opět jednoduchá:\n\n```php\n$router[] = new Route('sitemap.xml', 'Homepage:sitemap');\n```\n\nHledá se šablona <code>sitemap.latte</code>. Přečtěte si jak vytvořit tuto šablonu v článku [RSS a Sitemap jednoduše a rychle](rss-a-sitemap-jednoduse-a-rychle). Výsledná URL je tak jak má být:\n\n```\nhttp://zlml.cz/sitemap.xml\n```\n\nTo samé lze udělal pro RSS.\n\n# Jdeme do hloubky\n\nTrošku složitější routování přichází vždy když chcete udělat něco speciálního.\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\n\n```\nhttp://zlml.cz/2\n```\n\n```php\n$router[] = new Route(\"[<paginator-page [1](2)>]\", array(\n\t'presenter' => 'Homepage',\n\t'action' => 'default',\n\t'paginator-page' => 1\n));\n```\n\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\n\n```\nhttp://zlml.cz/using-fulltext-searching-with-innodb\n```\n\n```php\n$router[] = new Route('<id>', array(\n\t'presenter' => 'Single',\n\t'action' => 'article',\n\t'id' => array(\n\t\tRoute::FILTER_IN => function ($url) {\n\t\t\treturn $this->posts->getIdByUrl($url);\n\t\t},\n\t\tRoute::FILTER_OUT => function ($id) {\n\t\t\treturn $this->posts->getUrlById($id);\n\t\t},\n\t),\n));\n```\n\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\n\n```\nhttp://zlml.cz/search/fio%20api\n```\n\n```php\n$router[] = new Route('search[/<search>]', 'Search:default');\n```\n\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\n\n```\nhttp://zlml.cz/rss.xml\n```\n\n```php\n$router[] = new Route('rss.xml', 'Front:Blog:rss');\n```\n\nChová se to stejně jako u předchozího příkladu se `sitemap.xml`, v tomto příkladu však routa hledá `BlogPresenter.php` ve složce `FrontModule` a šablonu `rss.latte`, také v tomto modulu. U rout pro modulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa zvládne jazykové mutace pro FrontModul, jinak je to opět ta nejobecnější routa vůbec:\n\n```\nhttp://zlml.cz/en/site/kontakt\n```\n\n```php\n$router[] = new Route('[<lang cs|sk|en>/]<presenter>/<action>[/<id>]', array(\n\t'module' => 'Front',\n\t'presenter' => 'Homepage',\n\t'action' => 'default',\n));\n```\n\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\n\n```\nhttp://zlml.cz/user/en/setting/password\n```\n\n```php\n$router[] = new Route('user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]', array(\n\t'module' => 'User',\n\t'presenter' => 'Board',\n\t'action' => 'default',\n));\n```\n\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\n\n```php\n$router[] = new Route('sitemap.xml', 'Front:Export:sitemap');\n$router[] = new Route('kategorie/<category>', 'Front:Product:default');\n$router[] = new Route('produkt/<product>', 'Front:Product:detail');\n$router[] = new Route('', 'Front:Product:default');\n$router[] = new Route('admin/sign-<action>', 'Admin:Sign:');\n$router[] = new Route('registrace/', 'Front:Register:new');\n$router[] = new Route('index.php', 'Homepage:default', Route::ONE_WAY);\n$router[] = new CliRouter(array('action' => 'Cli:Cli:cron'));\n$router[] = new \\App\\RestRouter('api[/<presenter>[/<id>]]', array( //vyžaduje speciální objekt (není součástí Nette)\n\t'module' => 'Rest',\n\t'presenter' => 'Resource',\n\t'action' => 'get',\n), \\App\\RestRouter::RESTFUL);\n```\n\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\n\nJak na v posledním příkladu zmíněný CLI router se dočtete v článku [Nette 2.1-dev CliRouter](nette-2-1-dev-clirouter).\n\nMáte nějakou zajímavou routu? Podělte se o ni... (-:","frontmatter":"id: 314fff27-204c-449e-9975-572db54475a2\ntimestamp: 1375611559000\ntitle: Routování v Nette - prakticky\nslug: routovani-v-nette-prakticky"},{"attributes":{"id":"17782730-319b-40ea-92d0-e33c84b32e29","timestamp":1375215333000,"title":"Problémy fulltextu v Nette","slug":"problemy-fulltextu-v-nette"},"body":"Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://zlml.cz/using-fulltext-searching-with-innodb).\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\nbylo řešení [Jakuba Vrány .{target:_blank}](http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php).\n\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\n\n# Nette, ty jedna zrádná bestie...\n\n\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\npoužití **REGEXP**.\n\nBěžný kód pro fultextové dotazování může vypadat takto:\n\n```php\n/** @var Nette\\Database\\SelectionFactory @inject */\npublic $sf;\n    \n$this->sf->table('mirror_posts')\n\t->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\n\t->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\n\t->limit(50);\n```\n\nCož vygeneruje přibližně přesně následující:\n\n```sql\nSELECT `id`, `title`, `body` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST ('api' IN BOOLEAN MODE)) \nORDER BY 5 * MATCH(`title`) AGAINST ('api') + MATCH(`body`) AGAINST ('api') DESC \nLIMIT 50\n```\n\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\nposkládám složitější dotaz:\n\n```php\n$where = \"\";\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE 'ft_min_word_len'\"), 0, 1);\n$ft_min_word_len = 4;\npreg_match_all(\"~[\\\\pL\\\\pN_]+('[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\nforeach ($matches[0] as $part) {\n\tif (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\n\t\t$regexp = \"REGEXP '[[:<:]]\" . addslashes($part) . \"[[:>:]]'\";\n\t\t$where .= \" OR (title $regexp OR body $regexp)\";\n\t}\n}\n```\n\nA doplníme fluidní dotaz:\n\n```php\n...\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\n...\n```\n\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\n\n```sql\nSELECT `id` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST ('api' IN BOOLEAN MODE) OR (`title` REGEXP '[[:<:]]`api`[[:>:]]' OR `body` REGEXP '[[:<:]]`api`[[:>:]]')) \nORDER BY 5 * MATCH(`title`) AGAINST ('api') + MATCH(`body`) AGAINST ('api') DESC \nLIMIT 50\n```\n\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\nDůvodem jsou zpětné uvozovky v regulárním výrazu **''[[:<:]]`api`[[:>:]]''**.\n\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\npřímo ptá databáze. Existuje však vyčůranější způsob.\n\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\n\n```php\n$regexp = \"REGEXP '[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]'\";\n```\n\nA dotaz se následně poskládá strávně:\n\n```sql\nSELECT `id`, `title`, `body` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST ('api' IN BOOLEAN MODE) OR (`title` REGEXP '[[:<:]]API[[:>:]]' OR `body` REGEXP '[[:<:]]API[[:>:]]')) \nORDER BY 5 * MATCH(`title`) AGAINST ('api') + MATCH(`body`) AGAINST ('api') DESC \nLIMIT 50\n```\n\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\n\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\nale je to divné.","frontmatter":"id: 17782730-319b-40ea-92d0-e33c84b32e29\ntimestamp: 1375215333000\ntitle: Problémy fulltextu v Nette\nslug: problemy-fulltextu-v-nette"},{"attributes":{"id":"30938e58-9de3-403e-a862-493564630ddd","timestamp":1375126671000,"title":"Using fulltext searching with InnoDB","slug":"using-fulltext-searching-with-innodb"},"body":"Sometimes is quite useful to use InnoDB engine. \nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \nYou can't create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \nUnfortunately you can't create foreign keys on MyISAM. It's starting to be quite embarassing. \nLet me show you how to search via fulltext on InnoDB tables.\n\nIn fact it's not possible to use fulltext index on InnoDB tables, \nbut there is possible workaround. At first you need a classic InnoDB structure. \nFor example database of  blog:\n\n```sql\nSET NAMES utf8;\nSET foreign_key_checks = 0;\nSET time_zone = 'SYSTEM';\nSET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';\n\nDROP TABLE IF EXISTS `posts`;\nCREATE TABLE `posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  `date` datetime NOT NULL,\n  `release_date` datetime NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `title_3` (`title`(200))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `tags`;\nCREATE TABLE `tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) NOT NULL,\n  `color` varchar(6) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `posts_tags`;\nCREATE TABLE `posts_tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) NOT NULL,\n  `post_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tag_id` (`tag_id`),\n  KEY `post_id` (`post_id`),\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \nIt would be nice to be able search on database table **posts** using fulltext search:\n\n```sql\nSELECT *\nFROM posts\nWHERE MATCH(title, body) AGAINST ('something' IN BOOLEAN MODE);\n```\n\nBut it is not possible. It returns something like:\n>   Error in query: The used table type doesn't support FULLTEXT indexes\n\nLet's create another one table with triggers and fulltext indexes. \nWe need to create mirror table. For example:\n\n```sql\nDROP TABLE IF EXISTS `mirror_posts`;\nCREATE TABLE `mirror_posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  PRIMARY KEY (`id`),\n  FULLTEXT KEY `title_body` (`title`,`body`),\n  FULLTEXT KEY `title` (`title`),\n  FULLTEXT KEY `body` (`body`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n```\n\nAnd than we need to create triggers:\n\n```sql\nDELIMITER ;;\n\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\n\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\nUPDATE mirror_posts SET\n    id = NEW.id,\n    title = NEW.title,\n    body = NEW.body\nWHERE id = OLD.id;;\n\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\nDELETE FROM mirror_posts WHERE id = OLD.id;;\n```\n\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\nFinally we can use more complex fulltext search feature:\n\n```sql\nSELECT *\nFROM mirror_posts\nWHERE MATCH(title, body) AGAINST ('something' IN BOOLEAN MODE)\nORDER BY 5 * MATCH(title) AGAINST ('something') + MATCH(body) AGAINST ('something') DESC;\n```\n\nAs I said, this is just workaround, not solution. \nSometimes it's bad practice, because you need copy of indexed columns. \nBut it works. And for small blogs it's sufficient.","frontmatter":"id: 30938e58-9de3-403e-a862-493564630ddd\ntimestamp: 1375126671000\ntitle: Using fulltext searching with InnoDB\nslug: using-fulltext-searching-with-innodb"},{"attributes":{"id":"d9072c23-be9d-4f6a-a89c-565595c73b84","timestamp":1375087004000,"title":"Třída pro připojení k FIO API","slug":"trida-pro-pripojeni-k-fio-api"},"body":"Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://zlml.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n```php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . ' FILE: ' . $exc->getFile() . ' on line: ' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n```\n\nK tomu se hodí právě následující třída:\n\n```php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = 'https://www.fio.cz/ib_api/rest/';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         * @return array|mixed\n         */\n        public function transactions($from = '-1 month', $to = 'now') {\n                $from = \\Nette\\DateTime::from($from)->format('Y-m-d');\n                $to = \\Nette\\DateTime::from($to)->format('Y-m-d');\n                $url = $this->rest_url . 'periods/' . $this->token . '/' . $from . '/' . $to . '/transactions.json';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date('Y');\n                }\n                $url = $this->rest_url . 'by-id/' . $this->token . '/' . $year . '/' . $id . '/transactions.json';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . 'last/' . $this->token . '/transactions.json';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded('curl')) {\n                        throw new \\Exception('Curl extension, does\\'t loaded.');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception('Fio API overheated. Please wait...');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n```\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n```neon\nparameters:\n\tfio_token: '' #token pro přístup do FIO banky\n    \n...\n\nservices:\n\t- Fresh\\Fio(token: %fio_token%)\n    \n...\n```\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.","frontmatter":"id: d9072c23-be9d-4f6a-a89c-565595c73b84\ntimestamp: 1375087004000\ntitle: Třída pro připojení k FIO API\nslug: trida-pro-pripojeni-k-fio-api"},{"attributes":{"id":"a285c880-267e-4070-9139-98b86d63772e","timestamp":1375044812000,"title":"CRON validátor","slug":"cron-validator"},"body":"A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\n\n# Můžeš tohle, nesmíš tamto\n\n\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\n\n1.  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\n2.  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\n3.  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\n4.  povolený rozsah pro minuty: <strong>0-59</strong>\n5.  povolený rozsah pro hodiny: <strong>0-23</strong>\n6.  povolený rozsah pro dny měsíce: <strong>1-31</strong>\n7.  povolený rozsah pro měsíce: <strong>1-12</strong>\n8.  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\n\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\numístit sem celý kód alespoň vytvoření:\n\n```php\n/**\n  * @return Nette\\Application\\UI\\Form\n  */\nprotected function createComponentAddCron() {\n\t$form = new Nette\\Application\\UI\\Form;\n\t$form->addProtection();\n\t$form->addText('minutes', 'Minuty:')\n\t\t->addRule(\\Fresh\\ValidateCron::MINUTES, 'Nevalidní CRON zápis - minuty.');\n\t$form->addText('hours', 'Hodiny:')\n\t\t->addRule(\\Fresh\\ValidateCron::HOURS, 'Nevalidní CRON zápis - hodiny.');\n\t$form->addText('mdays', 'Dny měsíce:')\n\t\t->addRule(\\Fresh\\ValidateCron::MDAYS, 'Nevalidní CRON zápis - mdays.');\n\t$form->addText('months', 'Měsíce:')\n\t\t->addRule(\\Fresh\\ValidateCron::MONTHS, 'Nevalidní CRON zápis - měsíce.');\n\t$form->addText('wdays', 'Dny v týdnu:')\n\t\t->addRule(\\Fresh\\ValidateCron::WDAYS, 'Nevalidní CRON zápis - wdays.');\n\t$form->addText('command', 'Příkaz:')\n\t\t->setRequired('Vyplňte prosím příkaz, který bude CRON spouštět.');\n\t$form->addSubmit('save', 'Přidat nový CRON');\n\t$form->onSuccess[] = $this->addCronSucceeded;\n\treturn $form;\n}\n```\n\nA rovnou bez hloupých povídání celý validátor:\n\n```php\n<?php\n\nnamespace Fresh;\n\n/**\n * Class ValidateCron - inspired by ISPConfig\n * @package Fresh\n */\nclass ValidateCron extends \\Nette\\Object {\n\n        const MINUTES = '\\Fresh\\ValidateCron::validateMinutes';\n        const HOURS = '\\Fresh\\ValidateCron::validateHours';\n        const MDAYS = '\\Fresh\\ValidateCron::validateMdays';\n        const MONTHS = '\\Fresh\\ValidateCron::validateMonths';\n        const WDAYS = '\\Fresh\\ValidateCron::validateWdays';\n\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\n        }\n\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\n        }\n\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\n        }\n\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\n                if($control->getValue() != '@reboot') { // allow value @reboot in month field\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\n                } else {\n                        return TRUE;\n                }\n        }\n\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\n        }\n\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\n                if (preg_match(\"'^[0-9\\-\\,\\/\\*]+$'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\n                        return FALSE;\n                } elseif (preg_match(\"'[\\-\\,\\/][\\-\\,\\/]'\", $value) == true) { // comma, - and / never stand together\n                        return FALSE;\n                }\n                $time_list = explode(\",\", $value);\n                foreach ($time_list as $entry) {\n                        // possible value combinations:\n                        // x               =>      ^(\\d+)$\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\n                        if (preg_match(\"'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$'\", $entry, $matches) == false) {\n                                return FALSE;\n                        }\n                        // matches contains:\n                        // 1       =>      * or value or x-y range\n                        // 2       =>      unused\n                        // 3       =>      value if [1] != *\n                        // 4       =>      empty if no range was used\n                        // 5       =>      2nd value of range if [1] != * and range was used\n                        // 6       =>      empty if step was not used\n                        // 7       =>      step\n                        if ($matches[1] == \"*\") {\n                                // not to check\n                        } else {\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\n                                        return FALSE;\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\n                                        // check if value is in allowed range and not less or equal to first value\n                                        return FALSE;\n                                }\n                        }\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\n                                return FALSE;\n                        }\n                } // end foreach entry loop\n                return TRUE;\n        }\n\n}\n```\n\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\n\n```html\n{form $form}\n\n<ul class=\"error\" n:if=\"$form->allErrors\">\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\n</ul>\n\n...\n\n{/form}\n```","frontmatter":"id: a285c880-267e-4070-9139-98b86d63772e\ntimestamp: 1375044812000\ntitle: CRON validátor\nslug: cron-validator"},{"attributes":{"id":"3e9279b1-89aa-4813-9beb-7bc9f8044dff","timestamp":1375043798000,"title":"Testování presenterů v Nette","slug":"testovani-presenteru-v-nette"},"body":"Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\nV následujících odstavcích bych rád předvedl myšlenku jak si\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\n\n# Nezbytná teorie\n\n\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\na následně daný presenter vyrobit. Například takto:\n\n```php\n$presenterFactory = $this->container->getByType('Nette\\Application\\IPresenterFactory');\n$this->presenter = $presenterFactory->createPresenter('Front:Homepage');\n```\n\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\npomocí inject anotace.\n\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\n\n```php\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\n$response = $this->presenter->run($request);\n```\n\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\n\n```php\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\n```\n\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\n\n```php\n$html = (string)$response->getSource();\n$dom = \\Tester\\DomQuery::fromHtml($html);\n\\Tester\\Assert::true($dom->has('title'));\n```\n\n# Psaní, psaní, psaní...\n\n\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\nzačne být lehce kopírovací nuda.\n\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\nMůj první návrh vypadá přibližně takto:\n\n```php\n<?php\n\nnamespace Test;\n\nclass Presenter extends \\Nette\\Object {\n\n        private $container;\n        private $presenter;\n        private $presName;\n\n        public function __construct(\\Nette\\DI\\Container $container) {\n                $this->container = $container;\n        }\n\n        /**\n         * @param $presName string Fully qualified presenter name.\n         */\n        public function init($presName) {\n                $presenterFactory = $this->container->getByType('Nette\\Application\\IPresenterFactory');\n                $this->presenter = $presenterFactory->createPresenter($presName);\n                $this->presenter->autoCanonicalize = FALSE;\n                $this->presName = $presName;\n        }\n\n        public function test($action, $method = 'GET', $params = array(), $post = array()) {\n                $params['action'] = $action;\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\n                $response = $this->presenter->run($request);\n                return $response;\n        }\n\n        public function testAction($action, $method = 'GET', $params = array(), $post = array()) {\n                $response = $this->test($action, $method, $params, $post);\n\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\n\n                $html = (string)$response->getSource();\n                $dom = \\Tester\\DomQuery::fromHtml($html);\n                \\Tester\\Assert::true($dom->has('title'));\n\n                return $response;\n        }\n\n        public function testForm($action, $method = 'POST', $post = array()) {\n                $response = $this->test($action, $method, $post);\n\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\n\n                return $response;\n        }\n\n}\n```\n\nTestování samotných presenterů je pak již otázkou několika málo řádek:\n\n```php\n<?php\n\nnamespace Test;\n\n$container = require __DIR__ . '/../bootstrap.php';\n\nclass HomepagePresenterTest extends \\Tester\\TestCase {\n\n        public function __construct(\\Nette\\DI\\Container $container) {\n                $this->tester = new \\Test\\Presenter($container);\n        }\n\n        public function setUp() {\n                $this->tester->init('Front:Homepage');\n        }\n\n        public function testRenderDefault() {\n                $this->tester->testAction('default');\n        }\n\n}\n\nid(new HomepagePresenterTest($container))->run();\n```\n\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.","frontmatter":"id: 3e9279b1-89aa-4813-9beb-7bc9f8044dff\ntimestamp: 1375043798000\ntitle: Testování presenterů v Nette\nslug: testovani-presenteru-v-nette"},{"attributes":{"id":"46649054-460c-4258-9ce4-d25d89f63ba8","timestamp":1375041522000,"title":"Portál ZČU dočasně mimo provoz","slug":"portal-zcu-docasne-mimo-provoz"},"body":"Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n<div class=\"alert alert-danger\">Tak dlouho jsem s tímto blogem experimentoval, až jsem o obrázek \npřišel. :-( Představte si tedy prosím screen vyhledávání na kterém je portál ZČU se zaindexovaným\ntitle \"Portál ZČU dočasně mimo provoz&hellip;\"</div>\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:","frontmatter":"id: 46649054-460c-4258-9ce4-d25d89f63ba8\ntimestamp: 1375041522000\ntitle: Portál ZČU dočasně mimo provoz\nslug: portal-zcu-docasne-mimo-provoz"},{"attributes":{"id":"01c2866b-fd82-4562-ab63-dbab3505ee8e","timestamp":1363554156000,"title":"Nette 2.1-dev CliRouter","slug":"nette-2-1-dev-clirouter"},"body":"Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n```php\n<?php\n\nnamespace App;\n\nuse Nette,\n\tNette\\Application\\Routers\\RouteList,\n\tNette\\Application\\Routers\\Route,\n\tNette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Nette\\DI\\Container $container) {\n\t\t$this->container = $container;\n\t}\n\n\t/**\n\t * @return \\Nette\\Application\\IRouter\n\t */\n\tpublic function createRouter() {\n\t\t$router = new RouteList();\n\t\tif ($this->container->parameters['consoleMode']) {\n\t\t\t$router[] = new CliRouter(array('action' => 'Cli:Cli:cron'));\n\t\t} else {\n\t\t\t$router[] = new Route('rss.xml', 'Front:Blog:rss');\n\t\t\t$router[] = new Route('user/<presenter>/<action>[/<id>]', array(\n\t\t\t\t'module' => 'User',\n\t\t\t\t'presenter' => 'Board',\n\t\t\t\t'action' => 'default',\n\t\t\t));\n\t\t\t$router[] = new Route('<presenter>/<action>[/<id>]', array(\n\t\t\t\t'module' => 'Front',\n\t\t\t\t'presenter' => 'Homepage',\n\t\t\t\t'action' => 'default',\n\t\t\t));\n\t\t}\n\t\treturn $router;\n\t}\n\n}\n```\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n```php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n\tpublic function startup() {\n\t\tparent::startup();\n\t\tif (!$this->context->parameters['consoleMode']) {\n\t\t\tthrow new Nette\\Security\\AuthenticationException;\n\t\t}\n\t}\n\n}\n```\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n```php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n\tpublic function actionCron() {\n\t\techo 'FUNGUJU!';\n\t\t$this->terminate();\n\t}\n\n}\n```\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem <code>php index.php</code>. Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze <code>php index.php Front:Homepage:default</code>.","frontmatter":"id: 01c2866b-fd82-4562-ab63-dbab3505ee8e\ntimestamp: 1363554156000\ntitle: Nette 2.1-dev CliRouter\nslug: nette-2-1-dev-clirouter"},{"attributes":{"id":"5920d80f-a65c-40e0-9648-6a95bac6ab87","timestamp":1356648759000,"title":"Návrhový vzor Factory Method","slug":"navrhovy-vzor-factory-method"},"body":"Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\n\n```php\n<?php\nabstract class ACreator {\n\tprotected $attribute;\n\tpublic function __construct($attribute) {\n\t\t$this->attribute = $attribute;\n\t}\n\tabstract public function createConcreteObject();\n}\n```\n\n```php\n<?php\nclass ConcreteCreator extends ACreator {\n\tpublic function createConcreteObject() {\n\t\t$concreteObject = new ConcreteObject($this->attribute);\n\t\treturn $concreteObject;\n\t}\n}\n```\n\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\n\n```php\n<?php\nclass ConcreteObject implements IObject {\n\tprotected $attribute;\n\tpublic function __construct($attribute) {\n\t\t$this->attribute = $attribute;\n\t}\n\tpublic function test() {\n\t\techo $this->attribute;\n\t}\n}\n```\n\nPřípadně jeho rozhraní:\n\n```php\n<?php\ninterface IObject {\n\tpublic function test();\n}\n```\n\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\n\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\n\n```php\n$instance = new ConcreteObject('TEST');\n$instance->test();\n```\n\nPři zapojení továrny je použití zdánlivě složitější.\n\n```php\n$factory = new ConcreteCreator('TEST');\n$instance = $factory->createConcreteObject();\n$instance->test();\n```\n\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\n\n```php\n// pomocí operátoru new:\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n\n// pomocí továrny:\n$factory = new ConcreteCreator('TEST');\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n```\n\nA teď přidejme nový atribut - aktuální rok.\n\n```php\n// pomocí operátoru new:\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n\n// pomocí továrny:\n$factory = new ConcreteCreator('TEST', date('Y'));\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n```\n\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\n\n```php\n<?php\nclass ConcreteObject implements IObject {\n\tprotected $attribute;\n\tprotected $year;\n\tpublic function __construct($attribute, $year) {\n\t\t$this->attribute = $attribute;\n\t\t$this->year = $year;\n\t}\n\t// ...\n}\n\nabstract class ACreator {\n\tprotected $attribute;\n\tprotected $year;\n\tpublic function __construct($attribute, $year) {\n\t\t$this->attribute = $attribute;\n\t\t$this->year = $year;\n\t}\n\tabstract public function createConcreteObject();\n}\n\nclass ConcreteCreator extends ACreator {\n\tpublic function createConcreteObject() {\n\t\t$concreteObject = new ConcreteObject($this->attribute, $this->year);\n\t\treturn $concreteObject;\n\t}\n}\n```\n\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\n\nMimochodem vzpomeňte si na [osm návrhových přikázání](osm-navrhovych-prikazani), kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.","frontmatter":"id: 5920d80f-a65c-40e0-9648-6a95bac6ab87\ntimestamp: 1356648759000\ntitle: Návrhový vzor Factory Method\nslug: navrhovy-vzor-factory-method"},{"attributes":{"id":"e9cd5692-13b4-495f-a63d-1dd5f4923fcb","timestamp":1356550681000,"title":"Návrhový vzor Singleton","slug":"navrhovy-vzor-singleton"},"body":"Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n}\n```\n\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = Object::getInstance();\n```\n\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\n\n```php\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2'; //TRUE\n} else {\n\techo '$obj1 !== $obj2';\n}\n```\n\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = new Object();\n\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2';\n} else {\n\techo '$obj1 !== $obj2'; //TRUE\n}\n```\n\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n}\n```\n\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = clone $obj1;\n\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2';\n} else {\n\techo '$obj1 !== $obj2'; //TRUE\n}\n```\n\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n\tprivate function __clone() {}\n}\n```\n\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = unserialize(serialize($obj1));\n\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2';\n} else {\n\techo '$obj1 !== $obj2'; //TRUE\n}\n```\n\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n\tprivate function __clone() {}\n\tprivate function __wakeup() {}\n}\n```\n\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n\tpublic final function __clone() {\n\t\tthrow new Exception('Objekt nelze klonovat!');\n\t}\n\tpublic final function __wakeup() {\n\t\tthrow new Exception('Objekt nelze deserializovat!');\n\t}\n}\n```","frontmatter":"id: e9cd5692-13b4-495f-a63d-1dd5f4923fcb\ntimestamp: 1356550681000\ntitle: Návrhový vzor Singleton\nslug: navrhovy-vzor-singleton"},{"attributes":{"id":"6ef2212c-312f-45c5-a31b-bb9a7327ff42","timestamp":1356472874000,"title":"Osm návrhových přikázání","slug":"osm-navrhovych-prikazani"},"body":"Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\n\n1. Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\n2. Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\n3. V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\n4. Znovupoužitelnost kódu je lepší než duplicitní kód.\n5. Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\n6. Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\n7. Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\n8. Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\n\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:","frontmatter":"id: 6ef2212c-312f-45c5-a31b-bb9a7327ff42\ntimestamp: 1356472874000\ntitle: Osm návrhových přikázání\nslug: osm-navrhovych-prikazani"},{"attributes":{"id":"0939f66b-9d4b-4646-b787-76fa294fd2c4","timestamp":1353707019000,"title":"Výpočet mediánu","slug":"vypocet-medianu"},"body":"# Zadání\n\n\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \njednoduchost a implementační nenáročnost, paměťová spotřeba.\n\n# Definice\n\n\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\njako je tomu například u průměru.\n\n# Analýza problému\n\n\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\ntotiž o způsob, který zřejmě napadne každého jako první.\n\nPřímočaré řešení\n----------------\n\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\npřípadě.\n\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\nřazení.\n\nAlgoritmus FIND\n---------------\n\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\nmediánu.\n\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\numístěny na levé straně a prvky větší než pivot zase na pravé.\n\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\nnaším mediánem.\n\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\nnásledující odstavce.\n\nAlgoritmus SELECT\n-----------------\n\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\ndělení celé posloupnosti.\n\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\n\n# Srovnání zmíněných algoritmů\n\n\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\nnejlepší možné řešení.\n\n# Závěr\n\n\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\nSELECT, který je sice složitý, ale má vynikající výsledky.","frontmatter":"id: 0939f66b-9d4b-4646-b787-76fa294fd2c4\ntimestamp: 1353707019000\ntitle: Výpočet mediánu\nslug: vypocet-medianu"},{"attributes":{"id":"6dcf0031-975d-4eb2-85d6-e4e00d02dd4a","timestamp":1349557092000,"title":"Tabulkový masakr","slug":"tabulkovy-masakr"},"body":"Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\n\nPodívejte se na první ukázku:\n\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr>\n\t\t<td width=\"33%\">A1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">A2</td>\n\t\t<td width=\"33%\">A3</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"3\">B1</td>\n\t</tr>\n\t<tr>\n\t\t<td>C1</td>\n\t\t<td>C3</td>\n\t</tr>\n\t<tr>\n\t\t<td>D1</td>\n\t\t<td>D3</td>\n\t</tr>\n</table>\n\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\n```html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr>\n\t\t<td width=\"33%\">A1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">A2</td>\n\t\t<td width=\"33%\">A3</td>\n\t</tr>\n\t<tr>\n\t\t<td colspan=\"3\">B1</td>\n\t</tr>\n\t<tr>\n\t\t<td>C1</td>\n\t\t<td>C3</td>\n\t</tr>\n\t<tr>\n\t\t<td>D1</td>\n\t\t<td>D3</td>\n\t</tr>\n</table>\n```\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\n\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\n\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">A1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">A2</td>\n\t\t<td width=\"33%\" colspan=\"4\">A3</td>\n\t\t<td width=\"33%\" rowspan=\"4\">A4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">B1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">B2</td>\n\t\t<td width=\"33%\" colspan=\"4\">B3</td>\n\t\t<td width=\"33%\" rowspan=\"4\">B4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">C1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">C2</td>\n\t\t<td width=\"33%\" colspan=\"4\">C3</td>\n\t\t<td width=\"33%\" rowspan=\"4\">C4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">D1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">D2</td>\n\t\t<td width=\"33%\" colspan=\"4\">D3</td>\n\t\t<td width=\"33%\" rowspan=\"4\">D4</td>\n\t</tr>\n</table>\n\n<br />\n\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr>\n\t\t<td width=\"33%\" rowspan=\"4\">A1</td>\n\t\t<td width=\"33%\" colspan=\"4\">A2</td>\n\t\t<td width=\"33%\" rowspan=\"4\">A3</td>\n\t\t<td width=\"33%\" colspan=\"4\">A4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" rowspan=\"4\">B1</td>\n\t\t<td width=\"33%\" colspan=\"4\">B2</td>\n\t\t<td width=\"33%\" rowspan=\"4\">B3</td>\n\t\t<td width=\"33%\" colspan=\"4\">B4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" rowspan=\"4\">C1</td>\n\t\t<td width=\"33%\" colspan=\"4\">C2</td>\n\t\t<td width=\"33%\" rowspan=\"4\">C3</td>\n\t\t<td width=\"33%\" colspan=\"4\">C4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" rowspan=\"4\">D1</td>\n\t\t<td width=\"33%\" colspan=\"4\">D2</td>\n\t\t<td width=\"33%\" rowspan=\"4\">D3</td>\n\t\t<td width=\"33%\" colspan=\"4\">D4</td>\n\t</tr>\n</table>\n\n<br />\n\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">A1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">A2</td>\n\t\t<td width=\"33%\" colspan=\"4\">A3</td>\n\t\t<td width=\"33%\" colspan=\"4\">A4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" rowspan=\"4\">B1</td>\n\t\t<td width=\"33%\" colspan=\"4\">B2</td>\n\t\t<td width=\"33%\" rowspan=\"4\">B3</td>\n\t\t<td width=\"33%\" rowspan=\"4\">B4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">C1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">C2</td>\n\t\t<td width=\"33%\" colspan=\"4\">C3</td>\n\t\t<td width=\"33%\" colspan=\"4\">C4</td>\n\t</tr>\n\t<tr>\n\t\t<td width=\"33%\" colspan=\"4\">D1</td>\n\t\t<td width=\"33%\" rowspan=\"4\">D2</td>\n\t\t<td width=\"33%\" colspan=\"4\">D3</td>\n\t\t<td width=\"33%\" colspan=\"4\">D4</td>\n\t</tr>\n</table>\n\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\n\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\n```html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\n\t<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\n\t<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\n\t<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\n</table>\n```\nVýsledek je vidět ve třetí ukázce:\n\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n\t<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\n\t<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\n\t<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\n\t<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\n</table>\n\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.","frontmatter":"id: 6dcf0031-975d-4eb2-85d6-e4e00d02dd4a\ntimestamp: 1349557092000\ntitle: Tabulkový masakr\nslug: tabulkovy-masakr"},{"attributes":{"id":"af8c8824-3542-4019-8dc1-dbea1e985808","timestamp":1347738626000,"title":"Lovec matematik","slug":"lovec-matematik"},"body":"Znáte následující hádanku?\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\n\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\n\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\n\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\n\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...","frontmatter":"id: af8c8824-3542-4019-8dc1-dbea1e985808\ntimestamp: 1347738626000\ntitle: Lovec matematik\nslug: lovec-matematik"},{"attributes":{"id":"cec65f8d-f2c5-4820-8ca6-3c6c9c7b1e72","timestamp":1347049798000,"title":"Asymetrická šifra s veřejným klíčem","slug":"asymetricka-sifra-s-verejnym-klicem"},"body":"O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\n\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\n\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\n\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\n\n```\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\n```\n\nDílčí prvočísla si nechám jako tajemství? (-:","frontmatter":"id: cec65f8d-f2c5-4820-8ca6-3c6c9c7b1e72\ntimestamp: 1347049798000\ntitle: Asymetrická šifra s veřejným klíčem\nslug: asymetricka-sifra-s-verejnym-klicem"}]