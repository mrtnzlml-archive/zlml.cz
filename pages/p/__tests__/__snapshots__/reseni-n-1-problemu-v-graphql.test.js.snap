// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div>
  <div
    className="jsx-1307704868 wrapper"
  >
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      ¡Hola! My name is
    </p>
    <h1
      className="jsx-2345896288"
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/"
          onClick={[Function]}
        >
          Martin Zlámal
        </a>
      </span>
    </h1>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
    <h1
      className="jsx-1056554702"
    >
      Řešení N+1 problému v GraphQL
    </h1>
    <div
      className="jsx-1056554702 article"
      dangerouslySetInnerHTML={
        Object {
          "__html": "<p>Na 85. Poslední sobotě v Praze jsem měl workshop a přednášku o GraphQL. Na konci přednášky padl velmi dobrý dotaz ohledně toho, jestli náhodou netrpí GraphQL v určitých situacích N+1 problémem. Načež jsem odvětil, že to není problém GraphQL, ale že ano. Teď je tedy ten správný čas podívat se na tuto situaci konkrétně a pokusit se ji vyřešit. Skvělé je, že <a href=\\"http://webonyx.github.io/graphql-php/\\">knihovna, kterou používám</a> na sebe částečně převzala řešení tohoto nešvaru. Ale o tom až za chvíli...</p>
<h2 id=\\"n-1-probl-m\\">N+1 problém <a href=\\"#n-1-probl-m\\">#</a></h2><p>S <a href=\\"https://secure.phabricator.com/book/phabcontrib/article/n_plus_one/\\">N+1 problémem</a> se setkal každý, kdo naprogramoval alespoň blog s komentáři. Problém nastává pokud se z databáze netahají všechna potřebná data s předstihem. Například pokud u blogu vytáhneme pouze články a až později budeme iterovat články a tahat k nim komentáře, pak máme N+1 problém. Stane se totiž, že položíme na databázi stejný počet dotazů, jako máme článků.</p>
<p>Řešit se to dá dvojím způsobem. Můžeme použít databázový <code>JOIN</code> a v jednom dotázu si vytáhnout vše potřebné (články a kometáře) s tím, že již víme co potřebujeme. A nebo použijeme <code>IN</code> klauzuli a druhým dotazem se doptáme na vše potřebné (zbývající komentáře). Tento přístup se pro GraphQL hodí více.</p>
<p>Hezký příklad tohoto problému je vidět na tomto GraphQL dotazu:</p>
<pre><code>{
  query_1: allWeatherStations {
    edges {
      node {
        ...RecordsFragment
      }
    }
  }
  query_2: allWeatherStations {
    weatherStations {
      ...RecordsFragment
    }
  }
}

fragment RecordsFragment on WeatherStation {
  records {
    id
  }
}
</code></pre><p>Toto by se dalo nazvat M*N+M problémem... :) Kdybych totiž posílal jen první dotaz (dej mi meteostanice a ke každé stanici všechny záznamy), vznikl by dříve popisovaný problém. Jen jsou zde místo článků meteostanice a místo komentářů jednotlivé záznamy stanic. Jenže v GraphQL lze skutečně složit graf a tak se můžu ptát velmi složitě a zamotaně. Dokonce se můžu ptát pořád dokolečka:</p>
<pre><code>{
  articles { # get all articles
    authors { # get all authors of the articles
      theirArticles { # get all articles they wrote
        authors { # get authors of those articles
          theirArticles {
            ...
          }
        }
      }
    }
  }
}
</code></pre><p>Neříkám, že to dává smysl, ale pokud je API dostatečně kompikované, tak se zde můžou objevit cyklické cesty.</p>
<h2 id=\\"-e-en-\\">Řešení <a href=\\"#-e-en-\\">#</a></h2><p>Podívejme se, jak se tahají jednotlivé záznamy pro konkrétní meteostanici:</p>
<pre><code class=\\"lang-php\\">$field-&gt;setResolveFunction(function (WeatherStation $ws, $args, UserId $userId) {
    return $this-&gt;allWsRecords-&gt;execute($userId, $ws-&gt;id());
});
</code></pre>
<p>Slovy řečeno: v callbacku přijde meteostanice a my se zeptáme nějaké modelové třídy na všechny záznamy podle ID meteostanice. To je přesně to místo, kde vzniká N+1 problém. V knihovně <a href=\\"https://github.com/webonyx/graphql-php\\">webonyx/graphql-php</a> je od verze <code>v0.9.0</code> k dispozici objekt <code>GraphQL\\\\Deferred</code>, který perfektně poslouží k optimalizaci:</p>
<pre><code class=\\"lang-php\\">$field-&gt;setResolveFunction(function (WeatherStation $ws, $args, UserId $userId) {
    $this-&gt;allWsRecords-&gt;buffer($ws-&gt;id());

    return new \\\\GraphQL\\\\Deferred(function() use ($userId, $ws) {
        return $this-&gt;allWsRecords-&gt;execute($userId, $ws-&gt;id());
    });
});
</code></pre>
<p>Vtip je v tom, že při řešení dotazu prochází knihovna <code>webonyx/graphql-php</code> celý graf a zjišťuje potřebné hodnoty. Ve chvíli kdy dojde k našemu uzlu/listu, tak si jen poznamenáme (buffer) jaké ID bylo práve vyžadováno a vrátíme onen <code>Deferred</code> objekt. Až celý proces dojde na samotný konec, tak se knihovna zeptá ještě na ty odložené objekty. V tu chvíli ale již víme jaké všechny ID jsou potřeba a můžeme je získat jedním dotazem a postupně vracet:</p>
<pre><code class=\\"lang-php\\">if(empty($this-&gt;weatherStationIdsBuffer)) {
    return $this-&gt;wsrr-&gt;ofWeatherStationId($weatherStationId);
} else {
    static $result = NULL; //memoization
    if ($result === NULL) {
        $result = $this-&gt;wsrr-&gt;ofAllWeatherStationIds($this-&gt;weatherStationIdsBuffer);
    }
    return $result[$weatherStationId-&gt;id()];
}
</code></pre>
<p>Tedy pokud není nic v bufferu, prostě se na to jedno ID zeptáme do databáze. Zde není co optimalizovat. V opačném případě však pošleme dotaz s <code>IN</code> a zeptáme se na všechny ID, které jsou v bufferu. Ty budeme chvíli držet v lokální cache a postupně ven servírovat jednotlivé záznamy (bez dalších dotazů do databáze).</p>
<p>Výsledek je následující (předtím):</p>
<pre><code class=\\"lang-sql\\">SELECT t0.* FROM user_accounts t0 WHERE t0.id = ?

SELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?

SELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?
</code></pre>
<p>A potom:</p>
<pre><code class=\\"lang-sql\\">SELECT t0.* FROM user_accounts t0 WHERE t0.id = ?
SELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?
SELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?
SELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id IN (
    &#39;df40acdd-5222-4f89-a693-999f2d3f3eb6&#39;,
    &#39;6f5fb680-f5e3-4d8c-b7e1-27205b848657&#39;,
    &#39;14837156-c662-4e8c-b527-2227506c2bf7&#39;,
    &#39;2965494d-d13f-4415-8535-b910ac29326a&#39;,
    &#39;662c0434-9eca-4241-9462-ce85d279fd6b&#39;,
    &#39;36eed5a8-08fd-48db-8153-67355d092201&#39;
)
</code></pre>
<p>To je obrovské zlepšení. Zejména když si uvědomíte, že k optimalizaci N+1 dotazu nedochází pouze naivně v rámci jedné cesty v grafu, ale v rámci úplně celého grafu. Pokud chcete vidět konkrétní změnu v rámci projektu z workshopu, tak je vidět v commitu <a href=\\"https://github.com/adeira/connector/commit/ed8b43257b778b6b2d4adb1b92baae18daf36905\\">ed8b43</a>.</p>
<p>Toliko má odpoveď... :)</p>
",
        }
      }
    />
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <strong>
        Do you have any comments? That's great!
         
        <span
          className="jsx-3140515621"
        >
          <a
            className="jsx-3140515621 "
            href="https://twitter.com/home?status=https%3A%2F%2Fzlml.cz%2Freseni-n-1-problemu-v-graphql%20cc%20%40mrtnzlml"
          >
            Tweet them
          </a>
        </span>
         
        so everyone can hear you…
      </strong>
    </p>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
  </div>
</div>
`;
