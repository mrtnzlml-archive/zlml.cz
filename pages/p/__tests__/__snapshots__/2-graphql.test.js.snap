// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div>
  <div
    className="jsx-1307704868 wrapper"
  >
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      ¡Hola! My name is
    </p>
    <h1
      className="jsx-2345896288"
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/"
          onClick={[Function]}
        >
          Martin Zlámal
        </a>
      </span>
    </h1>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
    <h1
      className="jsx-1056554702"
    >
      GraphQL
    </h1>
    <div
      className="jsx-1056554702 article"
      dangerouslySetInnerHTML={
        Object {
          "__html": "<p>Z <a href=\\"1-od-komponent-zpet-ke-komponentam\\">minulého dílu</a> by mělo být všem jasné, jak jsem se dostal až sem. Od PHP komponent k webovým komponentám, které vlastně nejsou skutečné webové komponenty, ale jen kus JS kódu, který implementuje vlastní způsob webových komponent - React. Jsem přesvědčen o tom, že pro další pokračování je nutné vysvětlit, jak taková aplikace funguje. Takže...</p>
        <h2 id=\\"jak-takov-aplikace-funguje-\\">Jak taková aplikace funguje? <a href=\\"#jak-takov-aplikace-funguje-\\">#</a></h2><p>Jestli mě něco na JS světě už dlouhou dobu děsí, tak je to skutečnost, že vlastně nikdo neví, jak by taková aplikace měla vypadat. Ačkoliv je mnoho lidí přesvědčeno o své pravdě, neuvědomují si subjektivitu jejich tvrzení. Z toho důvodu je teď milion implementací a návrhů a každý to dělá trošku jinak. Pokud to však vezmu co nejvíce objektivně, tak by se taková aplikace dala popsat následovně:</p>
        <ul>
        <li>v prohlížeči běží JS kód, který se stará o vykreslování stránky s využitím veškeré síly JavaScriptu</li>
        <li><em>volitelně</em>: JS kód posílá do prohlížeče třeba NodeJS server, který dokáže vyrenderovat JS a poslat rovnou hotovou stránku do prohlížeče (včetně připravených dat)</li>
        <li>na serveru běží kód (v mém případě Nette), který čeká na co se ho JS kód zeptá prostřednictvím (GraphQL) API a podle toho odpoví</li>
        </ul>
        <p>Proč mi na serveru běží PHP, když hodně lidí preferuje mít JS i na serveru? Protože jsem skálopevně přesvědčen, že dokážu v PHP napsat lepší aplikaci s využitím veškerých myšlenek DDD co zvládnu pochopit (narozdíl od JS). End of story...</p>
        <p>No a jak už titulek tohoto článku napovídá, tak mnou navrhovaný způsob je právě <strong>GraphQL</strong> (<a href=\\"http://graphql.org/\\">link</a>).</p>
        <h2 id=\\"graphql-queries\\">GraphQL queries <a href=\\"#graphql-queries\\">#</a></h2><p>GraphQL je nesmírně chytrý způsob jak se ptát API a přitom je to tak jednoduché, až mi přijde hloupé o tom psát. Pomocí GraphQL se lze serveru zeptat přímo na konkrétní věci. Tedy jako když se ptáte REST API, ale s tím rozdílem, že součástí požadavku je i informace o tom, co má API vrátit. Je dokonce možné zeptat se i více &quot;endpointů&quot; najednou. Zkuste si toto v REST API... :) Naopak GraphQL vyžaduje explicitní vyjmenování toho co chcete, takže jednoduše (pokud vím) nelze napsat dotaz, který by vrátil vše co daný endpoint umí.</p>
        <p>Pojďme si to trošku vyzkoušet. Jako dobré hřiště pro dotazy poslouží <a href=\\"http://graphql-swapi.parseapp.com/\\">tato online aplikace</a>. Dotazy se vždy posílají na jednu adresu (vetšinou <code>/graphql</code>) s tím, že se mění pouze obsah zprávy, který putuje v POST. To je velký rozdíl oproti REST API. Zde je jen jedna adresa, ale memí se obsah dotazu. Právě to přidává na dynamice dotazování - nejsme limitování na URL adresy. Takže když chceme vytáhnout z API např. všechny filmy, pošleme tento dotaz:</p>
        <pre><code>{
          allFilms {
            totalCount
            films {
              id
              title
              director
            }
          }
        }
        </code></pre><p>Tento zvláštní zápis říká, že se ptám na všechny filmy (<code>allFilms</code>) a zajímá mě kolik jich je. Zároveň chci u jednotlivých filmů vrátit jejich ID, název a režiséra. API mi pak vrátí dlouhý JSON:</p>
        <pre><code class=\\"lang-js\\">{
          &quot;data&quot;: {
            &quot;allFilms&quot;: {
              &quot;totalCount&quot;: 6,
              &quot;films&quot;: [
                {
                  &quot;id&quot;: &quot;ZmlsbXM6MQ==&quot;,
                  &quot;title&quot;: &quot;A New Hope&quot;,
                  &quot;director&quot;: &quot;George Lucas&quot;
                },
                ...
              ]
            }
          }
        }
        </code></pre>
        <p><a href=\\"http://graphql-swapi.parseapp.com/?query=%7B%0A%20%20allFilms%20%7B%0A%20%20%20%20totalCount%0A%20%20%20%20films%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20title%0A%20%20%20%20%20%20director%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&amp;operationName=null\\">Vyzkoušejte si to</a>. Chtěl bych ještě vědět jaké planety jsou ve filmu? Stačí rozšířit dotaz:</p>
        <pre><code>{
          allFilms {
            totalCount
            films {
              id
              title
              director
              planetConnection {
                planets {
                  name
                }
              }
            }
          }
        }
        </code></pre><p>API vrátí ještě delší JSON. Vyzkoušejme jiný příklad. Co když mám k dispozici ID filmu, jak se zeptám pouze na ten konkrétní film? Pošleme ID filmu jako paramter dotazu:</p>
        <pre><code class=\\"lang-js\\">{
          film(id: &quot;ZmlsbXM6MQ==&quot;) {
            title
          }
        }
        </code></pre>
        <p>A teď ta nejvíce úžasná část. Chci si jedním šmahem vytáhnout film, člověka a všechny planety? Easy:</p>
        <pre><code class=\\"lang-js\\">{
          film(id: &quot;ZmlsbXM6MQ==&quot;) {
            title
          }
          person(id: &quot;cGVvcGxlOjE=&quot;) {
            name
          }
          allPlanets {
            planets {
              name
            }
          }
        }
        </code></pre>
        <p>A výsledek? Ultra dlouhý JSON:</p>
        <pre><code class=\\"lang-js\\">{
          &quot;data&quot;: {
            &quot;film&quot;: {
              &quot;title&quot;: &quot;A New Hope&quot;
            },
            &quot;person&quot;: {
              &quot;name&quot;: &quot;Luke Skywalker&quot;
            },
            &quot;allPlanets&quot;: {
              &quot;planets&quot;: [
                {
                  &quot;name&quot;: &quot;Tatooine&quot;
                },
                {
                  &quot;name&quot;: &quot;Alderaan&quot;
                },
                ...
              ]
            }
          }
        }
        </code></pre>
        <p>Asi nemá smysl zanořovat se hlouběji. Princip by měl být jasný a samotné API je do jisté míry ovlivněno jeho návrhem (zde stránkováním). Jednoduše mohu jedním POST dotazem (což je ten zvláštní řetězec vypadající jako zjednodušený JSON) získat z API informace, které přesně moje React komponenta potřebuje. Toho některé knihovny silně využívají a vrácený výsledek posílají v properties přímo komponentě, který se stará <strong>pouze</strong> o vykreslování. Uvedu zde pouze krátký příklad toho co tím myslím (podrobněji to můžeme řešit později).</p>
        <p><code>DataSourcesContainer</code> je komponenta, která využívá <a href=\\"http://dev.apollodata.com/react/\\">Apollo</a> a cíl této komponenty je pouze vytáhnout data a vykresení delegovat někam dál (<code>Row</code>).</p>
        <pre><code class=\\"lang-js\\">const DataSourcesContainer = (props) =&gt; {
            let {data: {loading, devices}} = props;
            return loading ? null :
                &lt;div&gt;
                    &lt;h2&gt;Data Sources&lt;/h2&gt;
                    {devices.map(dataSource =&gt;
                        &lt;Row key={dataSource.id} dataSource={dataSource}/&gt;
                    )}
                &lt;/div&gt;;
        };
        
        export default graphql(gql\`
          query {
            devices {
              id,
              name,
              records
            }
          }
        \`)(DataSourcesContainer);
        </code></pre>
        <p>Až teprve <code>Row</code> se stará o vykreslení, ale už nikdy nikdy nepošle dotaz na API:</p>
        <pre><code class=\\"lang-js\\">const Row = (props) =&gt; {
            let ds = props.dataSource;
            return &lt;div&gt;{ds.name} &lt;Link to={\`/data-sources/\${ds.id}\`}&gt;{ds.id}&lt;/Link&gt; ({ds.records.length} records available)
            &lt;/div&gt;;
        };
        
        Row.propTypes = {
            dataSource: React.PropTypes.shape({
                id: React.PropTypes.string,
                name: React.PropTypes.string,
                records: React.PropTypes.arrayOf(React.PropTypes.string)
            }).isRequired,
        };
        
        export default Row;
        </code></pre>
        <p>Nechápu proč si někdo říká React programátor... :))</p>
        <h2 id=\\"graphql-mutations\\">GraphQL mutations <a href=\\"#graphql-mutations\\">#</a></h2><p>Dobré API však potřebuje ještě minimálně jedu věc - možnost modifikace dat. K tomu slouží mutace. Zde opět musí aplikace (Nette) nadefinovat jaké jsou &quot;endpointy&quot; a jaké mají parametry. Taková mutace potom může vrátit nějaký datový typ a zde se to chová úplně stejně jako <em>queries</em>.</p>
        <p>Tak kupříkladu přihlášení. Z mého pohledu je to mutace, protože měním stav aplikace a proto má moje aplikace připravenou tuto mutaci (toto je skutečný příklad z projektu <a href=\\"https://github.com/adeira/connector\\">adeira/connector</a> pokud se chcete šťourat v kódu):</p>
        <pre><code>type Mutation {
          login(username: String!, password: String!): User
        }
        </code></pre><p>Tzn. že pokud pošlu dotaz na to správné místo, tak mi API vratí uživatele, nebo mě odmítne. Využijeme CURL:</p>
        <pre><code>curl -XPOST -H &quot;Content-Type:application/graphql&quot; -d &#39;{&quot;query&quot;: &quot;mutation {login(username:\\\\&quot;test\\\\&quot;,password:\\\\&quot;test\\\\&quot;){id,token}}&quot;}&#39; http://connector.adeira.localhost/graphql | jq .
        </code></pre><p>A protože jsem zadal správné přihlašovacé údaje, tak mi API vrátí ID a <a href=\\"https://jwt.io/\\">JWT token</a>, protože o to jsem si v dotazu řekl:</p>
        <pre><code class=\\"lang-js\\">{
          &quot;data&quot;: {
            &quot;login&quot;: {
              &quot;id&quot;: &quot;4ff2f293-9d21-4407-a6af-08f766e06cb3&quot;,
              &quot;token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE0ODMxODE3OTksImV4cCI6MTQ4MzE4NTM5OSwidXVpZCI6IjRmZjJmMjkzLTlkMjEtNDQwNy1hNmFmLTA4Zjc2NmUwNmNiMyJ9.o2aHdbjgtg80e_yXdFJSy4gCTb-4exEbNQbaOK9xa7nyiLpfvYe0FBPizz0XUVrE1JDzkW9m3QnupiVtTDyZ2g&quot;
            }
          }
        }
        </code></pre>
        <p>Zde je nutné zdůraznit, že je naprosto zásadní, aby aplikace používala HTTPS. Co když zadám špatné heslo? API samozřejmě náležitě odpoví (včetně správného HTTP kódu):</p>
        <pre><code class=\\"lang-js\\">{
          &quot;data&quot;: {
            &quot;login&quot;: null
          },
          &quot;errors&quot;: [
            {
              &quot;message&quot;: &quot;The password is incorrect.&quot;,
              &quot;locations&quot;: [
                {
                  &quot;line&quot;: 1,
                  &quot;column&quot;: 11
                }
              ]
            }
          ]
        }
        </code></pre>
        <p>Z API si tak můžu vytáhnout vše co potřebuju pro změnu stavu aplikace. V tomto případě je to jen <a href=\\"https://jwt.io/\\">JWT token</a>, který si uložím třeba do local storage a jsem na frontendu přihlášen...</p>
        <p>Tento článek se již natáhl více než bych si přál a proto jsem vypustil informaci o implementaci na straně PHP. To totiž vydá na samostatnou kapitolku, takže si to nechám na někdy jindy (možná hned příště, aby to šlo pěkně popořadě).</p>
        <p>Podělte se prosím o postřehy.</p>
        <p>Každý pozorný čtenář si také jistě všiml změny designu (nemluvě o přechodu na AWS) - líbí? :)</p>
        ",
        }
      }
    />
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <strong>
        Do you have any comments? That's great!
         
        <span
          className="jsx-3140515621"
        >
          <a
            className="jsx-3140515621 "
            href="https://twitter.com/home?status=https%3A%2F%2Fzlml.cz%2F2-graphql%20cc%20%40mrtnzlml"
          >
            Tweet them
          </a>
        </span>
         
        so everyone can hear you…
      </strong>
    </p>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
  </div>
</div>
`;
