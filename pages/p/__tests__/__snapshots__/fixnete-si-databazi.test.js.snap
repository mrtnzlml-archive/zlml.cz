// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div>
  <div
    className="jsx-1307704868 wrapper"
  >
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      ¡Hola! My name is
    </p>
    <h1
      className="jsx-2345896288"
    >
      <span
        className="jsx-364771521"
      >
        <a
          className="jsx-364771521"
          href="/"
          onClick={[Function]}
        >
          Martin Zlámal
        </a>
      </span>
    </h1>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-364771521"
      >
        <a
          className="jsx-364771521"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
    <h1
      className="jsx-1056554702"
    >
      Fixněte si databázi
    </h1>
    <div
      className="jsx-1056554702 article"
      dangerouslySetInnerHTML={
        Object {
          "__html": "<p>Možná to znáte. Již nějaký čas nepoužíváte žádný SQL soubor a strukturu databáze si generujete z entit pomocí Doctrine. Je to super, rychlé a funguje to. Paráda. Jenže málokterá databáze se obejde bez nějakých inicializačních dat. Jenže jak na to?</p>
        <h2 id=\\"prvn-p-stup\\">První přístup <a href=\\"#prvn-p-stup\\">#</a></h2><p>Nebudu ho popisovat moc dlouho, protože ukazuje přesně to, co nechci ukázat. Jendoduše si napíšete nějaké to SQL, které pak nahrnete do databáze. Třeba nějak takto:</p>
        <pre><code class=\\"lang-sql\\">REPLACE INTO \`options\` (\`key\`, \`value\`)
        VALUES
        (&#39;option1&#39;, &#39;value1&#39;),
        (&#39;option2&#39;, &#39;value2&#39;),
        (&#39;option3&#39;, &#39;value3&#39;);
        </code></pre>
        <p>To jak si to pošlete do databáze je celkem jedno. Jestli ručně, nebo přes PHP. Pořád někde zůstává SQL. Proč mi to vadí? Tak třeba zde na blogu je nějaká instalace. A protože jsem se ještě nedokopal k tomu to přepsat, tak musím mít tyto soubory dva. Jeden pro MySQL a druhý pro PosgreSQL. <em>(Jo správně, blog jde nainstalovat na více databází...)</em> A to je voser.</p>
        <p>Ale jsou i projekty, kde jsem to udělal rovnou pořádně (i když jsou jen na jedné databázi).</p>
        <h2 id=\\"lep-p-stup-pomoc-fixtures\\">Lepší přístup pomocí fixtures <a href=\\"#lep-p-stup-pomoc-fixtures\\">#</a></h2><p>Znáte <a href=\\"https://github.com/doctrine/data-fixtures\\">Doctrine Data Fixtures Extension</a>? Neznáte? Tak to doporučuji, protože vám pomohou vyřešit přesně tento problém. Lépe tuto knihovnu poznáte pomocí composeru:</p>
        <pre><code>composer require doctrine/data-fixtures
        </code></pre><p>Samozřejmě je takový nepsaný předpoklad, že používáte Doctrine... :) Co dál? Ještě než se pustím do dalšího vysvětlování, bylo by fajn napsat si nějaký command. Na takový command objekt se nejlépe hodí moje oblíbená knihovna <a href=\\"https://github.com/Kdyby/Console\\">Kdyby/Console</a>, která integruje <a href=\\"http://symfony.com/doc/current/components/console/introduction.html\\">command ze Symfony</a>. Už jsem o tom psal něco málo <a href=\\"kdyby-console\\">dříve</a>. A díky této přehršli odkazů již víte jak na to a můžeme rovnou nějaký psát. A protože jsem líný programátor, tak se podívám jak to vyřešil <a href=\\"https://github.com/doctrine/DoctrineFixturesBundle/blob/master/Command/LoadDataFixturesDoctrineCommand.php\\">někdo jiný</a>. A trošku si to zjedoduším:</p>
        <pre><code class=\\"lang-php\\">&lt;?php
        
        use Doctrine\\\\Common\\\\DataFixtures\\\\Executor\\\\ORMExecutor;
        use Doctrine\\\\Common\\\\DataFixtures\\\\Loader;
        use Doctrine\\\\Common\\\\DataFixtures\\\\Purger\\\\ORMPurger;
        use Kdyby\\\\Doctrine\\\\EntityManager;
        use Symfony\\\\Component\\\\Console\\\\Command\\\\Command;
        use Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface;
        use Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;
        
        class DefaultData extends Command
        {
        
            /** @var EntityManager @inject */
            public $em;
        
            protected function configure()
            {
                $this
                    -&gt;setName(&#39;orm:demo-data:load&#39;)
                    -&gt;setDescription(&#39;Load data fixtures to your database.&#39;);
                    //-&gt;addOption...
            }
        
            protected function execute(InputInterface $input, OutputInterface $output)
            {
                try {
                    $loader = new Loader();
                    $loader-&gt;loadFromDirectory(__DIR__ . &#39;/../basic&#39;);
                    $fixtures = $loader-&gt;getFixtures();
        
                    $purger = new ORMPurger($this-&gt;em);
        
                    $executor = new ORMExecutor($this-&gt;em, $purger);
                    $executor-&gt;setLogger(function ($message) use ($output) {
                        $output-&gt;writeln(sprintf(&#39;  &lt;comment&gt;&gt;&lt;/comment&gt; &lt;info&gt;%s&lt;/info&gt;&#39;, $message));
                    });
                    $executor-&gt;execute($fixtures);
                    return 0; // zero return code means everything is ok
                } catch (\\\\Exception $exc) {
                    $output-&gt;writeLn(&quot;&lt;error&gt;{$exc-&gt;getMessage()}&lt;/error&gt;&quot;);
                    return 1; // non-zero return code means error
                }
            }
        }
        </code></pre>
        <p>Ok, to jsem to možná ořezal více než je třeba. Mrkněte na tu ukázku pro Symfony, bude to velmi podobné. A teď už konečně k samotným fixture objektům. To jsou ty co načítám ze složky basic pomocí <code>loadFromDirectory</code>. Jedná o objekty, které implementují interface <code>FixtureInterface</code>, nebo možná lépe dědí od abstraktní třídy <code>AbstractFixture</code>. Obojí je v <code>Doctrine\\\\Common\\\\DataFixtures</code> namespace. Objekt obsahující defaultní uživatele může vypadat takto:</p>
        <pre><code class=\\"lang-php\\">&lt;?php
        
        use Doctrine\\\\Common\\\\Persistence\\\\ObjectManager;
        use Nette\\\\Security\\\\Passwords;
        
        class UsersFixture extends \\\\Doctrine\\\\Common\\\\DataFixtures\\\\AbstractFixture
        {
        
            public function load(ObjectManager $manager)
            {
                $admin = new \\\\Users\\\\User(&#39;admin@nette.org&#39;);
                $admin-&gt;setPassword(Passwords::hash(&#39;admin&#39;));
                $admin-&gt;addRole($this-&gt;getReference(&#39;admin-role&#39;));
                $manager-&gt;persist($admin);
        
                $demo = new \\\\Users\\\\User(&#39;demo@nette.org&#39;);
                $demo-&gt;setPassword(Passwords::hash(&#39;demo&#39;));
                $demo-&gt;addRole($this-&gt;getReference(&#39;demo-role&#39;));
                $manager-&gt;persist($demo);
        
                $manager-&gt;flush();
        
                $this-&gt;addReference(&#39;admin-user&#39;, $admin);
                $this-&gt;addReference(&#39;demo-user&#39;, $demo);
            }
        
        }
        </code></pre>
        <p>V čem je to tak parádní? Používám PHP kód, používám vlastní nadefinované entity. Hned vidím, že mi to fugnuje, ověřuji svůj návrh databáze a rovnou poskytuji dalším ukázku toho, jak jsem to myslel. Za povšimnutí stojí funkce <code>addReference</code> a <code>getReference</code>. Je jasné, že v každé relační databázi budou nějaké relace a právě k tomu tyto funkce slouží. Vytvořím si tedy nějaké ukazatele a ty pak mohu použít v jiné části demo dat. Lépe to  bude vidět na druhé tabulce:</p>
        <pre><code class=\\"lang-php\\">&lt;?php
        
        use Doctrine\\\\Common\\\\Persistence\\\\ObjectManager;
        
        class RolesFixture extends \\\\Doctrine\\\\Common\\\\DataFixtures\\\\AbstractFixture
        {
        
            public function load(ObjectManager $manager)
            {
                $user = new \\\\Users\\\\Role();
                $user-&gt;setName(\\\\Users\\\\Role::DEMO_USER);
                $manager-&gt;persist($user);
        
                $admin = new \\\\Users\\\\Role();
                $admin-&gt;setName(\\\\Users\\\\Role::ADMIN);
                $manager-&gt;persist($admin);
        
                $manager-&gt;flush();
        
                $this-&gt;addReference(&#39;demo-role&#39;, $user);
                $this-&gt;addReference(&#39;admin-role&#39;, $admin);
            }
        
        }
        </code></pre>
        <p>Vidíte? Mám role, vytvořím si na ně odkaz a používám je při definici uživatele. Vyzkoušejte si to. Uvidíte, jak se krásně naplní referenční tabulky a vše bude tak, jak to má být...</p>
        <p>Jen pozor na jedno věc. Ohlídejte si <a href=\\"https://github.com/doctrine/data-fixtures#fixture-ordering\\">pořadí těchto objektů</a>. To lze vyřešit implementací rozhraní <code>OrderedFixtureInterface</code>, nebo <code>DependentFixtureInterface</code>, což je o něco lepší přístup.</p>
        <p>A jak toto celé použít? Však už to znáte:</p>
        <pre><code>λ php index.php
        λ php index.php orm:schema-tool:create
        λ php index.php orm:demo-data:load
        </code></pre><p>První příkaz vám nabídne všechny dostupné příkazy, druhý vygeneruje strukturu databáze bez dat a poslední spustí natažení demo dat. Pak už se jen kocháte:</p>
        <pre><code>λ php index.php orm:demo-data:load --demo
        Careful, database will be purged. Do you want to continue Y/N ? y
          &gt; purging database
          &gt; loading RolesFixture
          &gt; loading UsersFixture
          &gt; loading ArticlesFixture
          &gt; loading ProductsFixture
          ...
        </code></pre>",
        }
      }
    />
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <strong>
        Do you have any comments? That's great!
         
        <span
          className="jsx-364771521"
        >
          <a
            className="jsx-364771521 "
            href="https://twitter.com/home?status=https%3A%2F%2Fzlml.cz%2Ffixnete-si-databazi%20cc%20%40mrtnzlml"
          >
            Tweet them
          </a>
        </span>
         
        so everyone can hear you…
      </strong>
    </p>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-364771521"
      >
        <a
          className="jsx-364771521"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
  </div>
</div>
`;
