// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div>
  <div
    className="jsx-1307704868 wrapper"
  >
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      ¡Hola! My name is
    </p>
    <h1
      className="jsx-2345896288"
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/"
          onClick={[Function]}
        >
          Martin Zlámal
        </a>
      </span>
    </h1>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
    <h1
      className="jsx-1056554702"
    >
      Fixněte si databázi
    </h1>
    <div
      className="jsx-1056554702 article"
      dangerouslySetInnerHTML={
        Object {
          "__html": "<p>Možná to znáte. Již nějaký čas nepoužíváte žádný SQL soubor a strukturu databáze si generujete z entit pomocí Doctrine. Je to super, rychlé a funguje to. Paráda. Jenže málokterá databáze se obejde bez nějakých inicializačních dat. Jenže jak na to?</p>
<h2 id=\\"prvn-p-stup\\">První přístup <a href=\\"#prvn-p-stup\\">#</a></h2><p>Nebudu ho popisovat moc dlouho, protože ukazuje přesně to, co nechci ukázat. Jendoduše si napíšete nějaké to SQL, které pak nahrnete do databáze. Třeba nějak takto:</p>
<pre><code class=\\"lang-sql\\">REPLACE INTO \`options\` (\`key\`, \`value\`)
VALUES
(&#39;option1&#39;, &#39;value1&#39;),
(&#39;option2&#39;, &#39;value2&#39;),
(&#39;option3&#39;, &#39;value3&#39;);
</code></pre>
<p>To jak si to pošlete do databáze je celkem jedno. Jestli ručně, nebo přes PHP. Pořád někde zůstává SQL. Proč mi to vadí? Tak třeba zde na blogu je nějaká instalace. A protože jsem se ještě nedokopal k tomu to přepsat, tak musím mít tyto soubory dva. Jeden pro MySQL a druhý pro PosgreSQL. <em>(Jo správně, blog jde nainstalovat na více databází...)</em> A to je voser.</p>
<p>Ale jsou i projekty, kde jsem to udělal rovnou pořádně (i když jsou jen na jedné databázi).</p>
<h2 id=\\"lep-p-stup-pomoc-fixtures\\">Lepší přístup pomocí fixtures <a href=\\"#lep-p-stup-pomoc-fixtures\\">#</a></h2><p>Znáte <a href=\\"https://github.com/doctrine/data-fixtures\\">Doctrine Data Fixtures Extension</a>? Neznáte? Tak to doporučuji, protože vám pomohou vyřešit přesně tento problém. Lépe tuto knihovnu poznáte pomocí composeru:</p>
<pre><code>composer require doctrine/data-fixtures
</code></pre><p>Samozřejmě je takový nepsaný předpoklad, že používáte Doctrine... :) Co dál? Ještě než se pustím do dalšího vysvětlování, bylo by fajn napsat si nějaký command. Na takový command objekt se nejlépe hodí moje oblíbená knihovna <a href=\\"https://github.com/Kdyby/Console\\">Kdyby/Console</a>, která integruje <a href=\\"http://symfony.com/doc/current/components/console/introduction.html\\">command ze Symfony</a>. Už jsem o tom psal něco málo <a href=\\"kdyby-console\\">dříve</a>. A díky této přehršli odkazů již víte jak na to a můžeme rovnou nějaký psát. A protože jsem líný programátor, tak se podívám jak to vyřešil <a href=\\"https://github.com/doctrine/DoctrineFixturesBundle/blob/master/Command/LoadDataFixturesDoctrineCommand.php\\">někdo jiný</a>. A trošku si to zjedoduším:</p>
<pre><code class=\\"lang-php\\">&lt;?php

use Doctrine\\\\Common\\\\DataFixtures\\\\Executor\\\\ORMExecutor;
use Doctrine\\\\Common\\\\DataFixtures\\\\Loader;
use Doctrine\\\\Common\\\\DataFixtures\\\\Purger\\\\ORMPurger;
use Kdyby\\\\Doctrine\\\\EntityManager;
use Symfony\\\\Component\\\\Console\\\\Command\\\\Command;
use Symfony\\\\Component\\\\Console\\\\Input\\\\InputInterface;
use Symfony\\\\Component\\\\Console\\\\Output\\\\OutputInterface;

class DefaultData extends Command
{

    /** @var EntityManager @inject */
    public $em;

    protected function configure()
    {
        $this
            -&gt;setName(&#39;orm:demo-data:load&#39;)
            -&gt;setDescription(&#39;Load data fixtures to your database.&#39;);
            //-&gt;addOption...
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        try {
            $loader = new Loader();
            $loader-&gt;loadFromDirectory(__DIR__ . &#39;/../basic&#39;);
            $fixtures = $loader-&gt;getFixtures();

            $purger = new ORMPurger($this-&gt;em);

            $executor = new ORMExecutor($this-&gt;em, $purger);
            $executor-&gt;setLogger(function ($message) use ($output) {
                $output-&gt;writeln(sprintf(&#39;  &lt;comment&gt;&gt;&lt;/comment&gt; &lt;info&gt;%s&lt;/info&gt;&#39;, $message));
            });
            $executor-&gt;execute($fixtures);
            return 0; // zero return code means everything is ok
        } catch (\\\\Exception $exc) {
            $output-&gt;writeLn(&quot;&lt;error&gt;{$exc-&gt;getMessage()}&lt;/error&gt;&quot;);
            return 1; // non-zero return code means error
        }
    }
}
</code></pre>
<p>Ok, to jsem to možná ořezal více než je třeba. Mrkněte na tu ukázku pro Symfony, bude to velmi podobné. A teď už konečně k samotným fixture objektům. To jsou ty co načítám ze složky basic pomocí <code>loadFromDirectory</code>. Jedná o objekty, které implementují interface <code>FixtureInterface</code>, nebo možná lépe dědí od abstraktní třídy <code>AbstractFixture</code>. Obojí je v <code>Doctrine\\\\Common\\\\DataFixtures</code> namespace. Objekt obsahující defaultní uživatele může vypadat takto:</p>
<pre><code class=\\"lang-php\\">&lt;?php

use Doctrine\\\\Common\\\\Persistence\\\\ObjectManager;
use Nette\\\\Security\\\\Passwords;

class UsersFixture extends \\\\Doctrine\\\\Common\\\\DataFixtures\\\\AbstractFixture
{

    public function load(ObjectManager $manager)
    {
        $admin = new \\\\Users\\\\User(&#39;admin@nette.org&#39;);
        $admin-&gt;setPassword(Passwords::hash(&#39;admin&#39;));
        $admin-&gt;addRole($this-&gt;getReference(&#39;admin-role&#39;));
        $manager-&gt;persist($admin);

        $demo = new \\\\Users\\\\User(&#39;demo@nette.org&#39;);
        $demo-&gt;setPassword(Passwords::hash(&#39;demo&#39;));
        $demo-&gt;addRole($this-&gt;getReference(&#39;demo-role&#39;));
        $manager-&gt;persist($demo);

        $manager-&gt;flush();

        $this-&gt;addReference(&#39;admin-user&#39;, $admin);
        $this-&gt;addReference(&#39;demo-user&#39;, $demo);
    }

}
</code></pre>
<p>V čem je to tak parádní? Používám PHP kód, používám vlastní nadefinované entity. Hned vidím, že mi to fugnuje, ověřuji svůj návrh databáze a rovnou poskytuji dalším ukázku toho, jak jsem to myslel. Za povšimnutí stojí funkce <code>addReference</code> a <code>getReference</code>. Je jasné, že v každé relační databázi budou nějaké relace a právě k tomu tyto funkce slouží. Vytvořím si tedy nějaké ukazatele a ty pak mohu použít v jiné části demo dat. Lépe to  bude vidět na druhé tabulce:</p>
<pre><code class=\\"lang-php\\">&lt;?php

use Doctrine\\\\Common\\\\Persistence\\\\ObjectManager;

class RolesFixture extends \\\\Doctrine\\\\Common\\\\DataFixtures\\\\AbstractFixture
{

    public function load(ObjectManager $manager)
    {
        $user = new \\\\Users\\\\Role();
        $user-&gt;setName(\\\\Users\\\\Role::DEMO_USER);
        $manager-&gt;persist($user);

        $admin = new \\\\Users\\\\Role();
        $admin-&gt;setName(\\\\Users\\\\Role::ADMIN);
        $manager-&gt;persist($admin);

        $manager-&gt;flush();

        $this-&gt;addReference(&#39;demo-role&#39;, $user);
        $this-&gt;addReference(&#39;admin-role&#39;, $admin);
    }

}
</code></pre>
<p>Vidíte? Mám role, vytvořím si na ně odkaz a používám je při definici uživatele. Vyzkoušejte si to. Uvidíte, jak se krásně naplní referenční tabulky a vše bude tak, jak to má být...</p>
<p>Jen pozor na jedno věc. Ohlídejte si <a href=\\"https://github.com/doctrine/data-fixtures#fixture-ordering\\">pořadí těchto objektů</a>. To lze vyřešit implementací rozhraní <code>OrderedFixtureInterface</code>, nebo <code>DependentFixtureInterface</code>, což je o něco lepší přístup.</p>
<p>A jak toto celé použít? Však už to znáte:</p>
<pre><code>λ php index.php
λ php index.php orm:schema-tool:create
λ php index.php orm:demo-data:load
</code></pre><p>První příkaz vám nabídne všechny dostupné příkazy, druhý vygeneruje strukturu databáze bez dat a poslední spustí natažení demo dat. Pak už se jen kocháte:</p>
<pre><code>λ php index.php orm:demo-data:load --demo
Careful, database will be purged. Do you want to continue Y/N ? y
  &gt; purging database
  &gt; loading RolesFixture
  &gt; loading UsersFixture
  &gt; loading ArticlesFixture
  &gt; loading ProductsFixture
  ...
</code></pre>",
        }
      }
    />
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <strong>
        Do you have any comments? That's great!
         
        <span
          className="jsx-3140515621"
        >
          <a
            className="jsx-3140515621 "
            href="https://twitter.com/home?status=https%3A%2F%2Fzlml.cz%2Ffixnete-si-databazi%20cc%20%40mrtnzlml"
          >
            Tweet them
          </a>
        </span>
         
        so everyone can hear you…
      </strong>
    </p>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
  </div>
</div>
`;
