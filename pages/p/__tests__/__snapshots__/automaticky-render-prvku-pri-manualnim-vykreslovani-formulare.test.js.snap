// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div>
  <div
    className="jsx-1307704868 wrapper"
  >
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      ¡Hola! My name is
    </p>
    <h1
      className="jsx-2345896288"
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/"
          onClick={[Function]}
        >
          Martin Zlámal
        </a>
      </span>
    </h1>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
    <h1
      className="jsx-1056554702"
    >
      Automatický render prvků při manuálním vykreslování formuláře
    </h1>
    <div
      className="jsx-1056554702 article"
      dangerouslySetInnerHTML={
        Object {
          "__html": "<p>Je čas na nějakou tu Nette divočinu. Podívejme se pod drobnohledem na to, jak funguje vykreslování prvků formuláře. Nejprve si vytvoříme úplně jednoduchý formulář, který bude obsahovat jeden prvek:</p>
<pre><code class=\\"lang-php\\">protected function createComponentContactForm()
{
    $form = new UI\\\\Form();
    $form-&gt;addSubmit(&#39;send&#39;, &#39;Odeslat&#39;);
    $form-&gt;onSuccess[] = function (UI\\\\Form $form, $values) {
        throw new \\\\Nette\\\\NotImplementedException;
    };
    return $form;
}
</code></pre>
<p>Jak bude vypadat takový formulář když jej vykreslíme pomocí <code>{control contactForm}</code>? Ve výchozím projektu asi nějak takto:</p>
<pre><code class=\\"lang-html\\">&lt;form action=&quot;/web-project/www/&quot; method=&quot;post&quot; id=&quot;frm-contactForm&quot;&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;send&quot; value=&quot;Odeslat&quot; class=&quot;button&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;input type=&quot;hidden&quot; name=&quot;_do&quot; value=&quot;contactForm-submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>Aniž se budeme nořit do detailů, tak je zřejmé, že se kromě našeho odesílacího inputu vyrenderoval i nějaký hidden input automaticky. Než se posuneme dále z tohoto úvodu, zjistíme ještě, co se stane při manuálním vykreslování:</p>
<pre><code class=\\"lang-latte\\">{form contactForm}
    {input send}
{/form}
</code></pre>
<p>Ačkoliv to není nikde dané, i v tomto případě se vykreslil další input prvek automaticky:</p>
<pre><code class=\\"lang-html\\">&lt;form action=&quot;/web-project/www/&quot; method=&quot;post&quot; id=&quot;frm-contactForm&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;send&quot; value=&quot;Odeslat&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_do&quot; value=&quot;contactForm-submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<h2 id=\\"chytr-antispam-prvek\\">Chytrý antispam prvek <a href=\\"#chytr-antispam-prvek\\">#</a></h2><p>Po krátkém úvodu (který je zcela jistě každému jasný) se přesuneme k něčemu zdánlivě jinému. Vytvoříme si chytrý antispam prvek a zjistíme, jak se bude při renderování chovat a jestli se vždy chová předvídatelně. A asi nebude překvapením, že se v určité situaci zachová moc moc špatně. Jedná se o delší kód, takže jej <a href=\\"https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a\\">najdete na Gistu</a>. Prakticky nejde o nic jiného, než že si vytvoříme vlastní antispam prvek. Tento prvek funguje tak, že vytvoří input ve kterém je nějaký text a pokud je k dispozici javascript, tak jej schová a smaže obsah. V tom případě je kontrola v pořádku, protože tiše předpokládá, že útočníkův robot nebude umět JS. Ačkoliv se to v dnešní době může zdát jako absurdní, tak to pořád funguje velmi dobře. Navíc přidává ještě pár honeypotů a doufá, že někde robot uvízne. Důležité je, že nijak neobtěžuje běžného návštěvníka - prostě to není vůbec vidět.</p>
<p>Napíšeme si jednoduché rozšíření pro DI kontejner, aby bylo možné tento nový prvek používat:</p>
<pre><code class=\\"lang-php\\">&lt;?php

namespace App;

use Nette\\\\Forms\\\\Form;

class HoneypotExtension extends \\\\Nette\\\\DI\\\\CompilerExtension
{

    public function afterCompile(\\\\Nette\\\\PhpGenerator\\\\ClassType $class)
    {
        $init = $class-&gt;methods[&#39;initialize&#39;];
        $init-&gt;addBody(self::class . &#39;::registerControlExtensionMethods();&#39;);
    }

    public static function registerControlExtensionMethods()
    {
        Form::extensionMethod(&#39;addAntispam&#39;, function (Form $form, $name = &#39;honeypot&#39;, $label = &#39;Vymažte toto pole&#39;) {
            $form[$name . &#39;_1&#39;] = new \\\\App\\\\Forms\\\\AntispamControl($name, $label);
            return $form;
        });
    }

}
</code></pre>
<p>Toto rozšíření samozřejmě zaregistrujeme v konfiguračním souboru:</p>
<pre><code class=\\"lang-neon\\">extensions:
    - App\\\\HoneypotExtension
</code></pre>
<p>A je to - v našem původním formuláři můžeme použít nový prvek:</p>
<pre><code class=\\"lang-php\\">$form = new UI\\\\Form();
$form-&gt;addAntispam();
//...
</code></pre>
<p>Je to trošku magie a IDE si s tím neporadí. Proto nebude našeptávat. V tomto případě doporučuji napsat si nějakou vlastní <code>FormFactory</code>, která bude vytváře instance <code>UI\\\\Form</code> a do této třídy doplnit anotaci <code>@method addAntispam()</code>. Udělat si vlastní továrničku na <code>UI\\\\Form</code> není vůbec špatný nápad a to nejen pro antispam. Just do it.</p>
<p>Tak a teď když máme funkční antispam a honeypoty formuláře, je čas kouknout se co se děje při renderování. Nejdříve automatické - pomocí <code>{control contactForm}</code>. Zde není co řešit. Prostě se všechny potřebná políčka vyrenderují a vše je tak, jak by mělo být. A co manuální vykreslování? Zde začíná ta nepříjemná část. Nette nemůže vědět, že by měl automaticky vykreslit i další prvky, takže je prostě nevykreslí. Praktická zkušenost je taková, že při manuálním vykreslování prostě antispam přestane fungovat. Zde se musíme ještě zasnažit.</p>
<h2 id=\\"chyt-ej-antispam-prvek\\">Chytřejší antispam prvek <a href=\\"#chyt-ej-antispam-prvek\\">#</a></h2><p>Teď musíme jít fakt na dřeň problému. Jak vlastně funguje to automatické renderování inputu při manuálním vykreslování? Existuje něco jako třída <code>Nette\\\\Bridges\\\\FormsLatte\\\\Runtime</code>, která má dvě metody: <code>renderFormBegin</code> a <code>renderFormEnd</code>. Právě druhá zmíněná přidává nějaký vlastní kód a je jedno, jestli se jedná o manuální, nebo automatické renderování formuláře. To by se nám hodilo. Vytvořme si tedy vlastní <code>Runtime</code> třídu. Není potřeba aby tato třída dědila od původní. Stačí, když si vykopírujeme metodu <code>renderFormEnd</code> a lehounce pozměníme prostřední foreach:</p>
<pre><code class=\\"lang-php\\">foreach ($form-&gt;getControls() as $control) {
    if ($control-&gt;getOption(&#39;autorender&#39;) || ($control-&gt;getOption(&#39;type&#39;) === &#39;hidden&#39; &amp;&amp; !$control-&gt;getOption(&#39;rendered&#39;))) {
        $s .= $control-&gt;getControl();
    }
}
</code></pre>
<p>Přesně tak. Všechny čáry a kouzla se aktivují, když nastavíme prvkům <code>autorender</code> (<a href=\\"https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a\\">viz Gist</a>). Jenže kde se tato třída původně používala? Kde ji použijeme nyní?</p>
<p>Řešení najdeme opět v namespace <code>Nette\\\\Bridges\\\\FormsLatte</code>, tentokrát však ve třídě <code>FormMacros</code>, která registruje formulářová makra. Vytvoříme si tedy vlastní implementaci <code>FormMacros</code> třídy, která bude dědit od původní:</p>
<pre><code class=\\"lang-php\\">class FormMacros extends \\\\Nette\\\\Bridges\\\\FormsLatte\\\\FormMacros
{

    public static function install(\\\\Latte\\\\Compiler $compiler)
    {
        $me = new static($compiler);
        $me-&gt;addMacro(&#39;form&#39;, [$me, &#39;macroForm&#39;], &#39;echo \\\\App\\\\Forms\\\\Runtime::renderFormEnd(array_pop($this-&gt;global-&gt;formsStack));&#39;);
        $me-&gt;addMacro(&#39;formContainer&#39;, [$me, &#39;macroFormContainer&#39;], &#39;array_pop($this-&gt;global-&gt;formsStack); $formContainer = $_form = end($this-&gt;global-&gt;formsStack)&#39;);
        $me-&gt;addMacro(&#39;label&#39;, [$me, &#39;macroLabel&#39;], [$me, &#39;macroLabelEnd&#39;], NULL, self::AUTO_EMPTY);
        $me-&gt;addMacro(&#39;input&#39;, [$me, &#39;macroInput&#39;]);
        $me-&gt;addMacro(&#39;name&#39;, [$me, &#39;macroName&#39;], [$me, &#39;macroNameEnd&#39;], [$me, &#39;macroNameAttr&#39;]);
        $me-&gt;addMacro(&#39;inputError&#39;, [$me, &#39;macroInputError&#39;]);
    }

}
</code></pre>
<p>Důležitá je zde registrace makra <code>{form}</code>, protože to pro svojí uzavírací značku používá novou implementaci <code>Runtime</code> (tu která podporuje autorender). Zaregistrujeme:</p>
<pre><code class=\\"lang-neon\\">latte:
    macros:
        - App\\\\Forms\\\\FormMacros::install
</code></pre>
<p>Smažeme cache a profitujeme. Nyní se autospam vykresluje automaticky i při manuálním renderování... :)</p>
<p>Podobně lze samozřejmě přidat i další kontroly jako je například kontrolní součet dvou čísel, který se javascriptem předvypočte automaticky, ale s vypnutým javascriptem se zobrazí políčka pro uživatele. Řešení tohoto antispamu je také <a href=\\"https://gist.github.com/mrtnzlml/961c3e2368e98aaa433e02c6603a5086\\">na mém Gistu</a>. Jen je potřeba trošku rozšířit <code>HoneypotExtension</code>:</p>
<pre><code class=\\"lang-php\\">public static function registerControlExtensionMethods()
{
    Form::extensionMethod(&#39;addAntispam&#39;, function (Form $form, $name = &#39;honeypot&#39;, $label = &#39;Vymažte toto pole&#39;) {
        $form[$name . &#39;_1&#39;] = new \\\\App\\\\AntispamControl($name, $label);

        $first = round(rand(0, 900), -2);
        $second = rand(0, 99);
        $validationData = self::encodeNumber($first) . &#39;;&#39; . self::encodeNumber($second);
        $form-&gt;addHidden(&#39;validationData&#39;, $validationData)-&gt;setOmitted(TRUE)-&gt;setOption(&#39;autorender&#39;, TRUE);
        $form[$name . &#39;_3&#39;] = new \\\\App\\\\Forms\\\\SumAntispamControl($first, $second, $validationData);

        return $form;
    });
}

private static function encodeNumber($originalNumber)
{
    return strtr($originalNumber, &#39;0123456789&#39;, &#39;(_.!)@-*+&amp;&#39;); //cannot contain &#39;;&#39; character
}
</code></pre>
<p>Původní kód zůstává stejný, jen jsem přidal další kontrolu a zakódoval číslice tak, aby nebylo jednoduché na první pohled poznat princip tohoto antispamu. Ve fantazii se meze nekladou.</p>
<p>A právě v tom je možná trošku problém. Zejména kvůli autorender funkci je potřeba zasahovat do vnitřností Nette a zde je již na pováženou, jestli je to dobře či nikoliv. Velké úskalí vidím v tom, že si programátor vyměňuje stavební kameny Nette za svoje trošku upravené a to nemusí být vždy hned evidentní. Pak je na zamyšlenou, jestli by nestálo za to vytvořit PR. Kdo by ale stál o takovou hovadinu... :)</p>
",
        }
      }
    />
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <strong>
        Do you have any comments? That's great!
         
        <span
          className="jsx-3140515621"
        >
          <a
            className="jsx-3140515621 "
            href="https://twitter.com/home?status=https%3A%2F%2Fzlml.cz%2Fautomaticky-render-prvku-pri-manualnim-vykreslovani-formulare%20cc%20%40mrtnzlml"
          >
            Tweet them
          </a>
        </span>
         
        so everyone can hear you…
      </strong>
    </p>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
  </div>
</div>
`;
