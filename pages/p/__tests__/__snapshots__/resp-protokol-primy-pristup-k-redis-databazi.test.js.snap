// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<div>
  <div
    className="jsx-1307704868 wrapper"
  >
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      ¡Hola! My name is
    </p>
    <h1
      className="jsx-2345896288"
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/"
          onClick={[Function]}
        >
          Martin Zlámal
        </a>
      </span>
    </h1>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
    <h1
      className="jsx-1056554702"
    >
      RESP protokol - přímý přístup k Redis databázi
    </h1>
    <div
      className="jsx-1056554702 article"
      dangerouslySetInnerHTML={
        Object {
          "__html": "<p><img src=\\"*RESP*\\" alt=\\"\\">(<a href=\\"http://redis.io/topics/protocol\\">http://redis.io/topics/protocol</a>) (<strong>RE</strong>dis <strong>S</strong>erialization <strong>P</strong>rotocol) je něco, s čím se asi většina lidí nepotká. Důvod je prostý. Tento protokol je většinou zabalen hluboko v knihovně, která pracuje s Redis databází. Existují však situace, kdy se tento protokol hodí. Jednou ze situací je stav, kdy potřebujete předat, nebo naopak získat z Redisu nějaká data a všechno ostatní vyjma RESP komunikace je zbytečné zdržování (u mě třeba sypání dat z procesoru přímo do Redisu). Druhý případ nastane v okamžiku, kdy potřebujete zajistit komunikaci klient-server a potřebujete zvolit vhodný formát přenosu informací. Jedná se tedy o použití tohoto protokolu úplně mimo Redis. Důvodů může být celá řada, nejhlavnější by však byl asi ten, že se s RESP formátem dat dá snadno pracovat, protože používá prefixový zápis.</p>
<h2 id=\\"form-t-resp-protokolu\\">Formát RESP protokolu <a href=\\"#form-t-resp-protokolu\\">#</a></h2><p>RESP používá celkem 5 způsobů jak zaobalit přenášenou informaci. Vždy však platí, že první byte je byte určující o jaký formát se jedná:</p>
<ul>
<li><code>+</code> jednoduchý string</li>
<li><code>-</code> error</li>
<li><code>:</code> integer</li>
<li><code>$</code> bulk string (binary safe)</li>
<li><code>*</code> array</li>
</ul>
<p>Následuje samotný obsah, nebo dodatečné informace, například o délce a vše je ukončeno pomocí CRLF (<code>\\\\r</code>). Postupně tedy přenášené informace moho vypadat například takto:</p>
<ul>
<li><code>+PONG\\\\r</code></li>
<li><code>-Error 123\\\\r</code></li>
<li><code>:54986\\\\r</code></li>
<li><code>$4\\\\r
PING\\\\r</code> (první část určuje délku bulk stringu, NULL je pak <code>$-1\\\\r</code>)</li>
<li><code>*2\\\\r
$3\\\\r
GET\\\\r
$3\\\\r
key\\\\r</code> (první je délka pole, následuje kombinace předchozích)</li>
</ul>
<p>To je celé, žádná věda v tom není. Je to skutečně jednoduchý protokol a to je super, protože se s ním dá snadno pracovat. Navíc lze poslat celý dlouhý text obsahující více příkazů v jednom spojení.</p>
<h2 id=\\"implementace-v-node-js\\">Implementace v Node.js <a href=\\"#implementace-v-node-js\\">#</a></h2><p>V Node.js by teď měla být realizace velmi jednoduchá. Napíšeme si krátký TCP client, který se nám napojí na Redis databázi (většinou port 6379) a budeme posílat/přijímat data:</p>
<pre><code class=\\"lang-javascript\\">var net = require(&#39;net&#39;);

var client = net.connect({port: 6379}, function() {
    console.log(&#39;Connected to the Redis server.&#39;);

    client.write(&#39;*1\\\\r
$4\\\\r
PING\\\\r
&#39;);
    client.write(&#39;*3\\\\r
$3\\\\r
SET\\\\r
$3\\\\r
key\\\\r
$5\\\\r
xxxxx\\\\r
&#39;);
    client.write(&#39;*2\\\\r
$3\\\\r
GET\\\\r
$3\\\\r
key\\\\r
&#39;);
    client.write(&#39;*5\\\\r
$5\\\\r
PFADD\\\\r
$11\\\\r
HyperLogLog\\\\r
$3\\\\r
xxx\\\\r
$3\\\\r
yyy\\\\r
$3\\\\r
zzz\\\\r
&#39;);
    client.write(&#39;*2\\\\r
$7\\\\r
PFCOUNT\\\\r
$11\\\\r
HyperLogLog\\\\r
&#39;);

    client.write(&#39;*1\\\\r
$7\\\\r
FLUSHDB\\\\r
&#39;);
});

client.on(&#39;data&#39;, function(data) {
    console.log(data.toString());
    client.end();
});

client.on(&#39;end&#39;, function() {
    console.log(&#39;Disconnected from the Redis server.&#39;);
});
</code></pre>
<p><span style=\\"color:green\\">Ještě jednu poznámku, kterou jsem do původního článku nezahrnul. Proč jsou udesílaná data zabalena v RESP poli? Vychází to z toho, že podle dokumentace, by klient měl posílat na server pole bulk stringů. Nicméně dobře funkční a validní zápis je i bez pole (<code>client.write(&#39;GET key\\\\r
&#39;);</code>) jen musí být opět ukončen pomocí CRLF.</span></p>
<p>Odesíláme do Redis databáze celkem 6 příkazů. První je obyčejný <code>PING</code>, následuje <code>SET</code> a <code>GET</code> klíče, <code>PFADD</code> a <code>PFCOUNT</code> z HyperLogLog datového dypu a nakonec jen smazání databáze. Co bude výstupem?</p>
<pre><code>+PONG
+OK
$5
xxxxx
:0
:3
+OK
</code></pre><p>Jak je možné, že server vrátil 7 odpovědí? Je to prosté, upravíme si datový callback ať je zřejmé, co skutečně dostáváme za data:</p>
<pre><code class=\\"lang-javascript\\">client.on(&#39;data&#39;, function(data) {
    console.log(JSON.stringify(data.toString()));
    client.end();
});
</code></pre>
<p>Teď už bude výstup o něco jiný:</p>
<pre><code>&quot;+PONG\\\\r
+OK\\\\r
$5\\\\r
xxxxx\\\\r
:0\\\\r
:3\\\\r
+OK\\\\r
&quot;
</code></pre><p>A vše již dává smysl. První odpověď je <code>PONG</code> (na <code>PING</code>), následuje reakce <code>OK</code> na nastavení klíče, odpověď ve formě bulk stringu, který má dvě části - délku a samotnou textovou odpověď (proto to odřádkování navíc), následuje odpověď z <code>PFADD</code> (0 nebo 1 podle situace) a také odpověď z <code>PFCOUNT</code> (mohutnost množiny v HyperLogLog). Poslední <code>OK</code> je reakce na <code>FLUSHDB</code>. Jak je vidět, tak i v odpovědi je prvním znakem formát dat dané odpovědi.</p>
<p>Takto jsem to celkem zbytečně (ale pro přehlednost) rozepisoval. Celá komunikace směrem k serveru by se dala napsat do jednoho požadavku:</p>
<pre><code>*1\\\\r
$4\\\\r
PING\\\\r
*3\\\\r
$3\\\\r
SET\\\\r
$3\\\\r
key\\\\r
$5\\\\r
xxxxx\\\\r
*2\\\\r
$3\\\\r
GET\\\\r
$3\\\\r
key\\\\r
*5\\\\r
$5\\\\r
PFADD\\\\r
$11\\\\r
HyperLogLog\\\\r
$3\\\\r
xxx\\\\r
$3\\\\r
yyy\\\\r
$3\\\\r
zzz\\\\r
*2\\\\r
$7\\\\r
PFCOUNT\\\\r
$11\\\\r
HyperLogLog\\\\r
*1\\\\r
$7\\\\r
FLUSHDB\\\\r
</code></pre><p>Odpověď by zůstala stejná.</p>
",
        }
      }
    />
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <strong>
        Do you have any comments? That's great!
         
        <span
          className="jsx-3140515621"
        >
          <a
            className="jsx-3140515621 "
            href="https://twitter.com/home?status=https%3A%2F%2Fzlml.cz%2Fresp-protokol-primy-pristup-k-redis-databazi%20cc%20%40mrtnzlml"
          >
            Tweet them
          </a>
        </span>
         
        so everyone can hear you…
      </strong>
    </p>
    <p
      style={
        Object {
          "fontSize": "2rem",
          "hyphens": "auto",
          "textAlign": "justify",
        }
      }
    >
      <span
        className="jsx-3140515621"
      >
        <a
          className="jsx-3140515621"
          href="/archive"
          onClick={[Function]}
        >
          ← back to the archive
        </a>
      </span>
    </p>
  </div>
</div>
`;
